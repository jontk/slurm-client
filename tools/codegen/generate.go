//go:build ignore

package main

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
)

// Code generation tool for Slurm REST API clients using oapi-codegen
func main() {
	if len(os.Args) < 2 {
		log.Fatal("Usage: go run generate.go <version> [spec-file]")
	}
	
	version := os.Args[1]
	var specFile string
	
	if len(os.Args) >= 3 {
		specFile = os.Args[2]
	} else {
		specFile = filepath.Join("openapi-specs", fmt.Sprintf("slurm-%s.json", version))
	}
	
	if err := generateClient(version, specFile); err != nil {
		log.Fatalf("Failed to generate client for %s: %v", version, err)
	}
	
	fmt.Printf("Successfully generated client for version %s\n", version)
}

func generateClient(version, specFile string) error {
	// Check if spec file exists
	if _, err := os.Stat(specFile); os.IsNotExist(err) {
		return fmt.Errorf("OpenAPI spec file not found: %s", specFile)
	}
	
	// Ensure output directory exists
	outputDir := filepath.Join("internal", "api", normalizeVersion(version))
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}
	
	outputFile := filepath.Join(outputDir, "client.go")
	
	// Generate client using oapi-codegen
	cmd := exec.Command("/Users/jontk/go/bin/oapi-codegen",
		"-package", normalizeVersion(version),
		"-generate", "client,models,spec",
		"-o", outputFile,
		specFile,
	)
	
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("oapi-codegen failed: %w", err)
	}
	
	// Generate wrapper client
	if err := generateWrapper(version, outputDir); err != nil {
		return err
	}
	
	// Generate managers
	return generateManagers(version, outputDir)
}

func generateWrapper(version, outputDir string) error {
	wrapperFile := filepath.Join(outputDir, "wrapper.go")
	
	content := fmt.Sprintf(`// Code generated by tools/codegen/generate.go; DO NOT EDIT.

package %s

import (
	"net/http"
	
	"github.com/jontk/slurm-client/internal/interfaces"
)

// WrapperClient implements the SlurmClient interface for API version %s
type WrapperClient struct {
	apiClient *ClientWithResponses
	config    *interfaces.ClientConfig
}

// NewWrapperClient creates a new %s client
func NewWrapperClient(config *interfaces.ClientConfig) (*WrapperClient, error) {
	// Create HTTP client with authentication
	httpClient := config.HTTPClient
	if httpClient == nil {
		httpClient = &http.Client{}
	}
	
	// Create oapi-codegen client
	apiClient, err := NewClientWithResponses(config.BaseURL, WithHTTPClient(httpClient))
	if err != nil {
		return nil, err
	}
	
	return &WrapperClient{
		apiClient: apiClient,
		config:    config,
	}, nil
}

// Version returns the API version
func (c *WrapperClient) Version() string {
	return "%s"
}

// Jobs returns the JobManager
func (c *WrapperClient) Jobs() interfaces.JobManager {
	return &JobManager{client: c}
}

// Nodes returns the NodeManager  
func (c *WrapperClient) Nodes() interfaces.NodeManager {
	return &NodeManager{client: c}
}

// Partitions returns the PartitionManager
func (c *WrapperClient) Partitions() interfaces.PartitionManager {
	return &PartitionManager{client: c}
}

// Info returns the InfoManager
func (c *WrapperClient) Info() interfaces.InfoManager {
	return &InfoManager{client: c}
}

// Reservations returns the ReservationManager
func (c *WrapperClient) Reservations() interfaces.ReservationManager {
	%s
}

// QoS returns the QoSManager
func (c *WrapperClient) QoS() interfaces.QoSManager {
	%s
}

// Close closes the client
func (c *WrapperClient) Close() error {
	// No resources to close for HTTP client
	return nil
}
`, normalizeVersion(version), version, version, version, getReservationsImplementation(version), getQoSImplementation(version))
	
	return os.WriteFile(wrapperFile, []byte(content), 0644)
}

func normalizeVersion(version string) string {
	// Convert v0.0.42 to v0_0_42 for package names
	if len(version) > 0 && version[0] == 'v' {
		version = version[1:]
	}
	
	result := "v"
	for _, char := range version {
		if char == '.' {
			result += "_"
		} else {
			result += string(char)
		}
	}
	
	return result
}

func getReservationsImplementation(version string) string {
	// Only v0.0.43 and later support reservations
	if version == "v0.0.43" {
		return "return &ReservationManager{client: c}"
	}
	// Earlier versions return nil
	return "return nil"
}

func getQoSImplementation(version string) string {
	// Only v0.0.43 and later support QoS
	if version == "v0.0.43" {
		return "return &QoSManager{client: c}"
	}
	// Earlier versions return nil
	return "return nil"
}

func generateManagers(version, outputDir string) error {
	managersFile := filepath.Join(outputDir, "managers.go")
	
	content := fmt.Sprintf(`// Code generated by tools/codegen/generate.go; DO NOT EDIT.

package %s

import (
	"context"
	
	"github.com/jontk/slurm-client/internal/interfaces"
)

// JobManager implements the JobManager interface for API version %s
type JobManager struct {
	client *WrapperClient
	impl   *JobManagerImpl
}

// List jobs with optional filtering
func (m *JobManager) List(ctx context.Context, opts *interfaces.ListJobsOptions) (*interfaces.JobList, error) {
	if m.impl == nil {
		m.impl = NewJobManagerImpl(m.client)
	}
	return m.impl.List(ctx, opts)
}

// Get retrieves a specific job by ID
func (m *JobManager) Get(ctx context.Context, jobID string) (*interfaces.Job, error) {
	if m.impl == nil {
		m.impl = NewJobManagerImpl(m.client)
	}
	return m.impl.Get(ctx, jobID)
}

// Submit submits a new job
func (m *JobManager) Submit(ctx context.Context, job *interfaces.JobSubmission) (*interfaces.JobSubmitResponse, error) {
	if m.impl == nil {
		m.impl = NewJobManagerImpl(m.client)
	}
	return m.impl.Submit(ctx, job)
}

// Cancel cancels a job
func (m *JobManager) Cancel(ctx context.Context, jobID string) error {
	if m.impl == nil {
		m.impl = NewJobManagerImpl(m.client)
	}
	return m.impl.Cancel(ctx, jobID)
}

// Update updates job properties
func (m *JobManager) Update(ctx context.Context, jobID string, update *interfaces.JobUpdate) error {
	if m.impl == nil {
		m.impl = NewJobManagerImpl(m.client)
	}
	return m.impl.Update(ctx, jobID, update)
}

// Steps retrieves job steps for a job
func (m *JobManager) Steps(ctx context.Context, jobID string) (*interfaces.JobStepList, error) {
	if m.impl == nil {
		m.impl = NewJobManagerImpl(m.client)
	}
	return m.impl.Steps(ctx, jobID)
}

// Watch provides real-time job updates
func (m *JobManager) Watch(ctx context.Context, opts *interfaces.WatchJobsOptions) (<-chan interfaces.JobEvent, error) {
	if m.impl == nil {
		m.impl = NewJobManagerImpl(m.client)
	}
	return m.impl.Watch(ctx, opts)
}

// NodeManager implements the NodeManager interface for API version %s
type NodeManager struct {
	client *WrapperClient
	impl   *NodeManagerImpl
}

// List nodes with optional filtering
func (m *NodeManager) List(ctx context.Context, opts *interfaces.ListNodesOptions) (*interfaces.NodeList, error) {
	if m.impl == nil {
		m.impl = NewNodeManagerImpl(m.client)
	}
	return m.impl.List(ctx, opts)
}

// Get retrieves a specific node by name
func (m *NodeManager) Get(ctx context.Context, nodeName string) (*interfaces.Node, error) {
	if m.impl == nil {
		m.impl = NewNodeManagerImpl(m.client)
	}
	return m.impl.Get(ctx, nodeName)
}

// Update updates node properties
func (m *NodeManager) Update(ctx context.Context, nodeName string, update *interfaces.NodeUpdate) error {
	if m.impl == nil {
		m.impl = NewNodeManagerImpl(m.client)
	}
	return m.impl.Update(ctx, nodeName, update)
}

// Watch provides real-time node updates
func (m *NodeManager) Watch(ctx context.Context, opts *interfaces.WatchNodesOptions) (<-chan interfaces.NodeEvent, error) {
	if m.impl == nil {
		m.impl = NewNodeManagerImpl(m.client)
	}
	return m.impl.Watch(ctx, opts)
}

// PartitionManager implements the PartitionManager interface for API version %s
type PartitionManager struct {
	client *WrapperClient
	impl   *PartitionManagerImpl
}

// List partitions with optional filtering
func (m *PartitionManager) List(ctx context.Context, opts *interfaces.ListPartitionsOptions) (*interfaces.PartitionList, error) {
	if m.impl == nil {
		m.impl = NewPartitionManagerImpl(m.client)
	}
	return m.impl.List(ctx, opts)
}

// Get retrieves a specific partition by name
func (m *PartitionManager) Get(ctx context.Context, partitionName string) (*interfaces.Partition, error) {
	if m.impl == nil {
		m.impl = NewPartitionManagerImpl(m.client)
	}
	return m.impl.Get(ctx, partitionName)
}

// Update updates partition properties
func (m *PartitionManager) Update(ctx context.Context, partitionName string, update *interfaces.PartitionUpdate) error {
	if m.impl == nil {
		m.impl = NewPartitionManagerImpl(m.client)
	}
	return m.impl.Update(ctx, partitionName, update)
}

// Watch provides real-time partition updates
func (m *PartitionManager) Watch(ctx context.Context, opts *interfaces.WatchPartitionsOptions) (<-chan interfaces.PartitionEvent, error) {
	if m.impl == nil {
		m.impl = NewPartitionManagerImpl(m.client)
	}
	return m.impl.Watch(ctx, opts)
}

// InfoManager implements the InfoManager interface for API version %s
type InfoManager struct {
	client *WrapperClient
	impl   *InfoManagerImpl
}

// Get retrieves cluster information
func (m *InfoManager) Get(ctx context.Context) (*interfaces.ClusterInfo, error) {
	if m.impl == nil {
		m.impl = NewInfoManagerImpl(m.client)
	}
	return m.impl.Get(ctx)
}

// Ping tests connectivity to the cluster
func (m *InfoManager) Ping(ctx context.Context) error {
	if m.impl == nil {
		m.impl = NewInfoManagerImpl(m.client)
	}
	return m.impl.Ping(ctx)
}

// Stats retrieves cluster statistics
func (m *InfoManager) Stats(ctx context.Context) (*interfaces.ClusterStats, error) {
	if m.impl == nil {
		m.impl = NewInfoManagerImpl(m.client)
	}
	return m.impl.Stats(ctx)
}

// Version retrieves API version information
func (m *InfoManager) Version(ctx context.Context) (*interfaces.APIVersion, error) {
	if m.impl == nil {
		m.impl = NewInfoManagerImpl(m.client)
	}
	return m.impl.Version(ctx)
}
`, normalizeVersion(version), version, version, version, version)
	
	return os.WriteFile(managersFile, []byte(content), 0644)
}