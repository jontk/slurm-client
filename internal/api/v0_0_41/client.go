// Package v0_0_41 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v0_0_41

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	TokenScopes      = "token.Scopes"
	UserScopes       = "user.Scopes"
)

// Defines values for V0041OpenapiAccountsRespAccountsFlags.
const (
	V0041OpenapiAccountsRespAccountsFlagsDELETED          V0041OpenapiAccountsRespAccountsFlags = "DELETED"
	V0041OpenapiAccountsRespAccountsFlagsNoUsersAreCoords V0041OpenapiAccountsRespAccountsFlags = "NoUsersAreCoords"
	V0041OpenapiAccountsRespAccountsFlagsUsersAreCoords   V0041OpenapiAccountsRespAccountsFlags = "UsersAreCoords"
	V0041OpenapiAccountsRespAccountsFlagsWithAssociations V0041OpenapiAccountsRespAccountsFlags = "WithAssociations"
	V0041OpenapiAccountsRespAccountsFlagsWithCoordinators V0041OpenapiAccountsRespAccountsFlags = "WithCoordinators"
)

// Defines values for V0041OpenapiAssocsRespAssociationsFlags.
const (
	V0041OpenapiAssocsRespAssociationsFlagsDELETED          V0041OpenapiAssocsRespAssociationsFlags = "DELETED"
	V0041OpenapiAssocsRespAssociationsFlagsExact            V0041OpenapiAssocsRespAssociationsFlags = "Exact"
	V0041OpenapiAssocsRespAssociationsFlagsNoUpdate         V0041OpenapiAssocsRespAssociationsFlags = "NoUpdate"
	V0041OpenapiAssocsRespAssociationsFlagsNoUsersAreCoords V0041OpenapiAssocsRespAssociationsFlags = "NoUsersAreCoords"
	V0041OpenapiAssocsRespAssociationsFlagsUsersAreCoords   V0041OpenapiAssocsRespAssociationsFlags = "UsersAreCoords"
)

// Defines values for V0041OpenapiClustersRespClustersFlags.
const (
	V0041OpenapiClustersRespClustersFlagsEXTERNAL       V0041OpenapiClustersRespClustersFlags = "EXTERNAL"
	V0041OpenapiClustersRespClustersFlagsFEDERATION     V0041OpenapiClustersRespClustersFlags = "FEDERATION"
	V0041OpenapiClustersRespClustersFlagsMULTIPLESLURMD V0041OpenapiClustersRespClustersFlags = "MULTIPLE_SLURMD"
	V0041OpenapiClustersRespClustersFlagsREGISTERING    V0041OpenapiClustersRespClustersFlags = "REGISTERING"
)

// Defines values for V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus.
const (
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusCOREDUMPED V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusERROR      V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "ERROR"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusINVALID    V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "INVALID"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusPENDING    V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "PENDING"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusSIGNALED   V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "SIGNALED"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusSUCCESS    V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiJobInfoRespJobsExclusive.
const (
	V0041OpenapiJobInfoRespJobsExclusiveFalse V0041OpenapiJobInfoRespJobsExclusive = "false"
	V0041OpenapiJobInfoRespJobsExclusiveMcs   V0041OpenapiJobInfoRespJobsExclusive = "mcs"
	V0041OpenapiJobInfoRespJobsExclusiveTopo  V0041OpenapiJobInfoRespJobsExclusive = "topo"
	V0041OpenapiJobInfoRespJobsExclusiveTrue  V0041OpenapiJobInfoRespJobsExclusive = "true"
	V0041OpenapiJobInfoRespJobsExclusiveUser  V0041OpenapiJobInfoRespJobsExclusive = "user"
)

// Defines values for V0041OpenapiJobInfoRespJobsExitCodeStatus.
const (
	V0041OpenapiJobInfoRespJobsExitCodeStatusCOREDUMPED V0041OpenapiJobInfoRespJobsExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiJobInfoRespJobsExitCodeStatusERROR      V0041OpenapiJobInfoRespJobsExitCodeStatus = "ERROR"
	V0041OpenapiJobInfoRespJobsExitCodeStatusINVALID    V0041OpenapiJobInfoRespJobsExitCodeStatus = "INVALID"
	V0041OpenapiJobInfoRespJobsExitCodeStatusPENDING    V0041OpenapiJobInfoRespJobsExitCodeStatus = "PENDING"
	V0041OpenapiJobInfoRespJobsExitCodeStatusSIGNALED   V0041OpenapiJobInfoRespJobsExitCodeStatus = "SIGNALED"
	V0041OpenapiJobInfoRespJobsExitCodeStatusSUCCESS    V0041OpenapiJobInfoRespJobsExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiJobInfoRespJobsFlags.
const (
	V0041OpenapiJobInfoRespJobsFlagsACCRUECOUNTCLEARED       V0041OpenapiJobInfoRespJobsFlags = "ACCRUE_COUNT_CLEARED"
	V0041OpenapiJobInfoRespJobsFlagsBACKFILLATTEMPTED        V0041OpenapiJobInfoRespJobsFlags = "BACKFILL_ATTEMPTED"
	V0041OpenapiJobInfoRespJobsFlagsCRONJOB                  V0041OpenapiJobInfoRespJobsFlags = "CRON_JOB"
	V0041OpenapiJobInfoRespJobsFlagsDEPENDENT                V0041OpenapiJobInfoRespJobsFlags = "DEPENDENT"
	V0041OpenapiJobInfoRespJobsFlagsEXACTCPUCOUNTREQUESTED   V0041OpenapiJobInfoRespJobsFlags = "EXACT_CPU_COUNT_REQUESTED"
	V0041OpenapiJobInfoRespJobsFlagsEXACTMEMORYREQUESTED     V0041OpenapiJobInfoRespJobsFlags = "EXACT_MEMORY_REQUESTED"
	V0041OpenapiJobInfoRespJobsFlagsEXACTTASKCOUNTREQUESTED  V0041OpenapiJobInfoRespJobsFlags = "EXACT_TASK_COUNT_REQUESTED"
	V0041OpenapiJobInfoRespJobsFlagsGRESBINDINGDISABLED      V0041OpenapiJobInfoRespJobsFlags = "GRES_BINDING_DISABLED"
	V0041OpenapiJobInfoRespJobsFlagsGRESBINDINGENFORCED      V0041OpenapiJobInfoRespJobsFlags = "GRES_BINDING_ENFORCED"
	V0041OpenapiJobInfoRespJobsFlagsHASSTATEDIRECTORY        V0041OpenapiJobInfoRespJobsFlags = "HAS_STATE_DIRECTORY"
	V0041OpenapiJobInfoRespJobsFlagsHETEROGENEOUSJOB         V0041OpenapiJobInfoRespJobsFlags = "HETEROGENEOUS_JOB"
	V0041OpenapiJobInfoRespJobsFlagsJOBACCRUETIMERESET       V0041OpenapiJobInfoRespJobsFlags = "JOB_ACCRUE_TIME_RESET"
	V0041OpenapiJobInfoRespJobsFlagsJOBKILLHURRY             V0041OpenapiJobInfoRespJobsFlags = "JOB_KILL_HURRY"
	V0041OpenapiJobInfoRespJobsFlagsJOBWASRUNNING            V0041OpenapiJobInfoRespJobsFlags = "JOB_WAS_RUNNING"
	V0041OpenapiJobInfoRespJobsFlagsKILLINVALIDDEPENDENCY    V0041OpenapiJobInfoRespJobsFlags = "KILL_INVALID_DEPENDENCY"
	V0041OpenapiJobInfoRespJobsFlagsMAGNETIC                 V0041OpenapiJobInfoRespJobsFlags = "MAGNETIC"
	V0041OpenapiJobInfoRespJobsFlagsNOKILLINVALIDDEPENDENCY  V0041OpenapiJobInfoRespJobsFlags = "NO_KILL_INVALID_DEPENDENCY"
	V0041OpenapiJobInfoRespJobsFlagsPARTITIONASSIGNED        V0041OpenapiJobInfoRespJobsFlags = "PARTITION_ASSIGNED"
	V0041OpenapiJobInfoRespJobsFlagsPREFERMINIMUMNODECOUNT   V0041OpenapiJobInfoRespJobsFlags = "PREFER_MINIMUM_NODE_COUNT"
	V0041OpenapiJobInfoRespJobsFlagsSCHEDULINGATTEMPTED      V0041OpenapiJobInfoRespJobsFlags = "SCHEDULING_ATTEMPTED"
	V0041OpenapiJobInfoRespJobsFlagsSENDJOBENVIRONMENT       V0041OpenapiJobInfoRespJobsFlags = "SEND_JOB_ENVIRONMENT"
	V0041OpenapiJobInfoRespJobsFlagsSIBLINGCLUSTERUPDATEONLY V0041OpenapiJobInfoRespJobsFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	V0041OpenapiJobInfoRespJobsFlagsSKIPTRESSTRINGACCOUNTING V0041OpenapiJobInfoRespJobsFlags = "SKIP_TRES_STRING_ACCOUNTING"
	V0041OpenapiJobInfoRespJobsFlagsSPREADJOB                V0041OpenapiJobInfoRespJobsFlags = "SPREAD_JOB"
	V0041OpenapiJobInfoRespJobsFlagsSTEPMGRENABLED           V0041OpenapiJobInfoRespJobsFlags = "STEPMGR_ENABLED"
	V0041OpenapiJobInfoRespJobsFlagsTESTINGBACKFILL          V0041OpenapiJobInfoRespJobsFlags = "TESTING_BACKFILL"
	V0041OpenapiJobInfoRespJobsFlagsTESTINGWHOLENODEBACKFILL V0041OpenapiJobInfoRespJobsFlags = "TESTING_WHOLE_NODE_BACKFILL"
	V0041OpenapiJobInfoRespJobsFlagsTESTNOWONLY              V0041OpenapiJobInfoRespJobsFlags = "TEST_NOW_ONLY"
	V0041OpenapiJobInfoRespJobsFlagsTOPPRIORITYJOB           V0041OpenapiJobInfoRespJobsFlags = "TOP_PRIORITY_JOB"
	V0041OpenapiJobInfoRespJobsFlagsUSINGDEFAULTACCOUNT      V0041OpenapiJobInfoRespJobsFlags = "USING_DEFAULT_ACCOUNT"
	V0041OpenapiJobInfoRespJobsFlagsUSINGDEFAULTPARTITION    V0041OpenapiJobInfoRespJobsFlags = "USING_DEFAULT_PARTITION"
	V0041OpenapiJobInfoRespJobsFlagsUSINGDEFAULTQOS          V0041OpenapiJobInfoRespJobsFlags = "USING_DEFAULT_QOS"
	V0041OpenapiJobInfoRespJobsFlagsUSINGDEFAULTWCKEY        V0041OpenapiJobInfoRespJobsFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus.
const (
	V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatusALLOCATED   V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus = "ALLOCATED"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatusINUSE       V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus = "IN_USE"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatusINVALID     V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus = "INVALID"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatusUNALLOCATED V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus = "UNALLOCATED"
)

// Defines values for V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType.
const (
	V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectTypeAVAILABLE V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType = "AVAILABLE"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectTypeONEROW    V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType = "ONE_ROW"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectTypeRESERVED  V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType = "RESERVED"
)

// Defines values for V0041OpenapiJobInfoRespJobsJobResourcesSelectType.
const (
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeBOARD                V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "BOARD"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeCORE                 V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "CORE"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeCOREDEFAULTDISTBLOCK V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "CORE_DEFAULT_DIST_BLOCK"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeCPU                  V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "CPU"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeLINEAR               V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "LINEAR"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeLLN                  V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "LLN"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeMEMORY               V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "MEMORY"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeONETASKPERCORE       V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "ONE_TASK_PER_CORE"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypePACKNODES            V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "PACK_NODES"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeSOCKET               V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "SOCKET"
)

// Defines values for V0041OpenapiJobInfoRespJobsJobState.
const (
	V0041OpenapiJobInfoRespJobsJobStateBOOTFAIL     V0041OpenapiJobInfoRespJobsJobState = "BOOT_FAIL"
	V0041OpenapiJobInfoRespJobsJobStateCANCELLED    V0041OpenapiJobInfoRespJobsJobState = "CANCELLED"
	V0041OpenapiJobInfoRespJobsJobStateCOMPLETED    V0041OpenapiJobInfoRespJobsJobState = "COMPLETED"
	V0041OpenapiJobInfoRespJobsJobStateCOMPLETING   V0041OpenapiJobInfoRespJobsJobState = "COMPLETING"
	V0041OpenapiJobInfoRespJobsJobStateCONFIGURING  V0041OpenapiJobInfoRespJobsJobState = "CONFIGURING"
	V0041OpenapiJobInfoRespJobsJobStateDEADLINE     V0041OpenapiJobInfoRespJobsJobState = "DEADLINE"
	V0041OpenapiJobInfoRespJobsJobStateFAILED       V0041OpenapiJobInfoRespJobsJobState = "FAILED"
	V0041OpenapiJobInfoRespJobsJobStateLAUNCHFAILED V0041OpenapiJobInfoRespJobsJobState = "LAUNCH_FAILED"
	V0041OpenapiJobInfoRespJobsJobStateNODEFAIL     V0041OpenapiJobInfoRespJobsJobState = "NODE_FAIL"
	V0041OpenapiJobInfoRespJobsJobStateOUTOFMEMORY  V0041OpenapiJobInfoRespJobsJobState = "OUT_OF_MEMORY"
	V0041OpenapiJobInfoRespJobsJobStatePENDING      V0041OpenapiJobInfoRespJobsJobState = "PENDING"
	V0041OpenapiJobInfoRespJobsJobStatePOWERUPNODE  V0041OpenapiJobInfoRespJobsJobState = "POWER_UP_NODE"
	V0041OpenapiJobInfoRespJobsJobStatePREEMPTED    V0041OpenapiJobInfoRespJobsJobState = "PREEMPTED"
	V0041OpenapiJobInfoRespJobsJobStateRECONFIGFAIL V0041OpenapiJobInfoRespJobsJobState = "RECONFIG_FAIL"
	V0041OpenapiJobInfoRespJobsJobStateREQUEUED     V0041OpenapiJobInfoRespJobsJobState = "REQUEUED"
	V0041OpenapiJobInfoRespJobsJobStateREQUEUEFED   V0041OpenapiJobInfoRespJobsJobState = "REQUEUE_FED"
	V0041OpenapiJobInfoRespJobsJobStateREQUEUEHOLD  V0041OpenapiJobInfoRespJobsJobState = "REQUEUE_HOLD"
	V0041OpenapiJobInfoRespJobsJobStateRESIZING     V0041OpenapiJobInfoRespJobsJobState = "RESIZING"
	V0041OpenapiJobInfoRespJobsJobStateRESVDELHOLD  V0041OpenapiJobInfoRespJobsJobState = "RESV_DEL_HOLD"
	V0041OpenapiJobInfoRespJobsJobStateREVOKED      V0041OpenapiJobInfoRespJobsJobState = "REVOKED"
	V0041OpenapiJobInfoRespJobsJobStateRUNNING      V0041OpenapiJobInfoRespJobsJobState = "RUNNING"
	V0041OpenapiJobInfoRespJobsJobStateSIGNALING    V0041OpenapiJobInfoRespJobsJobState = "SIGNALING"
	V0041OpenapiJobInfoRespJobsJobStateSPECIALEXIT  V0041OpenapiJobInfoRespJobsJobState = "SPECIAL_EXIT"
	V0041OpenapiJobInfoRespJobsJobStateSTAGEOUT     V0041OpenapiJobInfoRespJobsJobState = "STAGE_OUT"
	V0041OpenapiJobInfoRespJobsJobStateSTOPPED      V0041OpenapiJobInfoRespJobsJobState = "STOPPED"
	V0041OpenapiJobInfoRespJobsJobStateSUSPENDED    V0041OpenapiJobInfoRespJobsJobState = "SUSPENDED"
	V0041OpenapiJobInfoRespJobsJobStateTIMEOUT      V0041OpenapiJobInfoRespJobsJobState = "TIMEOUT"
)

// Defines values for V0041OpenapiJobInfoRespJobsMailType.
const (
	V0041OpenapiJobInfoRespJobsMailTypeARRAYTASKS        V0041OpenapiJobInfoRespJobsMailType = "ARRAY_TASKS"
	V0041OpenapiJobInfoRespJobsMailTypeBEGIN             V0041OpenapiJobInfoRespJobsMailType = "BEGIN"
	V0041OpenapiJobInfoRespJobsMailTypeEND               V0041OpenapiJobInfoRespJobsMailType = "END"
	V0041OpenapiJobInfoRespJobsMailTypeFAIL              V0041OpenapiJobInfoRespJobsMailType = "FAIL"
	V0041OpenapiJobInfoRespJobsMailTypeINVALIDDEPENDENCY V0041OpenapiJobInfoRespJobsMailType = "INVALID_DEPENDENCY"
	V0041OpenapiJobInfoRespJobsMailTypeREQUEUE           V0041OpenapiJobInfoRespJobsMailType = "REQUEUE"
	V0041OpenapiJobInfoRespJobsMailTypeSTAGEOUT          V0041OpenapiJobInfoRespJobsMailType = "STAGE_OUT"
	V0041OpenapiJobInfoRespJobsMailTypeTIME100           V0041OpenapiJobInfoRespJobsMailType = "TIME=100%"
	V0041OpenapiJobInfoRespJobsMailTypeTIME50            V0041OpenapiJobInfoRespJobsMailType = "TIME=50%"
	V0041OpenapiJobInfoRespJobsMailTypeTIME80            V0041OpenapiJobInfoRespJobsMailType = "TIME=80%"
	V0041OpenapiJobInfoRespJobsMailTypeTIME90            V0041OpenapiJobInfoRespJobsMailType = "TIME=90%"
)

// Defines values for V0041OpenapiJobInfoRespJobsProfile.
const (
	V0041OpenapiJobInfoRespJobsProfileENERGY  V0041OpenapiJobInfoRespJobsProfile = "ENERGY"
	V0041OpenapiJobInfoRespJobsProfileLUSTRE  V0041OpenapiJobInfoRespJobsProfile = "LUSTRE"
	V0041OpenapiJobInfoRespJobsProfileNETWORK V0041OpenapiJobInfoRespJobsProfile = "NETWORK"
	V0041OpenapiJobInfoRespJobsProfileNONE    V0041OpenapiJobInfoRespJobsProfile = "NONE"
	V0041OpenapiJobInfoRespJobsProfileNOTSET  V0041OpenapiJobInfoRespJobsProfile = "NOT_SET"
	V0041OpenapiJobInfoRespJobsProfileTASK    V0041OpenapiJobInfoRespJobsProfile = "TASK"
)

// Defines values for V0041OpenapiJobInfoRespJobsShared.
const (
	V0041OpenapiJobInfoRespJobsSharedMcs           V0041OpenapiJobInfoRespJobsShared = "mcs"
	V0041OpenapiJobInfoRespJobsSharedNone          V0041OpenapiJobInfoRespJobsShared = "none"
	V0041OpenapiJobInfoRespJobsSharedOversubscribe V0041OpenapiJobInfoRespJobsShared = "oversubscribe"
	V0041OpenapiJobInfoRespJobsSharedTopo          V0041OpenapiJobInfoRespJobsShared = "topo"
	V0041OpenapiJobInfoRespJobsSharedUser          V0041OpenapiJobInfoRespJobsShared = "user"
)

// Defines values for V0041OpenapiJobInfoRespJobsShowFlags.
const (
	V0041OpenapiJobInfoRespJobsShowFlagsALL        V0041OpenapiJobInfoRespJobsShowFlags = "ALL"
	V0041OpenapiJobInfoRespJobsShowFlagsDETAIL     V0041OpenapiJobInfoRespJobsShowFlags = "DETAIL"
	V0041OpenapiJobInfoRespJobsShowFlagsFEDERATION V0041OpenapiJobInfoRespJobsShowFlags = "FEDERATION"
	V0041OpenapiJobInfoRespJobsShowFlagsFUTURE     V0041OpenapiJobInfoRespJobsShowFlags = "FUTURE"
	V0041OpenapiJobInfoRespJobsShowFlagsLOCAL      V0041OpenapiJobInfoRespJobsShowFlags = "LOCAL"
	V0041OpenapiJobInfoRespJobsShowFlagsMIXED      V0041OpenapiJobInfoRespJobsShowFlags = "MIXED"
	V0041OpenapiJobInfoRespJobsShowFlagsSIBLING    V0041OpenapiJobInfoRespJobsShowFlags = "SIBLING"
)

// Defines values for V0041OpenapiNodesRespNodesNextStateAfterReboot.
const (
	V0041OpenapiNodesRespNodesNextStateAfterRebootALLOCATED       V0041OpenapiNodesRespNodesNextStateAfterReboot = "ALLOCATED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootCLOUD           V0041OpenapiNodesRespNodesNextStateAfterReboot = "CLOUD"
	V0041OpenapiNodesRespNodesNextStateAfterRebootCOMPLETING      V0041OpenapiNodesRespNodesNextStateAfterReboot = "COMPLETING"
	V0041OpenapiNodesRespNodesNextStateAfterRebootDOWN            V0041OpenapiNodesRespNodesNextStateAfterReboot = "DOWN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootDRAIN           V0041OpenapiNodesRespNodesNextStateAfterReboot = "DRAIN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootDYNAMICFUTURE   V0041OpenapiNodesRespNodesNextStateAfterReboot = "DYNAMIC_FUTURE"
	V0041OpenapiNodesRespNodesNextStateAfterRebootDYNAMICNORM     V0041OpenapiNodesRespNodesNextStateAfterReboot = "DYNAMIC_NORM"
	V0041OpenapiNodesRespNodesNextStateAfterRebootERROR           V0041OpenapiNodesRespNodesNextStateAfterReboot = "ERROR"
	V0041OpenapiNodesRespNodesNextStateAfterRebootFAIL            V0041OpenapiNodesRespNodesNextStateAfterReboot = "FAIL"
	V0041OpenapiNodesRespNodesNextStateAfterRebootFUTURE          V0041OpenapiNodesRespNodesNextStateAfterReboot = "FUTURE"
	V0041OpenapiNodesRespNodesNextStateAfterRebootIDLE            V0041OpenapiNodesRespNodesNextStateAfterReboot = "IDLE"
	V0041OpenapiNodesRespNodesNextStateAfterRebootINVALID         V0041OpenapiNodesRespNodesNextStateAfterReboot = "INVALID"
	V0041OpenapiNodesRespNodesNextStateAfterRebootINVALIDREG      V0041OpenapiNodesRespNodesNextStateAfterReboot = "INVALID_REG"
	V0041OpenapiNodesRespNodesNextStateAfterRebootMAINTENANCE     V0041OpenapiNodesRespNodesNextStateAfterReboot = "MAINTENANCE"
	V0041OpenapiNodesRespNodesNextStateAfterRebootMIXED           V0041OpenapiNodesRespNodesNextStateAfterReboot = "MIXED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootNOTRESPONDING   V0041OpenapiNodesRespNodesNextStateAfterReboot = "NOT_RESPONDING"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPLANNED         V0041OpenapiNodesRespNodesNextStateAfterReboot = "PLANNED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERDOWN       V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWER_DOWN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERDRAIN      V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWER_DRAIN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWEREDDOWN     V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWERED_DOWN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERINGDOWN    V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWERING_DOWN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERINGUP      V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWERING_UP"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERUP         V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWER_UP"
	V0041OpenapiNodesRespNodesNextStateAfterRebootREBOOTCANCELED  V0041OpenapiNodesRespNodesNextStateAfterReboot = "REBOOT_CANCELED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootREBOOTISSUED    V0041OpenapiNodesRespNodesNextStateAfterReboot = "REBOOT_ISSUED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootREBOOTREQUESTED V0041OpenapiNodesRespNodesNextStateAfterReboot = "REBOOT_REQUESTED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootRESERVED        V0041OpenapiNodesRespNodesNextStateAfterReboot = "RESERVED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootRESUME          V0041OpenapiNodesRespNodesNextStateAfterReboot = "RESUME"
	V0041OpenapiNodesRespNodesNextStateAfterRebootUNDRAIN         V0041OpenapiNodesRespNodesNextStateAfterReboot = "UNDRAIN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootUNKNOWN         V0041OpenapiNodesRespNodesNextStateAfterReboot = "UNKNOWN"
)

// Defines values for V0041OpenapiNodesRespNodesState.
const (
	V0041OpenapiNodesRespNodesStateALLOCATED       V0041OpenapiNodesRespNodesState = "ALLOCATED"
	V0041OpenapiNodesRespNodesStateCLOUD           V0041OpenapiNodesRespNodesState = "CLOUD"
	V0041OpenapiNodesRespNodesStateCOMPLETING      V0041OpenapiNodesRespNodesState = "COMPLETING"
	V0041OpenapiNodesRespNodesStateDOWN            V0041OpenapiNodesRespNodesState = "DOWN"
	V0041OpenapiNodesRespNodesStateDRAIN           V0041OpenapiNodesRespNodesState = "DRAIN"
	V0041OpenapiNodesRespNodesStateDYNAMICFUTURE   V0041OpenapiNodesRespNodesState = "DYNAMIC_FUTURE"
	V0041OpenapiNodesRespNodesStateDYNAMICNORM     V0041OpenapiNodesRespNodesState = "DYNAMIC_NORM"
	V0041OpenapiNodesRespNodesStateERROR           V0041OpenapiNodesRespNodesState = "ERROR"
	V0041OpenapiNodesRespNodesStateFAIL            V0041OpenapiNodesRespNodesState = "FAIL"
	V0041OpenapiNodesRespNodesStateFUTURE          V0041OpenapiNodesRespNodesState = "FUTURE"
	V0041OpenapiNodesRespNodesStateIDLE            V0041OpenapiNodesRespNodesState = "IDLE"
	V0041OpenapiNodesRespNodesStateINVALID         V0041OpenapiNodesRespNodesState = "INVALID"
	V0041OpenapiNodesRespNodesStateINVALIDREG      V0041OpenapiNodesRespNodesState = "INVALID_REG"
	V0041OpenapiNodesRespNodesStateMAINTENANCE     V0041OpenapiNodesRespNodesState = "MAINTENANCE"
	V0041OpenapiNodesRespNodesStateMIXED           V0041OpenapiNodesRespNodesState = "MIXED"
	V0041OpenapiNodesRespNodesStateNOTRESPONDING   V0041OpenapiNodesRespNodesState = "NOT_RESPONDING"
	V0041OpenapiNodesRespNodesStatePLANNED         V0041OpenapiNodesRespNodesState = "PLANNED"
	V0041OpenapiNodesRespNodesStatePOWERDOWN       V0041OpenapiNodesRespNodesState = "POWER_DOWN"
	V0041OpenapiNodesRespNodesStatePOWERDRAIN      V0041OpenapiNodesRespNodesState = "POWER_DRAIN"
	V0041OpenapiNodesRespNodesStatePOWEREDDOWN     V0041OpenapiNodesRespNodesState = "POWERED_DOWN"
	V0041OpenapiNodesRespNodesStatePOWERINGDOWN    V0041OpenapiNodesRespNodesState = "POWERING_DOWN"
	V0041OpenapiNodesRespNodesStatePOWERINGUP      V0041OpenapiNodesRespNodesState = "POWERING_UP"
	V0041OpenapiNodesRespNodesStatePOWERUP         V0041OpenapiNodesRespNodesState = "POWER_UP"
	V0041OpenapiNodesRespNodesStateREBOOTCANCELED  V0041OpenapiNodesRespNodesState = "REBOOT_CANCELED"
	V0041OpenapiNodesRespNodesStateREBOOTISSUED    V0041OpenapiNodesRespNodesState = "REBOOT_ISSUED"
	V0041OpenapiNodesRespNodesStateREBOOTREQUESTED V0041OpenapiNodesRespNodesState = "REBOOT_REQUESTED"
	V0041OpenapiNodesRespNodesStateRESERVED        V0041OpenapiNodesRespNodesState = "RESERVED"
	V0041OpenapiNodesRespNodesStateRESUME          V0041OpenapiNodesRespNodesState = "RESUME"
	V0041OpenapiNodesRespNodesStateUNDRAIN         V0041OpenapiNodesRespNodesState = "UNDRAIN"
	V0041OpenapiNodesRespNodesStateUNKNOWN         V0041OpenapiNodesRespNodesState = "UNKNOWN"
)

// Defines values for V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags.
const (
	Force V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags = "force"
)

// Defines values for V0041OpenapiPartitionRespPartitionsPartitionState.
const (
	V0041OpenapiPartitionRespPartitionsPartitionStateDOWN     V0041OpenapiPartitionRespPartitionsPartitionState = "DOWN"
	V0041OpenapiPartitionRespPartitionsPartitionStateDRAIN    V0041OpenapiPartitionRespPartitionsPartitionState = "DRAIN"
	V0041OpenapiPartitionRespPartitionsPartitionStateINACTIVE V0041OpenapiPartitionRespPartitionsPartitionState = "INACTIVE"
	V0041OpenapiPartitionRespPartitionsPartitionStateUNKNOWN  V0041OpenapiPartitionRespPartitionsPartitionState = "UNKNOWN"
	V0041OpenapiPartitionRespPartitionsPartitionStateUP       V0041OpenapiPartitionRespPartitionsPartitionState = "UP"
)

// Defines values for V0041OpenapiPartitionRespPartitionsSelectType.
const (
	V0041OpenapiPartitionRespPartitionsSelectTypeBOARD                V0041OpenapiPartitionRespPartitionsSelectType = "BOARD"
	V0041OpenapiPartitionRespPartitionsSelectTypeCORE                 V0041OpenapiPartitionRespPartitionsSelectType = "CORE"
	V0041OpenapiPartitionRespPartitionsSelectTypeCOREDEFAULTDISTBLOCK V0041OpenapiPartitionRespPartitionsSelectType = "CORE_DEFAULT_DIST_BLOCK"
	V0041OpenapiPartitionRespPartitionsSelectTypeCPU                  V0041OpenapiPartitionRespPartitionsSelectType = "CPU"
	V0041OpenapiPartitionRespPartitionsSelectTypeLINEAR               V0041OpenapiPartitionRespPartitionsSelectType = "LINEAR"
	V0041OpenapiPartitionRespPartitionsSelectTypeLLN                  V0041OpenapiPartitionRespPartitionsSelectType = "LLN"
	V0041OpenapiPartitionRespPartitionsSelectTypeMEMORY               V0041OpenapiPartitionRespPartitionsSelectType = "MEMORY"
	V0041OpenapiPartitionRespPartitionsSelectTypeONETASKPERCORE       V0041OpenapiPartitionRespPartitionsSelectType = "ONE_TASK_PER_CORE"
	V0041OpenapiPartitionRespPartitionsSelectTypePACKNODES            V0041OpenapiPartitionRespPartitionsSelectType = "PACK_NODES"
	V0041OpenapiPartitionRespPartitionsSelectTypeSOCKET               V0041OpenapiPartitionRespPartitionsSelectType = "SOCKET"
)

// Defines values for V0041OpenapiReservationRespReservationsFlags.
const (
	V0041OpenapiReservationRespReservationsFlagsALLNODES           V0041OpenapiReservationRespReservationsFlags = "ALL_NODES"
	V0041OpenapiReservationRespReservationsFlagsANYNODES           V0041OpenapiReservationRespReservationsFlags = "ANY_NODES"
	V0041OpenapiReservationRespReservationsFlagsDAILY              V0041OpenapiReservationRespReservationsFlags = "DAILY"
	V0041OpenapiReservationRespReservationsFlagsDURATIONMINUS      V0041OpenapiReservationRespReservationsFlags = "DURATION_MINUS"
	V0041OpenapiReservationRespReservationsFlagsDURATIONPLUS       V0041OpenapiReservationRespReservationsFlags = "DURATION_PLUS"
	V0041OpenapiReservationRespReservationsFlagsFLEX               V0041OpenapiReservationRespReservationsFlags = "FLEX"
	V0041OpenapiReservationRespReservationsFlagsHOURLY             V0041OpenapiReservationRespReservationsFlags = "HOURLY"
	V0041OpenapiReservationRespReservationsFlagsIGNOREJOBS         V0041OpenapiReservationRespReservationsFlags = "IGNORE_JOBS"
	V0041OpenapiReservationRespReservationsFlagsMAGNETIC           V0041OpenapiReservationRespReservationsFlags = "MAGNETIC"
	V0041OpenapiReservationRespReservationsFlagsMAINT              V0041OpenapiReservationRespReservationsFlags = "MAINT"
	V0041OpenapiReservationRespReservationsFlagsNODAILY            V0041OpenapiReservationRespReservationsFlags = "NO_DAILY"
	V0041OpenapiReservationRespReservationsFlagsNOFLEX             V0041OpenapiReservationRespReservationsFlags = "NO_FLEX"
	V0041OpenapiReservationRespReservationsFlagsNOHOLDJOBSAFTEREND V0041OpenapiReservationRespReservationsFlags = "NO_HOLD_JOBS_AFTER_END"
	V0041OpenapiReservationRespReservationsFlagsNOHOURLY           V0041OpenapiReservationRespReservationsFlags = "NO_HOURLY"
	V0041OpenapiReservationRespReservationsFlagsNOIGNOREJOBS       V0041OpenapiReservationRespReservationsFlags = "NO_IGNORE_JOBS"
	V0041OpenapiReservationRespReservationsFlagsNOMAINT            V0041OpenapiReservationRespReservationsFlags = "NO_MAINT"
	V0041OpenapiReservationRespReservationsFlagsNOPARTNODES        V0041OpenapiReservationRespReservationsFlags = "NO_PART_NODES"
	V0041OpenapiReservationRespReservationsFlagsNOPURGECOMP        V0041OpenapiReservationRespReservationsFlags = "NO_PURGE_COMP"
	V0041OpenapiReservationRespReservationsFlagsNOSTATIC           V0041OpenapiReservationRespReservationsFlags = "NO_STATIC"
	V0041OpenapiReservationRespReservationsFlagsNOUSERDELETE       V0041OpenapiReservationRespReservationsFlags = "NO_USER_DELETE"
	V0041OpenapiReservationRespReservationsFlagsNOWEEKDAY          V0041OpenapiReservationRespReservationsFlags = "NO_WEEKDAY"
	V0041OpenapiReservationRespReservationsFlagsNOWEEKEND          V0041OpenapiReservationRespReservationsFlags = "NO_WEEKEND"
	V0041OpenapiReservationRespReservationsFlagsNOWEEKLY           V0041OpenapiReservationRespReservationsFlags = "NO_WEEKLY"
	V0041OpenapiReservationRespReservationsFlagsOVERLAP            V0041OpenapiReservationRespReservationsFlags = "OVERLAP"
	V0041OpenapiReservationRespReservationsFlagsPARTNODES          V0041OpenapiReservationRespReservationsFlags = "PART_NODES"
	V0041OpenapiReservationRespReservationsFlagsPURGECOMP          V0041OpenapiReservationRespReservationsFlags = "PURGE_COMP"
	V0041OpenapiReservationRespReservationsFlagsREOCCURRING        V0041OpenapiReservationRespReservationsFlags = "REOCCURRING"
	V0041OpenapiReservationRespReservationsFlagsREPLACE            V0041OpenapiReservationRespReservationsFlags = "REPLACE"
	V0041OpenapiReservationRespReservationsFlagsSKIP               V0041OpenapiReservationRespReservationsFlags = "SKIP"
	V0041OpenapiReservationRespReservationsFlagsSPECNODES          V0041OpenapiReservationRespReservationsFlags = "SPEC_NODES"
	V0041OpenapiReservationRespReservationsFlagsSTATIC             V0041OpenapiReservationRespReservationsFlags = "STATIC"
	V0041OpenapiReservationRespReservationsFlagsTIMEFLOAT          V0041OpenapiReservationRespReservationsFlags = "TIME_FLOAT"
	V0041OpenapiReservationRespReservationsFlagsUSERDELETE         V0041OpenapiReservationRespReservationsFlags = "USER_DELETE"
	V0041OpenapiReservationRespReservationsFlagsWEEKDAY            V0041OpenapiReservationRespReservationsFlags = "WEEKDAY"
	V0041OpenapiReservationRespReservationsFlagsWEEKEND            V0041OpenapiReservationRespReservationsFlags = "WEEKEND"
	V0041OpenapiReservationRespReservationsFlagsWEEKLY             V0041OpenapiReservationRespReservationsFlags = "WEEKLY"
)

// Defines values for V0041OpenapiSharesRespSharesSharesType.
const (
	ASSOCIATION V0041OpenapiSharesRespSharesSharesType = "ASSOCIATION"
	USER        V0041OpenapiSharesRespSharesSharesType = "USER"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespAccountsFlags.
const (
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsDELETED          V0041OpenapiSlurmdbdConfigRespAccountsFlags = "DELETED"
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsNoUsersAreCoords V0041OpenapiSlurmdbdConfigRespAccountsFlags = "NoUsersAreCoords"
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsUsersAreCoords   V0041OpenapiSlurmdbdConfigRespAccountsFlags = "UsersAreCoords"
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsWithAssociations V0041OpenapiSlurmdbdConfigRespAccountsFlags = "WithAssociations"
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsWithCoordinators V0041OpenapiSlurmdbdConfigRespAccountsFlags = "WithCoordinators"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespAssociationsFlags.
const (
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsDELETED          V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "DELETED"
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsExact            V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "Exact"
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsNoUpdate         V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "NoUpdate"
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsNoUsersAreCoords V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "NoUsersAreCoords"
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsUsersAreCoords   V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "UsersAreCoords"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespClustersFlags.
const (
	V0041OpenapiSlurmdbdConfigRespClustersFlagsEXTERNAL       V0041OpenapiSlurmdbdConfigRespClustersFlags = "EXTERNAL"
	V0041OpenapiSlurmdbdConfigRespClustersFlagsFEDERATION     V0041OpenapiSlurmdbdConfigRespClustersFlags = "FEDERATION"
	V0041OpenapiSlurmdbdConfigRespClustersFlagsMULTIPLESLURMD V0041OpenapiSlurmdbdConfigRespClustersFlags = "MULTIPLE_SLURMD"
	V0041OpenapiSlurmdbdConfigRespClustersFlagsREGISTERING    V0041OpenapiSlurmdbdConfigRespClustersFlags = "REGISTERING"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespQosFlags.
const (
	V0041OpenapiSlurmdbdConfigRespQosFlagsADD                   V0041OpenapiSlurmdbdConfigRespQosFlags = "ADD"
	V0041OpenapiSlurmdbdConfigRespQosFlagsDENYLIMIT             V0041OpenapiSlurmdbdConfigRespQosFlags = "DENY_LIMIT"
	V0041OpenapiSlurmdbdConfigRespQosFlagsENFORCEUSAGETHRESHOLD V0041OpenapiSlurmdbdConfigRespQosFlags = "ENFORCE_USAGE_THRESHOLD"
	V0041OpenapiSlurmdbdConfigRespQosFlagsNODECAY               V0041OpenapiSlurmdbdConfigRespQosFlags = "NO_DECAY"
	V0041OpenapiSlurmdbdConfigRespQosFlagsNORESERVE             V0041OpenapiSlurmdbdConfigRespQosFlags = "NO_RESERVE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsNOTSET                V0041OpenapiSlurmdbdConfigRespQosFlags = "NOT_SET"
	V0041OpenapiSlurmdbdConfigRespQosFlagsOVERRIDEPARTITIONQOS  V0041OpenapiSlurmdbdConfigRespQosFlags = "OVERRIDE_PARTITION_QOS"
	V0041OpenapiSlurmdbdConfigRespQosFlagsPARTITIONMAXIMUMNODE  V0041OpenapiSlurmdbdConfigRespQosFlags = "PARTITION_MAXIMUM_NODE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsPARTITIONMINIMUMNODE  V0041OpenapiSlurmdbdConfigRespQosFlags = "PARTITION_MINIMUM_NODE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsPARTITIONTIMELIMIT    V0041OpenapiSlurmdbdConfigRespQosFlags = "PARTITION_TIME_LIMIT"
	V0041OpenapiSlurmdbdConfigRespQosFlagsRELATIVE              V0041OpenapiSlurmdbdConfigRespQosFlags = "RELATIVE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsREMOVE                V0041OpenapiSlurmdbdConfigRespQosFlags = "REMOVE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsREQUIREDRESERVATION   V0041OpenapiSlurmdbdConfigRespQosFlags = "REQUIRED_RESERVATION"
	V0041OpenapiSlurmdbdConfigRespQosFlagsUSAGEFACTORSAFE       V0041OpenapiSlurmdbdConfigRespQosFlags = "USAGE_FACTOR_SAFE"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespQosPreemptMode.
const (
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeCANCEL   V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "CANCEL"
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeDISABLED V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "DISABLED"
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeGANG     V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "GANG"
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeREQUEUE  V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "REQUEUE"
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeSUSPEND  V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "SUSPEND"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel.
const (
	V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevelAdministrator V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel = "Administrator"
	V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevelNone          V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel = "None"
	V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevelNotSet        V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel = "Not Set"
	V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevelOperator      V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel = "Operator"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespUsersFlags.
const (
	V0041OpenapiSlurmdbdConfigRespUsersFlagsDELETED V0041OpenapiSlurmdbdConfigRespUsersFlags = "DELETED"
	V0041OpenapiSlurmdbdConfigRespUsersFlagsNONE    V0041OpenapiSlurmdbdConfigRespUsersFlags = "NONE"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags.
const (
	V0041OpenapiSlurmdbdConfigRespUsersWckeysFlagsDELETED V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags = "DELETED"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespWckeysFlags.
const (
	V0041OpenapiSlurmdbdConfigRespWckeysFlagsDELETED V0041OpenapiSlurmdbdConfigRespWckeysFlags = "DELETED"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus.
const (
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusCOREDUMPED V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusERROR      V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "ERROR"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusINVALID    V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "INVALID"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusPENDING    V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusSIGNALED   V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "SIGNALED"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusSUCCESS    V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus.
const (
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusCOREDUMPED V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusERROR      V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "ERROR"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusINVALID    V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "INVALID"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusPENDING    V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusSIGNALED   V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "SIGNALED"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusSUCCESS    V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsFlags.
const (
	V0041OpenapiSlurmdbdJobsRespJobsFlagsCLEARSCHEDULING   V0041OpenapiSlurmdbdJobsRespJobsFlags = "CLEAR_SCHEDULING"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsNONE              V0041OpenapiSlurmdbdJobsRespJobsFlags = "NONE"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsNOTSET            V0041OpenapiSlurmdbdJobsRespJobsFlags = "NOT_SET"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsSTARTEDONBACKFILL V0041OpenapiSlurmdbdJobsRespJobsFlags = "STARTED_ON_BACKFILL"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsSTARTEDONSCHEDULE V0041OpenapiSlurmdbdJobsRespJobsFlags = "STARTED_ON_SCHEDULE"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsSTARTEDONSUBMIT   V0041OpenapiSlurmdbdJobsRespJobsFlags = "STARTED_ON_SUBMIT"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsSTARTRECEIVED     V0041OpenapiSlurmdbdJobsRespJobsFlags = "START_RECEIVED"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsStateCurrent.
const (
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentBOOTFAIL     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "BOOT_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentCANCELLED    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "CANCELLED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentCOMPLETED    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "COMPLETED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentCOMPLETING   V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "COMPLETING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentCONFIGURING  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "CONFIGURING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentDEADLINE     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "DEADLINE"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentFAILED       V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "FAILED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentLAUNCHFAILED V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "LAUNCH_FAILED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentNODEFAIL     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "NODE_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentOUTOFMEMORY  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "OUT_OF_MEMORY"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentPENDING      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentPOWERUPNODE  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "POWER_UP_NODE"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentPREEMPTED    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "PREEMPTED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentRECONFIGFAIL V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "RECONFIG_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentREQUEUED     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "REQUEUED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentREQUEUEFED   V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "REQUEUE_FED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentREQUEUEHOLD  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "REQUEUE_HOLD"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentRESIZING     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "RESIZING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentRESVDELHOLD  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "RESV_DEL_HOLD"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentREVOKED      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "REVOKED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentRUNNING      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "RUNNING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSIGNALING    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "SIGNALING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSPECIALEXIT  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "SPECIAL_EXIT"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSTAGEOUT     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "STAGE_OUT"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSTOPPED      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "STOPPED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSUSPENDED    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "SUSPENDED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentTIMEOUT      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "TIMEOUT"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus.
const (
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusCOREDUMPED V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusERROR      V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "ERROR"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusINVALID    V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "INVALID"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusPENDING    V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusSIGNALED   V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "SIGNALED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusSUCCESS    V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsStepsState.
const (
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateBOOTFAIL     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "BOOT_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateCANCELLED    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "CANCELLED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateCOMPLETED    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "COMPLETED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateCOMPLETING   V0041OpenapiSlurmdbdJobsRespJobsStepsState = "COMPLETING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateCONFIGURING  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "CONFIGURING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateDEADLINE     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "DEADLINE"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateFAILED       V0041OpenapiSlurmdbdJobsRespJobsStepsState = "FAILED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateLAUNCHFAILED V0041OpenapiSlurmdbdJobsRespJobsStepsState = "LAUNCH_FAILED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateNODEFAIL     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "NODE_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateOUTOFMEMORY  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "OUT_OF_MEMORY"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStatePENDING      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStatePOWERUPNODE  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "POWER_UP_NODE"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStatePREEMPTED    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "PREEMPTED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateRECONFIGFAIL V0041OpenapiSlurmdbdJobsRespJobsStepsState = "RECONFIG_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateREQUEUED     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "REQUEUED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateREQUEUEFED   V0041OpenapiSlurmdbdJobsRespJobsStepsState = "REQUEUE_FED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateREQUEUEHOLD  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "REQUEUE_HOLD"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateRESIZING     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "RESIZING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateRESVDELHOLD  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "RESV_DEL_HOLD"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateREVOKED      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "REVOKED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateRUNNING      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "RUNNING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSIGNALING    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "SIGNALING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSPECIALEXIT  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "SPECIAL_EXIT"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSTAGEOUT     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "STAGE_OUT"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSTOPPED      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "STOPPED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSUSPENDED    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "SUSPENDED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateTIMEOUT      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "TIMEOUT"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags.
const (
	ASSIGNEDDEFAULT V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags = "ASSIGNED_DEFAULT"
)

// Defines values for V0041OpenapiSlurmdbdQosRespQosFlags.
const (
	V0041OpenapiSlurmdbdQosRespQosFlagsADD                   V0041OpenapiSlurmdbdQosRespQosFlags = "ADD"
	V0041OpenapiSlurmdbdQosRespQosFlagsDENYLIMIT             V0041OpenapiSlurmdbdQosRespQosFlags = "DENY_LIMIT"
	V0041OpenapiSlurmdbdQosRespQosFlagsENFORCEUSAGETHRESHOLD V0041OpenapiSlurmdbdQosRespQosFlags = "ENFORCE_USAGE_THRESHOLD"
	V0041OpenapiSlurmdbdQosRespQosFlagsNODECAY               V0041OpenapiSlurmdbdQosRespQosFlags = "NO_DECAY"
	V0041OpenapiSlurmdbdQosRespQosFlagsNORESERVE             V0041OpenapiSlurmdbdQosRespQosFlags = "NO_RESERVE"
	V0041OpenapiSlurmdbdQosRespQosFlagsNOTSET                V0041OpenapiSlurmdbdQosRespQosFlags = "NOT_SET"
	V0041OpenapiSlurmdbdQosRespQosFlagsOVERRIDEPARTITIONQOS  V0041OpenapiSlurmdbdQosRespQosFlags = "OVERRIDE_PARTITION_QOS"
	V0041OpenapiSlurmdbdQosRespQosFlagsPARTITIONMAXIMUMNODE  V0041OpenapiSlurmdbdQosRespQosFlags = "PARTITION_MAXIMUM_NODE"
	V0041OpenapiSlurmdbdQosRespQosFlagsPARTITIONMINIMUMNODE  V0041OpenapiSlurmdbdQosRespQosFlags = "PARTITION_MINIMUM_NODE"
	V0041OpenapiSlurmdbdQosRespQosFlagsPARTITIONTIMELIMIT    V0041OpenapiSlurmdbdQosRespQosFlags = "PARTITION_TIME_LIMIT"
	V0041OpenapiSlurmdbdQosRespQosFlagsRELATIVE              V0041OpenapiSlurmdbdQosRespQosFlags = "RELATIVE"
	V0041OpenapiSlurmdbdQosRespQosFlagsREMOVE                V0041OpenapiSlurmdbdQosRespQosFlags = "REMOVE"
	V0041OpenapiSlurmdbdQosRespQosFlagsREQUIREDRESERVATION   V0041OpenapiSlurmdbdQosRespQosFlags = "REQUIRED_RESERVATION"
	V0041OpenapiSlurmdbdQosRespQosFlagsUSAGEFACTORSAFE       V0041OpenapiSlurmdbdQosRespQosFlags = "USAGE_FACTOR_SAFE"
)

// Defines values for V0041OpenapiSlurmdbdQosRespQosPreemptMode.
const (
	V0041OpenapiSlurmdbdQosRespQosPreemptModeCANCEL   V0041OpenapiSlurmdbdQosRespQosPreemptMode = "CANCEL"
	V0041OpenapiSlurmdbdQosRespQosPreemptModeDISABLED V0041OpenapiSlurmdbdQosRespQosPreemptMode = "DISABLED"
	V0041OpenapiSlurmdbdQosRespQosPreemptModeGANG     V0041OpenapiSlurmdbdQosRespQosPreemptMode = "GANG"
	V0041OpenapiSlurmdbdQosRespQosPreemptModeREQUEUE  V0041OpenapiSlurmdbdQosRespQosPreemptMode = "REQUEUE"
	V0041OpenapiSlurmdbdQosRespQosPreemptModeSUSPEND  V0041OpenapiSlurmdbdQosRespQosPreemptMode = "SUSPEND"
)

// Defines values for V0041OpenapiUsersRespUsersAdministratorLevel.
const (
	V0041OpenapiUsersRespUsersAdministratorLevelAdministrator V0041OpenapiUsersRespUsersAdministratorLevel = "Administrator"
	V0041OpenapiUsersRespUsersAdministratorLevelNone          V0041OpenapiUsersRespUsersAdministratorLevel = "None"
	V0041OpenapiUsersRespUsersAdministratorLevelNotSet        V0041OpenapiUsersRespUsersAdministratorLevel = "Not Set"
	V0041OpenapiUsersRespUsersAdministratorLevelOperator      V0041OpenapiUsersRespUsersAdministratorLevel = "Operator"
)

// Defines values for V0041OpenapiUsersRespUsersFlags.
const (
	V0041OpenapiUsersRespUsersFlagsDELETED V0041OpenapiUsersRespUsersFlags = "DELETED"
	V0041OpenapiUsersRespUsersFlagsNONE    V0041OpenapiUsersRespUsersFlags = "NONE"
)

// Defines values for V0041OpenapiUsersRespUsersWckeysFlags.
const (
	V0041OpenapiUsersRespUsersWckeysFlagsDELETED V0041OpenapiUsersRespUsersWckeysFlags = "DELETED"
)

// Defines values for V0041OpenapiWckeyRespWckeysFlags.
const (
	V0041OpenapiWckeyRespWckeysFlagsDELETED V0041OpenapiWckeyRespWckeysFlags = "DELETED"
)

// Defines values for V0041UpdateNodeMsgState.
const (
	V0041UpdateNodeMsgStateALLOCATED       V0041UpdateNodeMsgState = "ALLOCATED"
	V0041UpdateNodeMsgStateCLOUD           V0041UpdateNodeMsgState = "CLOUD"
	V0041UpdateNodeMsgStateCOMPLETING      V0041UpdateNodeMsgState = "COMPLETING"
	V0041UpdateNodeMsgStateDOWN            V0041UpdateNodeMsgState = "DOWN"
	V0041UpdateNodeMsgStateDRAIN           V0041UpdateNodeMsgState = "DRAIN"
	V0041UpdateNodeMsgStateDYNAMICFUTURE   V0041UpdateNodeMsgState = "DYNAMIC_FUTURE"
	V0041UpdateNodeMsgStateDYNAMICNORM     V0041UpdateNodeMsgState = "DYNAMIC_NORM"
	V0041UpdateNodeMsgStateERROR           V0041UpdateNodeMsgState = "ERROR"
	V0041UpdateNodeMsgStateFAIL            V0041UpdateNodeMsgState = "FAIL"
	V0041UpdateNodeMsgStateFUTURE          V0041UpdateNodeMsgState = "FUTURE"
	V0041UpdateNodeMsgStateIDLE            V0041UpdateNodeMsgState = "IDLE"
	V0041UpdateNodeMsgStateINVALID         V0041UpdateNodeMsgState = "INVALID"
	V0041UpdateNodeMsgStateINVALIDREG      V0041UpdateNodeMsgState = "INVALID_REG"
	V0041UpdateNodeMsgStateMAINTENANCE     V0041UpdateNodeMsgState = "MAINTENANCE"
	V0041UpdateNodeMsgStateMIXED           V0041UpdateNodeMsgState = "MIXED"
	V0041UpdateNodeMsgStateNOTRESPONDING   V0041UpdateNodeMsgState = "NOT_RESPONDING"
	V0041UpdateNodeMsgStatePLANNED         V0041UpdateNodeMsgState = "PLANNED"
	V0041UpdateNodeMsgStatePOWERDOWN       V0041UpdateNodeMsgState = "POWER_DOWN"
	V0041UpdateNodeMsgStatePOWERDRAIN      V0041UpdateNodeMsgState = "POWER_DRAIN"
	V0041UpdateNodeMsgStatePOWEREDDOWN     V0041UpdateNodeMsgState = "POWERED_DOWN"
	V0041UpdateNodeMsgStatePOWERINGDOWN    V0041UpdateNodeMsgState = "POWERING_DOWN"
	V0041UpdateNodeMsgStatePOWERINGUP      V0041UpdateNodeMsgState = "POWERING_UP"
	V0041UpdateNodeMsgStatePOWERUP         V0041UpdateNodeMsgState = "POWER_UP"
	V0041UpdateNodeMsgStateREBOOTCANCELED  V0041UpdateNodeMsgState = "REBOOT_CANCELED"
	V0041UpdateNodeMsgStateREBOOTISSUED    V0041UpdateNodeMsgState = "REBOOT_ISSUED"
	V0041UpdateNodeMsgStateREBOOTREQUESTED V0041UpdateNodeMsgState = "REBOOT_REQUESTED"
	V0041UpdateNodeMsgStateRESERVED        V0041UpdateNodeMsgState = "RESERVED"
	V0041UpdateNodeMsgStateRESUME          V0041UpdateNodeMsgState = "RESUME"
	V0041UpdateNodeMsgStateUNDRAIN         V0041UpdateNodeMsgState = "UNDRAIN"
	V0041UpdateNodeMsgStateUNKNOWN         V0041UpdateNodeMsgState = "UNKNOWN"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDLDMAP            SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDLDMASK           SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDLDRANK           SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDMAP              SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDMASK             SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDNONE             SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDRANK             SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDTOCORES          SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsVERBOSE                 SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlagsWILDDAYOFMONTH SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags = "WILD_DAY_OF_MONTH"
	SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlagsWILDDAYOFWEEK  SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags = "WILD_DAY_OF_WEEK"
	SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlagsWILDHOUR       SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags = "WILD_HOUR"
	SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlagsWILDMINUTE     SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags = "WILD_MINUTE"
	SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlagsWILDMONTH      SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobExclusive.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobExclusiveFalse SlurmV0041PostJobAllocateJSONBodyHetjobExclusive = "false"
	SlurmV0041PostJobAllocateJSONBodyHetjobExclusiveMcs   SlurmV0041PostJobAllocateJSONBodyHetjobExclusive = "mcs"
	SlurmV0041PostJobAllocateJSONBodyHetjobExclusiveTopo  SlurmV0041PostJobAllocateJSONBodyHetjobExclusive = "topo"
	SlurmV0041PostJobAllocateJSONBodyHetjobExclusiveTrue  SlurmV0041PostJobAllocateJSONBodyHetjobExclusive = "true"
	SlurmV0041PostJobAllocateJSONBodyHetjobExclusiveUser  SlurmV0041PostJobAllocateJSONBodyHetjobExclusive = "user"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsACCRUECOUNTCLEARED       SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "ACCRUE_COUNT_CLEARED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsBACKFILLATTEMPTED        SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "BACKFILL_ATTEMPTED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsCRONJOB                  SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "CRON_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsDEPENDENT                SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "DEPENDENT"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsEXACTCPUCOUNTREQUESTED   SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "EXACT_CPU_COUNT_REQUESTED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsEXACTMEMORYREQUESTED     SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "EXACT_MEMORY_REQUESTED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsEXACTTASKCOUNTREQUESTED  SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "EXACT_TASK_COUNT_REQUESTED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsGRESBINDINGDISABLED      SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "GRES_BINDING_DISABLED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsGRESBINDINGENFORCED      SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "GRES_BINDING_ENFORCED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsHASSTATEDIRECTORY        SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "HAS_STATE_DIRECTORY"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsHETEROGENEOUSJOB         SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "HETEROGENEOUS_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsJOBACCRUETIMERESET       SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "JOB_ACCRUE_TIME_RESET"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsJOBKILLHURRY             SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "JOB_KILL_HURRY"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsJOBWASRUNNING            SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "JOB_WAS_RUNNING"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsKILLINVALIDDEPENDENCY    SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsMAGNETIC                 SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "MAGNETIC"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsNOKILLINVALIDDEPENDENCY  SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "NO_KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsPARTITIONASSIGNED        SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "PARTITION_ASSIGNED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsPREFERMINIMUMNODECOUNT   SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "PREFER_MINIMUM_NODE_COUNT"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsSCHEDULINGATTEMPTED      SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "SCHEDULING_ATTEMPTED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsSENDJOBENVIRONMENT       SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "SEND_JOB_ENVIRONMENT"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsSIBLINGCLUSTERUPDATEONLY SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsSKIPTRESSTRINGACCOUNTING SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsSPREADJOB                SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "SPREAD_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsSTEPMGRENABLED           SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "STEPMGR_ENABLED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsTESTINGBACKFILL          SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "TESTING_BACKFILL"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsTESTINGWHOLENODEBACKFILL SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "TESTING_WHOLE_NODE_BACKFILL"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsTESTNOWONLY              SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "TEST_NOW_ONLY"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsTOPPRIORITYJOB           SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "TOP_PRIORITY_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsUSINGDEFAULTACCOUNT      SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "USING_DEFAULT_ACCOUNT"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsUSINGDEFAULTPARTITION    SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "USING_DEFAULT_PARTITION"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsUSINGDEFAULTQOS          SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "USING_DEFAULT_QOS"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsUSINGDEFAULTWCKEY        SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsARRAYTASK         SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "ARRAY_TASK"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsBATCHJOB          SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "BATCH_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsCRONJOBS          SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "CRON_JOBS"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsFEDERATIONREQUEUE SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsFULLJOB           SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "FULL_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsFULLSTEPSONLY     SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsHURRY             SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "HURRY"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsNOSIBLINGJOBS     SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsOUTOFMEMORY       SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsRESERVATIONJOB    SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "RESERVATION_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsVERBOSE           SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "VERBOSE"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsWARNINGSENT       SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobMailType.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeARRAYTASKS        SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "ARRAY_TASKS"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeBEGIN             SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "BEGIN"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeEND               SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "END"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeFAIL              SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "FAIL"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeINVALIDDEPENDENCY SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "INVALID_DEPENDENCY"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeREQUEUE           SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "REQUEUE"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeSTAGEOUT          SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "STAGE_OUT"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeTIME100           SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "TIME=100%"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeTIME50            SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "TIME=50%"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeTIME80            SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "TIME=80%"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeTIME90            SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "TIME=90%"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeLOCAL   SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "LOCAL"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeMAP     SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "MAP"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeMASK    SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "MASK"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeNONE    SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "NONE"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypePREFER  SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "PREFER"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeRANK    SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "RANK"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeSORT    SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "SORT"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeVERBOSE SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobOpenMode.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobOpenModeAPPEND   SlurmV0041PostJobAllocateJSONBodyHetjobOpenMode = "APPEND"
	SlurmV0041PostJobAllocateJSONBodyHetjobOpenModeTRUNCATE SlurmV0041PostJobAllocateJSONBodyHetjobOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobProfile.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobProfileENERGY  SlurmV0041PostJobAllocateJSONBodyHetjobProfile = "ENERGY"
	SlurmV0041PostJobAllocateJSONBodyHetjobProfileLUSTRE  SlurmV0041PostJobAllocateJSONBodyHetjobProfile = "LUSTRE"
	SlurmV0041PostJobAllocateJSONBodyHetjobProfileNETWORK SlurmV0041PostJobAllocateJSONBodyHetjobProfile = "NETWORK"
	SlurmV0041PostJobAllocateJSONBodyHetjobProfileNONE    SlurmV0041PostJobAllocateJSONBodyHetjobProfile = "NONE"
	SlurmV0041PostJobAllocateJSONBodyHetjobProfileNOTSET  SlurmV0041PostJobAllocateJSONBodyHetjobProfile = "NOT_SET"
	SlurmV0041PostJobAllocateJSONBodyHetjobProfileTASK    SlurmV0041PostJobAllocateJSONBodyHetjobProfile = "TASK"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobShared.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobSharedMcs           SlurmV0041PostJobAllocateJSONBodyHetjobShared = "mcs"
	SlurmV0041PostJobAllocateJSONBodyHetjobSharedNone          SlurmV0041PostJobAllocateJSONBodyHetjobShared = "none"
	SlurmV0041PostJobAllocateJSONBodyHetjobSharedOversubscribe SlurmV0041PostJobAllocateJSONBodyHetjobShared = "oversubscribe"
	SlurmV0041PostJobAllocateJSONBodyHetjobSharedTopo          SlurmV0041PostJobAllocateJSONBodyHetjobShared = "topo"
	SlurmV0041PostJobAllocateJSONBodyHetjobSharedUser          SlurmV0041PostJobAllocateJSONBodyHetjobShared = "user"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobX11.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobX11BATCHNODE       SlurmV0041PostJobAllocateJSONBodyHetjobX11 = "BATCH_NODE"
	SlurmV0041PostJobAllocateJSONBodyHetjobX11FIRSTNODE       SlurmV0041PostJobAllocateJSONBodyHetjobX11 = "FIRST_NODE"
	SlurmV0041PostJobAllocateJSONBodyHetjobX11FORWARDALLNODES SlurmV0041PostJobAllocateJSONBodyHetjobX11 = "FORWARD_ALL_NODES"
	SlurmV0041PostJobAllocateJSONBodyHetjobX11LASTNODE        SlurmV0041PostJobAllocateJSONBodyHetjobX11 = "LAST_NODE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDLDMAP            SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDLDMASK           SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDLDRANK           SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDMAP              SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDMASK             SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDNONE             SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDRANK             SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDTOCORES          SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsVERBOSE                 SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyJobCrontabFlagsWILDDAYOFMONTH SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags = "WILD_DAY_OF_MONTH"
	SlurmV0041PostJobAllocateJSONBodyJobCrontabFlagsWILDDAYOFWEEK  SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags = "WILD_DAY_OF_WEEK"
	SlurmV0041PostJobAllocateJSONBodyJobCrontabFlagsWILDHOUR       SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags = "WILD_HOUR"
	SlurmV0041PostJobAllocateJSONBodyJobCrontabFlagsWILDMINUTE     SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags = "WILD_MINUTE"
	SlurmV0041PostJobAllocateJSONBodyJobCrontabFlagsWILDMONTH      SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobExclusive.
const (
	SlurmV0041PostJobAllocateJSONBodyJobExclusiveFalse SlurmV0041PostJobAllocateJSONBodyJobExclusive = "false"
	SlurmV0041PostJobAllocateJSONBodyJobExclusiveMcs   SlurmV0041PostJobAllocateJSONBodyJobExclusive = "mcs"
	SlurmV0041PostJobAllocateJSONBodyJobExclusiveTopo  SlurmV0041PostJobAllocateJSONBodyJobExclusive = "topo"
	SlurmV0041PostJobAllocateJSONBodyJobExclusiveTrue  SlurmV0041PostJobAllocateJSONBodyJobExclusive = "true"
	SlurmV0041PostJobAllocateJSONBodyJobExclusiveUser  SlurmV0041PostJobAllocateJSONBodyJobExclusive = "user"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyJobFlagsACCRUECOUNTCLEARED       SlurmV0041PostJobAllocateJSONBodyJobFlags = "ACCRUE_COUNT_CLEARED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsBACKFILLATTEMPTED        SlurmV0041PostJobAllocateJSONBodyJobFlags = "BACKFILL_ATTEMPTED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsCRONJOB                  SlurmV0041PostJobAllocateJSONBodyJobFlags = "CRON_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsDEPENDENT                SlurmV0041PostJobAllocateJSONBodyJobFlags = "DEPENDENT"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsEXACTCPUCOUNTREQUESTED   SlurmV0041PostJobAllocateJSONBodyJobFlags = "EXACT_CPU_COUNT_REQUESTED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsEXACTMEMORYREQUESTED     SlurmV0041PostJobAllocateJSONBodyJobFlags = "EXACT_MEMORY_REQUESTED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsEXACTTASKCOUNTREQUESTED  SlurmV0041PostJobAllocateJSONBodyJobFlags = "EXACT_TASK_COUNT_REQUESTED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsGRESBINDINGDISABLED      SlurmV0041PostJobAllocateJSONBodyJobFlags = "GRES_BINDING_DISABLED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsGRESBINDINGENFORCED      SlurmV0041PostJobAllocateJSONBodyJobFlags = "GRES_BINDING_ENFORCED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsHASSTATEDIRECTORY        SlurmV0041PostJobAllocateJSONBodyJobFlags = "HAS_STATE_DIRECTORY"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsHETEROGENEOUSJOB         SlurmV0041PostJobAllocateJSONBodyJobFlags = "HETEROGENEOUS_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsJOBACCRUETIMERESET       SlurmV0041PostJobAllocateJSONBodyJobFlags = "JOB_ACCRUE_TIME_RESET"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsJOBKILLHURRY             SlurmV0041PostJobAllocateJSONBodyJobFlags = "JOB_KILL_HURRY"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsJOBWASRUNNING            SlurmV0041PostJobAllocateJSONBodyJobFlags = "JOB_WAS_RUNNING"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsKILLINVALIDDEPENDENCY    SlurmV0041PostJobAllocateJSONBodyJobFlags = "KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsMAGNETIC                 SlurmV0041PostJobAllocateJSONBodyJobFlags = "MAGNETIC"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsNOKILLINVALIDDEPENDENCY  SlurmV0041PostJobAllocateJSONBodyJobFlags = "NO_KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsPARTITIONASSIGNED        SlurmV0041PostJobAllocateJSONBodyJobFlags = "PARTITION_ASSIGNED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsPREFERMINIMUMNODECOUNT   SlurmV0041PostJobAllocateJSONBodyJobFlags = "PREFER_MINIMUM_NODE_COUNT"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsSCHEDULINGATTEMPTED      SlurmV0041PostJobAllocateJSONBodyJobFlags = "SCHEDULING_ATTEMPTED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsSENDJOBENVIRONMENT       SlurmV0041PostJobAllocateJSONBodyJobFlags = "SEND_JOB_ENVIRONMENT"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsSIBLINGCLUSTERUPDATEONLY SlurmV0041PostJobAllocateJSONBodyJobFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsSKIPTRESSTRINGACCOUNTING SlurmV0041PostJobAllocateJSONBodyJobFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsSPREADJOB                SlurmV0041PostJobAllocateJSONBodyJobFlags = "SPREAD_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsSTEPMGRENABLED           SlurmV0041PostJobAllocateJSONBodyJobFlags = "STEPMGR_ENABLED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsTESTINGBACKFILL          SlurmV0041PostJobAllocateJSONBodyJobFlags = "TESTING_BACKFILL"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsTESTINGWHOLENODEBACKFILL SlurmV0041PostJobAllocateJSONBodyJobFlags = "TESTING_WHOLE_NODE_BACKFILL"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsTESTNOWONLY              SlurmV0041PostJobAllocateJSONBodyJobFlags = "TEST_NOW_ONLY"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsTOPPRIORITYJOB           SlurmV0041PostJobAllocateJSONBodyJobFlags = "TOP_PRIORITY_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsUSINGDEFAULTACCOUNT      SlurmV0041PostJobAllocateJSONBodyJobFlags = "USING_DEFAULT_ACCOUNT"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsUSINGDEFAULTPARTITION    SlurmV0041PostJobAllocateJSONBodyJobFlags = "USING_DEFAULT_PARTITION"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsUSINGDEFAULTQOS          SlurmV0041PostJobAllocateJSONBodyJobFlags = "USING_DEFAULT_QOS"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsUSINGDEFAULTWCKEY        SlurmV0041PostJobAllocateJSONBodyJobFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsARRAYTASK         SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "ARRAY_TASK"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsBATCHJOB          SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "BATCH_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsCRONJOBS          SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "CRON_JOBS"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsFEDERATIONREQUEUE SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsFULLJOB           SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "FULL_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsFULLSTEPSONLY     SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsHURRY             SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "HURRY"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsNOSIBLINGJOBS     SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsOUTOFMEMORY       SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsRESERVATIONJOB    SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "RESERVATION_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsVERBOSE           SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "VERBOSE"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsWARNINGSENT       SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobMailType.
const (
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeARRAYTASKS        SlurmV0041PostJobAllocateJSONBodyJobMailType = "ARRAY_TASKS"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeBEGIN             SlurmV0041PostJobAllocateJSONBodyJobMailType = "BEGIN"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeEND               SlurmV0041PostJobAllocateJSONBodyJobMailType = "END"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeFAIL              SlurmV0041PostJobAllocateJSONBodyJobMailType = "FAIL"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeINVALIDDEPENDENCY SlurmV0041PostJobAllocateJSONBodyJobMailType = "INVALID_DEPENDENCY"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeREQUEUE           SlurmV0041PostJobAllocateJSONBodyJobMailType = "REQUEUE"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeSTAGEOUT          SlurmV0041PostJobAllocateJSONBodyJobMailType = "STAGE_OUT"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeTIME100           SlurmV0041PostJobAllocateJSONBodyJobMailType = "TIME=100%"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeTIME50            SlurmV0041PostJobAllocateJSONBodyJobMailType = "TIME=50%"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeTIME80            SlurmV0041PostJobAllocateJSONBodyJobMailType = "TIME=80%"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeTIME90            SlurmV0041PostJobAllocateJSONBodyJobMailType = "TIME=90%"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType.
const (
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeLOCAL   SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "LOCAL"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeMAP     SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "MAP"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeMASK    SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "MASK"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeNONE    SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "NONE"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypePREFER  SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "PREFER"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeRANK    SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "RANK"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeSORT    SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "SORT"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeVERBOSE SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobOpenMode.
const (
	SlurmV0041PostJobAllocateJSONBodyJobOpenModeAPPEND   SlurmV0041PostJobAllocateJSONBodyJobOpenMode = "APPEND"
	SlurmV0041PostJobAllocateJSONBodyJobOpenModeTRUNCATE SlurmV0041PostJobAllocateJSONBodyJobOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobProfile.
const (
	SlurmV0041PostJobAllocateJSONBodyJobProfileENERGY  SlurmV0041PostJobAllocateJSONBodyJobProfile = "ENERGY"
	SlurmV0041PostJobAllocateJSONBodyJobProfileLUSTRE  SlurmV0041PostJobAllocateJSONBodyJobProfile = "LUSTRE"
	SlurmV0041PostJobAllocateJSONBodyJobProfileNETWORK SlurmV0041PostJobAllocateJSONBodyJobProfile = "NETWORK"
	SlurmV0041PostJobAllocateJSONBodyJobProfileNONE    SlurmV0041PostJobAllocateJSONBodyJobProfile = "NONE"
	SlurmV0041PostJobAllocateJSONBodyJobProfileNOTSET  SlurmV0041PostJobAllocateJSONBodyJobProfile = "NOT_SET"
	SlurmV0041PostJobAllocateJSONBodyJobProfileTASK    SlurmV0041PostJobAllocateJSONBodyJobProfile = "TASK"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobShared.
const (
	SlurmV0041PostJobAllocateJSONBodyJobSharedMcs           SlurmV0041PostJobAllocateJSONBodyJobShared = "mcs"
	SlurmV0041PostJobAllocateJSONBodyJobSharedNone          SlurmV0041PostJobAllocateJSONBodyJobShared = "none"
	SlurmV0041PostJobAllocateJSONBodyJobSharedOversubscribe SlurmV0041PostJobAllocateJSONBodyJobShared = "oversubscribe"
	SlurmV0041PostJobAllocateJSONBodyJobSharedTopo          SlurmV0041PostJobAllocateJSONBodyJobShared = "topo"
	SlurmV0041PostJobAllocateJSONBodyJobSharedUser          SlurmV0041PostJobAllocateJSONBodyJobShared = "user"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobX11.
const (
	SlurmV0041PostJobAllocateJSONBodyJobX11BATCHNODE       SlurmV0041PostJobAllocateJSONBodyJobX11 = "BATCH_NODE"
	SlurmV0041PostJobAllocateJSONBodyJobX11FIRSTNODE       SlurmV0041PostJobAllocateJSONBodyJobX11 = "FIRST_NODE"
	SlurmV0041PostJobAllocateJSONBodyJobX11FORWARDALLNODES SlurmV0041PostJobAllocateJSONBodyJobX11 = "FORWARD_ALL_NODES"
	SlurmV0041PostJobAllocateJSONBodyJobX11LASTNODE        SlurmV0041PostJobAllocateJSONBodyJobX11 = "LAST_NODE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDLDMAP            SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDLDMASK           SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDLDRANK           SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDMAP              SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDMASK             SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDNONE             SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDRANK             SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDTOCORES          SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsVERBOSE                 SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobCrontabFlagsWILDDAYOFMONTH SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags = "WILD_DAY_OF_MONTH"
	SlurmV0041PostJobSubmitJSONBodyJobCrontabFlagsWILDDAYOFWEEK  SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags = "WILD_DAY_OF_WEEK"
	SlurmV0041PostJobSubmitJSONBodyJobCrontabFlagsWILDHOUR       SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags = "WILD_HOUR"
	SlurmV0041PostJobSubmitJSONBodyJobCrontabFlagsWILDMINUTE     SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags = "WILD_MINUTE"
	SlurmV0041PostJobSubmitJSONBodyJobCrontabFlagsWILDMONTH      SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobExclusive.
const (
	SlurmV0041PostJobSubmitJSONBodyJobExclusiveFalse SlurmV0041PostJobSubmitJSONBodyJobExclusive = "false"
	SlurmV0041PostJobSubmitJSONBodyJobExclusiveMcs   SlurmV0041PostJobSubmitJSONBodyJobExclusive = "mcs"
	SlurmV0041PostJobSubmitJSONBodyJobExclusiveTopo  SlurmV0041PostJobSubmitJSONBodyJobExclusive = "topo"
	SlurmV0041PostJobSubmitJSONBodyJobExclusiveTrue  SlurmV0041PostJobSubmitJSONBodyJobExclusive = "true"
	SlurmV0041PostJobSubmitJSONBodyJobExclusiveUser  SlurmV0041PostJobSubmitJSONBodyJobExclusive = "user"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobFlagsACCRUECOUNTCLEARED       SlurmV0041PostJobSubmitJSONBodyJobFlags = "ACCRUE_COUNT_CLEARED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsBACKFILLATTEMPTED        SlurmV0041PostJobSubmitJSONBodyJobFlags = "BACKFILL_ATTEMPTED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsCRONJOB                  SlurmV0041PostJobSubmitJSONBodyJobFlags = "CRON_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsDEPENDENT                SlurmV0041PostJobSubmitJSONBodyJobFlags = "DEPENDENT"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsEXACTCPUCOUNTREQUESTED   SlurmV0041PostJobSubmitJSONBodyJobFlags = "EXACT_CPU_COUNT_REQUESTED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsEXACTMEMORYREQUESTED     SlurmV0041PostJobSubmitJSONBodyJobFlags = "EXACT_MEMORY_REQUESTED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsEXACTTASKCOUNTREQUESTED  SlurmV0041PostJobSubmitJSONBodyJobFlags = "EXACT_TASK_COUNT_REQUESTED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsGRESBINDINGDISABLED      SlurmV0041PostJobSubmitJSONBodyJobFlags = "GRES_BINDING_DISABLED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsGRESBINDINGENFORCED      SlurmV0041PostJobSubmitJSONBodyJobFlags = "GRES_BINDING_ENFORCED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsHASSTATEDIRECTORY        SlurmV0041PostJobSubmitJSONBodyJobFlags = "HAS_STATE_DIRECTORY"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsHETEROGENEOUSJOB         SlurmV0041PostJobSubmitJSONBodyJobFlags = "HETEROGENEOUS_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsJOBACCRUETIMERESET       SlurmV0041PostJobSubmitJSONBodyJobFlags = "JOB_ACCRUE_TIME_RESET"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsJOBKILLHURRY             SlurmV0041PostJobSubmitJSONBodyJobFlags = "JOB_KILL_HURRY"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsJOBWASRUNNING            SlurmV0041PostJobSubmitJSONBodyJobFlags = "JOB_WAS_RUNNING"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsKILLINVALIDDEPENDENCY    SlurmV0041PostJobSubmitJSONBodyJobFlags = "KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsMAGNETIC                 SlurmV0041PostJobSubmitJSONBodyJobFlags = "MAGNETIC"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsNOKILLINVALIDDEPENDENCY  SlurmV0041PostJobSubmitJSONBodyJobFlags = "NO_KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsPARTITIONASSIGNED        SlurmV0041PostJobSubmitJSONBodyJobFlags = "PARTITION_ASSIGNED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsPREFERMINIMUMNODECOUNT   SlurmV0041PostJobSubmitJSONBodyJobFlags = "PREFER_MINIMUM_NODE_COUNT"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsSCHEDULINGATTEMPTED      SlurmV0041PostJobSubmitJSONBodyJobFlags = "SCHEDULING_ATTEMPTED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsSENDJOBENVIRONMENT       SlurmV0041PostJobSubmitJSONBodyJobFlags = "SEND_JOB_ENVIRONMENT"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsSIBLINGCLUSTERUPDATEONLY SlurmV0041PostJobSubmitJSONBodyJobFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsSKIPTRESSTRINGACCOUNTING SlurmV0041PostJobSubmitJSONBodyJobFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsSPREADJOB                SlurmV0041PostJobSubmitJSONBodyJobFlags = "SPREAD_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsSTEPMGRENABLED           SlurmV0041PostJobSubmitJSONBodyJobFlags = "STEPMGR_ENABLED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsTESTINGBACKFILL          SlurmV0041PostJobSubmitJSONBodyJobFlags = "TESTING_BACKFILL"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsTESTINGWHOLENODEBACKFILL SlurmV0041PostJobSubmitJSONBodyJobFlags = "TESTING_WHOLE_NODE_BACKFILL"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsTESTNOWONLY              SlurmV0041PostJobSubmitJSONBodyJobFlags = "TEST_NOW_ONLY"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsTOPPRIORITYJOB           SlurmV0041PostJobSubmitJSONBodyJobFlags = "TOP_PRIORITY_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsUSINGDEFAULTACCOUNT      SlurmV0041PostJobSubmitJSONBodyJobFlags = "USING_DEFAULT_ACCOUNT"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsUSINGDEFAULTPARTITION    SlurmV0041PostJobSubmitJSONBodyJobFlags = "USING_DEFAULT_PARTITION"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsUSINGDEFAULTQOS          SlurmV0041PostJobSubmitJSONBodyJobFlags = "USING_DEFAULT_QOS"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsUSINGDEFAULTWCKEY        SlurmV0041PostJobSubmitJSONBodyJobFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsARRAYTASK         SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "ARRAY_TASK"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsBATCHJOB          SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "BATCH_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsCRONJOBS          SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "CRON_JOBS"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsFEDERATIONREQUEUE SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsFULLJOB           SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "FULL_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsFULLSTEPSONLY     SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsHURRY             SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "HURRY"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsNOSIBLINGJOBS     SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsOUTOFMEMORY       SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsRESERVATIONJOB    SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "RESERVATION_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsVERBOSE           SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "VERBOSE"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsWARNINGSENT       SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobMailType.
const (
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeARRAYTASKS        SlurmV0041PostJobSubmitJSONBodyJobMailType = "ARRAY_TASKS"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeBEGIN             SlurmV0041PostJobSubmitJSONBodyJobMailType = "BEGIN"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeEND               SlurmV0041PostJobSubmitJSONBodyJobMailType = "END"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeFAIL              SlurmV0041PostJobSubmitJSONBodyJobMailType = "FAIL"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeINVALIDDEPENDENCY SlurmV0041PostJobSubmitJSONBodyJobMailType = "INVALID_DEPENDENCY"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeREQUEUE           SlurmV0041PostJobSubmitJSONBodyJobMailType = "REQUEUE"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeSTAGEOUT          SlurmV0041PostJobSubmitJSONBodyJobMailType = "STAGE_OUT"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeTIME100           SlurmV0041PostJobSubmitJSONBodyJobMailType = "TIME=100%"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeTIME50            SlurmV0041PostJobSubmitJSONBodyJobMailType = "TIME=50%"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeTIME80            SlurmV0041PostJobSubmitJSONBodyJobMailType = "TIME=80%"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeTIME90            SlurmV0041PostJobSubmitJSONBodyJobMailType = "TIME=90%"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType.
const (
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeLOCAL   SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "LOCAL"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeMAP     SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "MAP"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeMASK    SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "MASK"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeNONE    SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "NONE"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypePREFER  SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "PREFER"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeRANK    SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "RANK"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeSORT    SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "SORT"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeVERBOSE SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobOpenMode.
const (
	SlurmV0041PostJobSubmitJSONBodyJobOpenModeAPPEND   SlurmV0041PostJobSubmitJSONBodyJobOpenMode = "APPEND"
	SlurmV0041PostJobSubmitJSONBodyJobOpenModeTRUNCATE SlurmV0041PostJobSubmitJSONBodyJobOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobProfile.
const (
	SlurmV0041PostJobSubmitJSONBodyJobProfileENERGY  SlurmV0041PostJobSubmitJSONBodyJobProfile = "ENERGY"
	SlurmV0041PostJobSubmitJSONBodyJobProfileLUSTRE  SlurmV0041PostJobSubmitJSONBodyJobProfile = "LUSTRE"
	SlurmV0041PostJobSubmitJSONBodyJobProfileNETWORK SlurmV0041PostJobSubmitJSONBodyJobProfile = "NETWORK"
	SlurmV0041PostJobSubmitJSONBodyJobProfileNONE    SlurmV0041PostJobSubmitJSONBodyJobProfile = "NONE"
	SlurmV0041PostJobSubmitJSONBodyJobProfileNOTSET  SlurmV0041PostJobSubmitJSONBodyJobProfile = "NOT_SET"
	SlurmV0041PostJobSubmitJSONBodyJobProfileTASK    SlurmV0041PostJobSubmitJSONBodyJobProfile = "TASK"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobShared.
const (
	SlurmV0041PostJobSubmitJSONBodyJobSharedMcs           SlurmV0041PostJobSubmitJSONBodyJobShared = "mcs"
	SlurmV0041PostJobSubmitJSONBodyJobSharedNone          SlurmV0041PostJobSubmitJSONBodyJobShared = "none"
	SlurmV0041PostJobSubmitJSONBodyJobSharedOversubscribe SlurmV0041PostJobSubmitJSONBodyJobShared = "oversubscribe"
	SlurmV0041PostJobSubmitJSONBodyJobSharedTopo          SlurmV0041PostJobSubmitJSONBodyJobShared = "topo"
	SlurmV0041PostJobSubmitJSONBodyJobSharedUser          SlurmV0041PostJobSubmitJSONBodyJobShared = "user"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobX11.
const (
	SlurmV0041PostJobSubmitJSONBodyJobX11BATCHNODE       SlurmV0041PostJobSubmitJSONBodyJobX11 = "BATCH_NODE"
	SlurmV0041PostJobSubmitJSONBodyJobX11FIRSTNODE       SlurmV0041PostJobSubmitJSONBodyJobX11 = "FIRST_NODE"
	SlurmV0041PostJobSubmitJSONBodyJobX11FORWARDALLNODES SlurmV0041PostJobSubmitJSONBodyJobX11 = "FORWARD_ALL_NODES"
	SlurmV0041PostJobSubmitJSONBodyJobX11LASTNODE        SlurmV0041PostJobSubmitJSONBodyJobX11 = "LAST_NODE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDLDMAP            SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDLDMASK           SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDLDRANK           SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDMAP              SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDMASK             SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDNONE             SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDRANK             SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDTOCORES          SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsVERBOSE                 SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlagsWILDDAYOFMONTH SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags = "WILD_DAY_OF_MONTH"
	SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlagsWILDDAYOFWEEK  SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags = "WILD_DAY_OF_WEEK"
	SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlagsWILDHOUR       SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags = "WILD_HOUR"
	SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlagsWILDMINUTE     SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags = "WILD_MINUTE"
	SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlagsWILDMONTH      SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsExclusive.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsExclusiveFalse SlurmV0041PostJobSubmitJSONBodyJobsExclusive = "false"
	SlurmV0041PostJobSubmitJSONBodyJobsExclusiveMcs   SlurmV0041PostJobSubmitJSONBodyJobsExclusive = "mcs"
	SlurmV0041PostJobSubmitJSONBodyJobsExclusiveTopo  SlurmV0041PostJobSubmitJSONBodyJobsExclusive = "topo"
	SlurmV0041PostJobSubmitJSONBodyJobsExclusiveTrue  SlurmV0041PostJobSubmitJSONBodyJobsExclusive = "true"
	SlurmV0041PostJobSubmitJSONBodyJobsExclusiveUser  SlurmV0041PostJobSubmitJSONBodyJobsExclusive = "user"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsACCRUECOUNTCLEARED       SlurmV0041PostJobSubmitJSONBodyJobsFlags = "ACCRUE_COUNT_CLEARED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsBACKFILLATTEMPTED        SlurmV0041PostJobSubmitJSONBodyJobsFlags = "BACKFILL_ATTEMPTED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsCRONJOB                  SlurmV0041PostJobSubmitJSONBodyJobsFlags = "CRON_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsDEPENDENT                SlurmV0041PostJobSubmitJSONBodyJobsFlags = "DEPENDENT"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsEXACTCPUCOUNTREQUESTED   SlurmV0041PostJobSubmitJSONBodyJobsFlags = "EXACT_CPU_COUNT_REQUESTED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsEXACTMEMORYREQUESTED     SlurmV0041PostJobSubmitJSONBodyJobsFlags = "EXACT_MEMORY_REQUESTED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsEXACTTASKCOUNTREQUESTED  SlurmV0041PostJobSubmitJSONBodyJobsFlags = "EXACT_TASK_COUNT_REQUESTED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsGRESBINDINGDISABLED      SlurmV0041PostJobSubmitJSONBodyJobsFlags = "GRES_BINDING_DISABLED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsGRESBINDINGENFORCED      SlurmV0041PostJobSubmitJSONBodyJobsFlags = "GRES_BINDING_ENFORCED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsHASSTATEDIRECTORY        SlurmV0041PostJobSubmitJSONBodyJobsFlags = "HAS_STATE_DIRECTORY"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsHETEROGENEOUSJOB         SlurmV0041PostJobSubmitJSONBodyJobsFlags = "HETEROGENEOUS_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsJOBACCRUETIMERESET       SlurmV0041PostJobSubmitJSONBodyJobsFlags = "JOB_ACCRUE_TIME_RESET"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsJOBKILLHURRY             SlurmV0041PostJobSubmitJSONBodyJobsFlags = "JOB_KILL_HURRY"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsJOBWASRUNNING            SlurmV0041PostJobSubmitJSONBodyJobsFlags = "JOB_WAS_RUNNING"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsKILLINVALIDDEPENDENCY    SlurmV0041PostJobSubmitJSONBodyJobsFlags = "KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsMAGNETIC                 SlurmV0041PostJobSubmitJSONBodyJobsFlags = "MAGNETIC"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsNOKILLINVALIDDEPENDENCY  SlurmV0041PostJobSubmitJSONBodyJobsFlags = "NO_KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsPARTITIONASSIGNED        SlurmV0041PostJobSubmitJSONBodyJobsFlags = "PARTITION_ASSIGNED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsPREFERMINIMUMNODECOUNT   SlurmV0041PostJobSubmitJSONBodyJobsFlags = "PREFER_MINIMUM_NODE_COUNT"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsSCHEDULINGATTEMPTED      SlurmV0041PostJobSubmitJSONBodyJobsFlags = "SCHEDULING_ATTEMPTED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsSENDJOBENVIRONMENT       SlurmV0041PostJobSubmitJSONBodyJobsFlags = "SEND_JOB_ENVIRONMENT"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsSIBLINGCLUSTERUPDATEONLY SlurmV0041PostJobSubmitJSONBodyJobsFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsSKIPTRESSTRINGACCOUNTING SlurmV0041PostJobSubmitJSONBodyJobsFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsSPREADJOB                SlurmV0041PostJobSubmitJSONBodyJobsFlags = "SPREAD_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsSTEPMGRENABLED           SlurmV0041PostJobSubmitJSONBodyJobsFlags = "STEPMGR_ENABLED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsTESTINGBACKFILL          SlurmV0041PostJobSubmitJSONBodyJobsFlags = "TESTING_BACKFILL"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsTESTINGWHOLENODEBACKFILL SlurmV0041PostJobSubmitJSONBodyJobsFlags = "TESTING_WHOLE_NODE_BACKFILL"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsTESTNOWONLY              SlurmV0041PostJobSubmitJSONBodyJobsFlags = "TEST_NOW_ONLY"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsTOPPRIORITYJOB           SlurmV0041PostJobSubmitJSONBodyJobsFlags = "TOP_PRIORITY_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsUSINGDEFAULTACCOUNT      SlurmV0041PostJobSubmitJSONBodyJobsFlags = "USING_DEFAULT_ACCOUNT"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsUSINGDEFAULTPARTITION    SlurmV0041PostJobSubmitJSONBodyJobsFlags = "USING_DEFAULT_PARTITION"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsUSINGDEFAULTQOS          SlurmV0041PostJobSubmitJSONBodyJobsFlags = "USING_DEFAULT_QOS"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsUSINGDEFAULTWCKEY        SlurmV0041PostJobSubmitJSONBodyJobsFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsARRAYTASK         SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "ARRAY_TASK"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsBATCHJOB          SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "BATCH_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsCRONJOBS          SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "CRON_JOBS"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsFEDERATIONREQUEUE SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsFULLJOB           SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "FULL_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsFULLSTEPSONLY     SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsHURRY             SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "HURRY"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsNOSIBLINGJOBS     SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsOUTOFMEMORY       SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsRESERVATIONJOB    SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "RESERVATION_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsVERBOSE           SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "VERBOSE"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsWARNINGSENT       SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsMailType.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeARRAYTASKS        SlurmV0041PostJobSubmitJSONBodyJobsMailType = "ARRAY_TASKS"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeBEGIN             SlurmV0041PostJobSubmitJSONBodyJobsMailType = "BEGIN"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeEND               SlurmV0041PostJobSubmitJSONBodyJobsMailType = "END"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeFAIL              SlurmV0041PostJobSubmitJSONBodyJobsMailType = "FAIL"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeINVALIDDEPENDENCY SlurmV0041PostJobSubmitJSONBodyJobsMailType = "INVALID_DEPENDENCY"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeREQUEUE           SlurmV0041PostJobSubmitJSONBodyJobsMailType = "REQUEUE"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeSTAGEOUT          SlurmV0041PostJobSubmitJSONBodyJobsMailType = "STAGE_OUT"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeTIME100           SlurmV0041PostJobSubmitJSONBodyJobsMailType = "TIME=100%"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeTIME50            SlurmV0041PostJobSubmitJSONBodyJobsMailType = "TIME=50%"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeTIME80            SlurmV0041PostJobSubmitJSONBodyJobsMailType = "TIME=80%"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeTIME90            SlurmV0041PostJobSubmitJSONBodyJobsMailType = "TIME=90%"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeLOCAL   SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "LOCAL"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeMAP     SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "MAP"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeMASK    SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "MASK"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeNONE    SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "NONE"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypePREFER  SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "PREFER"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeRANK    SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "RANK"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeSORT    SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "SORT"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeVERBOSE SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsOpenMode.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsOpenModeAPPEND   SlurmV0041PostJobSubmitJSONBodyJobsOpenMode = "APPEND"
	SlurmV0041PostJobSubmitJSONBodyJobsOpenModeTRUNCATE SlurmV0041PostJobSubmitJSONBodyJobsOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsProfile.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsProfileENERGY  SlurmV0041PostJobSubmitJSONBodyJobsProfile = "ENERGY"
	SlurmV0041PostJobSubmitJSONBodyJobsProfileLUSTRE  SlurmV0041PostJobSubmitJSONBodyJobsProfile = "LUSTRE"
	SlurmV0041PostJobSubmitJSONBodyJobsProfileNETWORK SlurmV0041PostJobSubmitJSONBodyJobsProfile = "NETWORK"
	SlurmV0041PostJobSubmitJSONBodyJobsProfileNONE    SlurmV0041PostJobSubmitJSONBodyJobsProfile = "NONE"
	SlurmV0041PostJobSubmitJSONBodyJobsProfileNOTSET  SlurmV0041PostJobSubmitJSONBodyJobsProfile = "NOT_SET"
	SlurmV0041PostJobSubmitJSONBodyJobsProfileTASK    SlurmV0041PostJobSubmitJSONBodyJobsProfile = "TASK"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsShared.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsSharedMcs           SlurmV0041PostJobSubmitJSONBodyJobsShared = "mcs"
	SlurmV0041PostJobSubmitJSONBodyJobsSharedNone          SlurmV0041PostJobSubmitJSONBodyJobsShared = "none"
	SlurmV0041PostJobSubmitJSONBodyJobsSharedOversubscribe SlurmV0041PostJobSubmitJSONBodyJobsShared = "oversubscribe"
	SlurmV0041PostJobSubmitJSONBodyJobsSharedTopo          SlurmV0041PostJobSubmitJSONBodyJobsShared = "topo"
	SlurmV0041PostJobSubmitJSONBodyJobsSharedUser          SlurmV0041PostJobSubmitJSONBodyJobsShared = "user"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsX11.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsX11BATCHNODE       SlurmV0041PostJobSubmitJSONBodyJobsX11 = "BATCH_NODE"
	SlurmV0041PostJobSubmitJSONBodyJobsX11FIRSTNODE       SlurmV0041PostJobSubmitJSONBodyJobsX11 = "FIRST_NODE"
	SlurmV0041PostJobSubmitJSONBodyJobsX11FORWARDALLNODES SlurmV0041PostJobSubmitJSONBodyJobsX11 = "FORWARD_ALL_NODES"
	SlurmV0041PostJobSubmitJSONBodyJobsX11LASTNODE        SlurmV0041PostJobSubmitJSONBodyJobsX11 = "LAST_NODE"
)

// Defines values for SlurmV0041DeleteJobParamsFlags.
const (
	SlurmV0041DeleteJobParamsFlagsARRAYTASK         SlurmV0041DeleteJobParamsFlags = "ARRAY_TASK"
	SlurmV0041DeleteJobParamsFlagsBATCHJOB          SlurmV0041DeleteJobParamsFlags = "BATCH_JOB"
	SlurmV0041DeleteJobParamsFlagsCRONJOBS          SlurmV0041DeleteJobParamsFlags = "CRON_JOBS"
	SlurmV0041DeleteJobParamsFlagsFEDERATIONREQUEUE SlurmV0041DeleteJobParamsFlags = "FEDERATION_REQUEUE"
	SlurmV0041DeleteJobParamsFlagsFULLJOB           SlurmV0041DeleteJobParamsFlags = "FULL_JOB"
	SlurmV0041DeleteJobParamsFlagsFULLSTEPSONLY     SlurmV0041DeleteJobParamsFlags = "FULL_STEPS_ONLY"
	SlurmV0041DeleteJobParamsFlagsHURRY             SlurmV0041DeleteJobParamsFlags = "HURRY"
	SlurmV0041DeleteJobParamsFlagsNOSIBLINGJOBS     SlurmV0041DeleteJobParamsFlags = "NO_SIBLING_JOBS"
	SlurmV0041DeleteJobParamsFlagsOUTOFMEMORY       SlurmV0041DeleteJobParamsFlags = "OUT_OF_MEMORY"
	SlurmV0041DeleteJobParamsFlagsRESERVATIONJOB    SlurmV0041DeleteJobParamsFlags = "RESERVATION_JOB"
	SlurmV0041DeleteJobParamsFlagsVERBOSE           SlurmV0041DeleteJobParamsFlags = "VERBOSE"
	SlurmV0041DeleteJobParamsFlagsWARNINGSENT       SlurmV0041DeleteJobParamsFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041GetJobParamsFlags.
const (
	SlurmV0041GetJobParamsFlagsALL        SlurmV0041GetJobParamsFlags = "ALL"
	SlurmV0041GetJobParamsFlagsDETAIL     SlurmV0041GetJobParamsFlags = "DETAIL"
	SlurmV0041GetJobParamsFlagsFEDERATION SlurmV0041GetJobParamsFlags = "FEDERATION"
	SlurmV0041GetJobParamsFlagsFUTURE     SlurmV0041GetJobParamsFlags = "FUTURE"
	SlurmV0041GetJobParamsFlagsLOCAL      SlurmV0041GetJobParamsFlags = "LOCAL"
	SlurmV0041GetJobParamsFlagsMIXED      SlurmV0041GetJobParamsFlags = "MIXED"
	SlurmV0041GetJobParamsFlagsSIBLING    SlurmV0041GetJobParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041PostJobJSONBodyCpuBindingFlags.
const (
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDLDMAP            SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDLDMASK           SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDLDRANK           SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDMAP              SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDMASK             SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDNONE             SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDRANK             SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDTOCORES          SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsVERBOSE                 SlurmV0041PostJobJSONBodyCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0041PostJobJSONBodyCrontabFlags.
const (
	WILDDAYOFMONTH SlurmV0041PostJobJSONBodyCrontabFlags = "WILD_DAY_OF_MONTH"
	WILDDAYOFWEEK  SlurmV0041PostJobJSONBodyCrontabFlags = "WILD_DAY_OF_WEEK"
	WILDHOUR       SlurmV0041PostJobJSONBodyCrontabFlags = "WILD_HOUR"
	WILDMINUTE     SlurmV0041PostJobJSONBodyCrontabFlags = "WILD_MINUTE"
	WILDMONTH      SlurmV0041PostJobJSONBodyCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0041PostJobJSONBodyExclusive.
const (
	SlurmV0041PostJobJSONBodyExclusiveFalse SlurmV0041PostJobJSONBodyExclusive = "false"
	SlurmV0041PostJobJSONBodyExclusiveMcs   SlurmV0041PostJobJSONBodyExclusive = "mcs"
	SlurmV0041PostJobJSONBodyExclusiveTopo  SlurmV0041PostJobJSONBodyExclusive = "topo"
	SlurmV0041PostJobJSONBodyExclusiveTrue  SlurmV0041PostJobJSONBodyExclusive = "true"
	SlurmV0041PostJobJSONBodyExclusiveUser  SlurmV0041PostJobJSONBodyExclusive = "user"
)

// Defines values for SlurmV0041PostJobJSONBodyFlags.
const (
	ACCRUECOUNTCLEARED       SlurmV0041PostJobJSONBodyFlags = "ACCRUE_COUNT_CLEARED"
	BACKFILLATTEMPTED        SlurmV0041PostJobJSONBodyFlags = "BACKFILL_ATTEMPTED"
	CRONJOB                  SlurmV0041PostJobJSONBodyFlags = "CRON_JOB"
	DEPENDENT                SlurmV0041PostJobJSONBodyFlags = "DEPENDENT"
	EXACTCPUCOUNTREQUESTED   SlurmV0041PostJobJSONBodyFlags = "EXACT_CPU_COUNT_REQUESTED"
	EXACTMEMORYREQUESTED     SlurmV0041PostJobJSONBodyFlags = "EXACT_MEMORY_REQUESTED"
	EXACTTASKCOUNTREQUESTED  SlurmV0041PostJobJSONBodyFlags = "EXACT_TASK_COUNT_REQUESTED"
	GRESBINDINGDISABLED      SlurmV0041PostJobJSONBodyFlags = "GRES_BINDING_DISABLED"
	GRESBINDINGENFORCED      SlurmV0041PostJobJSONBodyFlags = "GRES_BINDING_ENFORCED"
	HASSTATEDIRECTORY        SlurmV0041PostJobJSONBodyFlags = "HAS_STATE_DIRECTORY"
	HETEROGENEOUSJOB         SlurmV0041PostJobJSONBodyFlags = "HETEROGENEOUS_JOB"
	JOBACCRUETIMERESET       SlurmV0041PostJobJSONBodyFlags = "JOB_ACCRUE_TIME_RESET"
	JOBKILLHURRY             SlurmV0041PostJobJSONBodyFlags = "JOB_KILL_HURRY"
	JOBWASRUNNING            SlurmV0041PostJobJSONBodyFlags = "JOB_WAS_RUNNING"
	KILLINVALIDDEPENDENCY    SlurmV0041PostJobJSONBodyFlags = "KILL_INVALID_DEPENDENCY"
	MAGNETIC                 SlurmV0041PostJobJSONBodyFlags = "MAGNETIC"
	NOKILLINVALIDDEPENDENCY  SlurmV0041PostJobJSONBodyFlags = "NO_KILL_INVALID_DEPENDENCY"
	PARTITIONASSIGNED        SlurmV0041PostJobJSONBodyFlags = "PARTITION_ASSIGNED"
	PREFERMINIMUMNODECOUNT   SlurmV0041PostJobJSONBodyFlags = "PREFER_MINIMUM_NODE_COUNT"
	SCHEDULINGATTEMPTED      SlurmV0041PostJobJSONBodyFlags = "SCHEDULING_ATTEMPTED"
	SENDJOBENVIRONMENT       SlurmV0041PostJobJSONBodyFlags = "SEND_JOB_ENVIRONMENT"
	SIBLINGCLUSTERUPDATEONLY SlurmV0041PostJobJSONBodyFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SKIPTRESSTRINGACCOUNTING SlurmV0041PostJobJSONBodyFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SPREADJOB                SlurmV0041PostJobJSONBodyFlags = "SPREAD_JOB"
	STEPMGRENABLED           SlurmV0041PostJobJSONBodyFlags = "STEPMGR_ENABLED"
	TESTINGBACKFILL          SlurmV0041PostJobJSONBodyFlags = "TESTING_BACKFILL"
	TESTINGWHOLENODEBACKFILL SlurmV0041PostJobJSONBodyFlags = "TESTING_WHOLE_NODE_BACKFILL"
	TESTNOWONLY              SlurmV0041PostJobJSONBodyFlags = "TEST_NOW_ONLY"
	TOPPRIORITYJOB           SlurmV0041PostJobJSONBodyFlags = "TOP_PRIORITY_JOB"
	USINGDEFAULTACCOUNT      SlurmV0041PostJobJSONBodyFlags = "USING_DEFAULT_ACCOUNT"
	USINGDEFAULTPARTITION    SlurmV0041PostJobJSONBodyFlags = "USING_DEFAULT_PARTITION"
	USINGDEFAULTQOS          SlurmV0041PostJobJSONBodyFlags = "USING_DEFAULT_QOS"
	USINGDEFAULTWCKEY        SlurmV0041PostJobJSONBodyFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0041PostJobJSONBodyKillWarningFlags.
const (
	SlurmV0041PostJobJSONBodyKillWarningFlagsARRAYTASK         SlurmV0041PostJobJSONBodyKillWarningFlags = "ARRAY_TASK"
	SlurmV0041PostJobJSONBodyKillWarningFlagsBATCHJOB          SlurmV0041PostJobJSONBodyKillWarningFlags = "BATCH_JOB"
	SlurmV0041PostJobJSONBodyKillWarningFlagsCRONJOBS          SlurmV0041PostJobJSONBodyKillWarningFlags = "CRON_JOBS"
	SlurmV0041PostJobJSONBodyKillWarningFlagsFEDERATIONREQUEUE SlurmV0041PostJobJSONBodyKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0041PostJobJSONBodyKillWarningFlagsFULLJOB           SlurmV0041PostJobJSONBodyKillWarningFlags = "FULL_JOB"
	SlurmV0041PostJobJSONBodyKillWarningFlagsFULLSTEPSONLY     SlurmV0041PostJobJSONBodyKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0041PostJobJSONBodyKillWarningFlagsHURRY             SlurmV0041PostJobJSONBodyKillWarningFlags = "HURRY"
	SlurmV0041PostJobJSONBodyKillWarningFlagsNOSIBLINGJOBS     SlurmV0041PostJobJSONBodyKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0041PostJobJSONBodyKillWarningFlagsOUTOFMEMORY       SlurmV0041PostJobJSONBodyKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0041PostJobJSONBodyKillWarningFlagsRESERVATIONJOB    SlurmV0041PostJobJSONBodyKillWarningFlags = "RESERVATION_JOB"
	SlurmV0041PostJobJSONBodyKillWarningFlagsVERBOSE           SlurmV0041PostJobJSONBodyKillWarningFlags = "VERBOSE"
	SlurmV0041PostJobJSONBodyKillWarningFlagsWARNINGSENT       SlurmV0041PostJobJSONBodyKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041PostJobJSONBodyMailType.
const (
	SlurmV0041PostJobJSONBodyMailTypeARRAYTASKS        SlurmV0041PostJobJSONBodyMailType = "ARRAY_TASKS"
	SlurmV0041PostJobJSONBodyMailTypeBEGIN             SlurmV0041PostJobJSONBodyMailType = "BEGIN"
	SlurmV0041PostJobJSONBodyMailTypeEND               SlurmV0041PostJobJSONBodyMailType = "END"
	SlurmV0041PostJobJSONBodyMailTypeFAIL              SlurmV0041PostJobJSONBodyMailType = "FAIL"
	SlurmV0041PostJobJSONBodyMailTypeINVALIDDEPENDENCY SlurmV0041PostJobJSONBodyMailType = "INVALID_DEPENDENCY"
	SlurmV0041PostJobJSONBodyMailTypeREQUEUE           SlurmV0041PostJobJSONBodyMailType = "REQUEUE"
	SlurmV0041PostJobJSONBodyMailTypeSTAGEOUT          SlurmV0041PostJobJSONBodyMailType = "STAGE_OUT"
	SlurmV0041PostJobJSONBodyMailTypeTIME100           SlurmV0041PostJobJSONBodyMailType = "TIME=100%"
	SlurmV0041PostJobJSONBodyMailTypeTIME50            SlurmV0041PostJobJSONBodyMailType = "TIME=50%"
	SlurmV0041PostJobJSONBodyMailTypeTIME80            SlurmV0041PostJobJSONBodyMailType = "TIME=80%"
	SlurmV0041PostJobJSONBodyMailTypeTIME90            SlurmV0041PostJobJSONBodyMailType = "TIME=90%"
)

// Defines values for SlurmV0041PostJobJSONBodyMemoryBindingType.
const (
	SlurmV0041PostJobJSONBodyMemoryBindingTypeLOCAL   SlurmV0041PostJobJSONBodyMemoryBindingType = "LOCAL"
	SlurmV0041PostJobJSONBodyMemoryBindingTypeMAP     SlurmV0041PostJobJSONBodyMemoryBindingType = "MAP"
	SlurmV0041PostJobJSONBodyMemoryBindingTypeMASK    SlurmV0041PostJobJSONBodyMemoryBindingType = "MASK"
	SlurmV0041PostJobJSONBodyMemoryBindingTypeNONE    SlurmV0041PostJobJSONBodyMemoryBindingType = "NONE"
	SlurmV0041PostJobJSONBodyMemoryBindingTypePREFER  SlurmV0041PostJobJSONBodyMemoryBindingType = "PREFER"
	SlurmV0041PostJobJSONBodyMemoryBindingTypeRANK    SlurmV0041PostJobJSONBodyMemoryBindingType = "RANK"
	SlurmV0041PostJobJSONBodyMemoryBindingTypeSORT    SlurmV0041PostJobJSONBodyMemoryBindingType = "SORT"
	SlurmV0041PostJobJSONBodyMemoryBindingTypeVERBOSE SlurmV0041PostJobJSONBodyMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0041PostJobJSONBodyOpenMode.
const (
	APPEND   SlurmV0041PostJobJSONBodyOpenMode = "APPEND"
	TRUNCATE SlurmV0041PostJobJSONBodyOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0041PostJobJSONBodyProfile.
const (
	ENERGY  SlurmV0041PostJobJSONBodyProfile = "ENERGY"
	LUSTRE  SlurmV0041PostJobJSONBodyProfile = "LUSTRE"
	NETWORK SlurmV0041PostJobJSONBodyProfile = "NETWORK"
	NONE    SlurmV0041PostJobJSONBodyProfile = "NONE"
	NOTSET  SlurmV0041PostJobJSONBodyProfile = "NOT_SET"
	TASK    SlurmV0041PostJobJSONBodyProfile = "TASK"
)

// Defines values for SlurmV0041PostJobJSONBodyShared.
const (
	SlurmV0041PostJobJSONBodySharedMcs           SlurmV0041PostJobJSONBodyShared = "mcs"
	SlurmV0041PostJobJSONBodySharedNone          SlurmV0041PostJobJSONBodyShared = "none"
	SlurmV0041PostJobJSONBodySharedOversubscribe SlurmV0041PostJobJSONBodyShared = "oversubscribe"
	SlurmV0041PostJobJSONBodySharedTopo          SlurmV0041PostJobJSONBodyShared = "topo"
	SlurmV0041PostJobJSONBodySharedUser          SlurmV0041PostJobJSONBodyShared = "user"
)

// Defines values for SlurmV0041PostJobJSONBodyX11.
const (
	BATCHNODE       SlurmV0041PostJobJSONBodyX11 = "BATCH_NODE"
	FIRSTNODE       SlurmV0041PostJobJSONBodyX11 = "FIRST_NODE"
	FORWARDALLNODES SlurmV0041PostJobJSONBodyX11 = "FORWARD_ALL_NODES"
	LASTNODE        SlurmV0041PostJobJSONBodyX11 = "LAST_NODE"
)

// Defines values for SlurmV0041DeleteJobsJSONBodyFlags.
const (
	SlurmV0041DeleteJobsJSONBodyFlagsARRAYTASK         SlurmV0041DeleteJobsJSONBodyFlags = "ARRAY_TASK"
	SlurmV0041DeleteJobsJSONBodyFlagsBATCHJOB          SlurmV0041DeleteJobsJSONBodyFlags = "BATCH_JOB"
	SlurmV0041DeleteJobsJSONBodyFlagsCRONJOBS          SlurmV0041DeleteJobsJSONBodyFlags = "CRON_JOBS"
	SlurmV0041DeleteJobsJSONBodyFlagsFEDERATIONREQUEUE SlurmV0041DeleteJobsJSONBodyFlags = "FEDERATION_REQUEUE"
	SlurmV0041DeleteJobsJSONBodyFlagsFULLJOB           SlurmV0041DeleteJobsJSONBodyFlags = "FULL_JOB"
	SlurmV0041DeleteJobsJSONBodyFlagsFULLSTEPSONLY     SlurmV0041DeleteJobsJSONBodyFlags = "FULL_STEPS_ONLY"
	SlurmV0041DeleteJobsJSONBodyFlagsHURRY             SlurmV0041DeleteJobsJSONBodyFlags = "HURRY"
	SlurmV0041DeleteJobsJSONBodyFlagsNOSIBLINGJOBS     SlurmV0041DeleteJobsJSONBodyFlags = "NO_SIBLING_JOBS"
	SlurmV0041DeleteJobsJSONBodyFlagsOUTOFMEMORY       SlurmV0041DeleteJobsJSONBodyFlags = "OUT_OF_MEMORY"
	SlurmV0041DeleteJobsJSONBodyFlagsRESERVATIONJOB    SlurmV0041DeleteJobsJSONBodyFlags = "RESERVATION_JOB"
	SlurmV0041DeleteJobsJSONBodyFlagsVERBOSE           SlurmV0041DeleteJobsJSONBodyFlags = "VERBOSE"
	SlurmV0041DeleteJobsJSONBodyFlagsWARNINGSENT       SlurmV0041DeleteJobsJSONBodyFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041DeleteJobsJSONBodyJobState.
const (
	SlurmV0041DeleteJobsJSONBodyJobStateBOOTFAIL     SlurmV0041DeleteJobsJSONBodyJobState = "BOOT_FAIL"
	SlurmV0041DeleteJobsJSONBodyJobStateCANCELLED    SlurmV0041DeleteJobsJSONBodyJobState = "CANCELLED"
	SlurmV0041DeleteJobsJSONBodyJobStateCOMPLETED    SlurmV0041DeleteJobsJSONBodyJobState = "COMPLETED"
	SlurmV0041DeleteJobsJSONBodyJobStateCOMPLETING   SlurmV0041DeleteJobsJSONBodyJobState = "COMPLETING"
	SlurmV0041DeleteJobsJSONBodyJobStateCONFIGURING  SlurmV0041DeleteJobsJSONBodyJobState = "CONFIGURING"
	SlurmV0041DeleteJobsJSONBodyJobStateDEADLINE     SlurmV0041DeleteJobsJSONBodyJobState = "DEADLINE"
	SlurmV0041DeleteJobsJSONBodyJobStateFAILED       SlurmV0041DeleteJobsJSONBodyJobState = "FAILED"
	SlurmV0041DeleteJobsJSONBodyJobStateLAUNCHFAILED SlurmV0041DeleteJobsJSONBodyJobState = "LAUNCH_FAILED"
	SlurmV0041DeleteJobsJSONBodyJobStateNODEFAIL     SlurmV0041DeleteJobsJSONBodyJobState = "NODE_FAIL"
	SlurmV0041DeleteJobsJSONBodyJobStateOUTOFMEMORY  SlurmV0041DeleteJobsJSONBodyJobState = "OUT_OF_MEMORY"
	SlurmV0041DeleteJobsJSONBodyJobStatePENDING      SlurmV0041DeleteJobsJSONBodyJobState = "PENDING"
	SlurmV0041DeleteJobsJSONBodyJobStatePOWERUPNODE  SlurmV0041DeleteJobsJSONBodyJobState = "POWER_UP_NODE"
	SlurmV0041DeleteJobsJSONBodyJobStatePREEMPTED    SlurmV0041DeleteJobsJSONBodyJobState = "PREEMPTED"
	SlurmV0041DeleteJobsJSONBodyJobStateRECONFIGFAIL SlurmV0041DeleteJobsJSONBodyJobState = "RECONFIG_FAIL"
	SlurmV0041DeleteJobsJSONBodyJobStateREQUEUED     SlurmV0041DeleteJobsJSONBodyJobState = "REQUEUED"
	SlurmV0041DeleteJobsJSONBodyJobStateREQUEUEFED   SlurmV0041DeleteJobsJSONBodyJobState = "REQUEUE_FED"
	SlurmV0041DeleteJobsJSONBodyJobStateREQUEUEHOLD  SlurmV0041DeleteJobsJSONBodyJobState = "REQUEUE_HOLD"
	SlurmV0041DeleteJobsJSONBodyJobStateRESIZING     SlurmV0041DeleteJobsJSONBodyJobState = "RESIZING"
	SlurmV0041DeleteJobsJSONBodyJobStateRESVDELHOLD  SlurmV0041DeleteJobsJSONBodyJobState = "RESV_DEL_HOLD"
	SlurmV0041DeleteJobsJSONBodyJobStateREVOKED      SlurmV0041DeleteJobsJSONBodyJobState = "REVOKED"
	SlurmV0041DeleteJobsJSONBodyJobStateRUNNING      SlurmV0041DeleteJobsJSONBodyJobState = "RUNNING"
	SlurmV0041DeleteJobsJSONBodyJobStateSIGNALING    SlurmV0041DeleteJobsJSONBodyJobState = "SIGNALING"
	SlurmV0041DeleteJobsJSONBodyJobStateSPECIALEXIT  SlurmV0041DeleteJobsJSONBodyJobState = "SPECIAL_EXIT"
	SlurmV0041DeleteJobsJSONBodyJobStateSTAGEOUT     SlurmV0041DeleteJobsJSONBodyJobState = "STAGE_OUT"
	SlurmV0041DeleteJobsJSONBodyJobStateSTOPPED      SlurmV0041DeleteJobsJSONBodyJobState = "STOPPED"
	SlurmV0041DeleteJobsJSONBodyJobStateSUSPENDED    SlurmV0041DeleteJobsJSONBodyJobState = "SUSPENDED"
	SlurmV0041DeleteJobsJSONBodyJobStateTIMEOUT      SlurmV0041DeleteJobsJSONBodyJobState = "TIMEOUT"
)

// Defines values for SlurmV0041GetJobsParamsFlags.
const (
	SlurmV0041GetJobsParamsFlagsALL        SlurmV0041GetJobsParamsFlags = "ALL"
	SlurmV0041GetJobsParamsFlagsDETAIL     SlurmV0041GetJobsParamsFlags = "DETAIL"
	SlurmV0041GetJobsParamsFlagsFEDERATION SlurmV0041GetJobsParamsFlags = "FEDERATION"
	SlurmV0041GetJobsParamsFlagsFUTURE     SlurmV0041GetJobsParamsFlags = "FUTURE"
	SlurmV0041GetJobsParamsFlagsLOCAL      SlurmV0041GetJobsParamsFlags = "LOCAL"
	SlurmV0041GetJobsParamsFlagsMIXED      SlurmV0041GetJobsParamsFlags = "MIXED"
	SlurmV0041GetJobsParamsFlagsSIBLING    SlurmV0041GetJobsParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetNodeParamsFlags.
const (
	SlurmV0041GetNodeParamsFlagsALL        SlurmV0041GetNodeParamsFlags = "ALL"
	SlurmV0041GetNodeParamsFlagsDETAIL     SlurmV0041GetNodeParamsFlags = "DETAIL"
	SlurmV0041GetNodeParamsFlagsFEDERATION SlurmV0041GetNodeParamsFlags = "FEDERATION"
	SlurmV0041GetNodeParamsFlagsFUTURE     SlurmV0041GetNodeParamsFlags = "FUTURE"
	SlurmV0041GetNodeParamsFlagsLOCAL      SlurmV0041GetNodeParamsFlags = "LOCAL"
	SlurmV0041GetNodeParamsFlagsMIXED      SlurmV0041GetNodeParamsFlags = "MIXED"
	SlurmV0041GetNodeParamsFlagsSIBLING    SlurmV0041GetNodeParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetNodesParamsFlags.
const (
	SlurmV0041GetNodesParamsFlagsALL        SlurmV0041GetNodesParamsFlags = "ALL"
	SlurmV0041GetNodesParamsFlagsDETAIL     SlurmV0041GetNodesParamsFlags = "DETAIL"
	SlurmV0041GetNodesParamsFlagsFEDERATION SlurmV0041GetNodesParamsFlags = "FEDERATION"
	SlurmV0041GetNodesParamsFlagsFUTURE     SlurmV0041GetNodesParamsFlags = "FUTURE"
	SlurmV0041GetNodesParamsFlagsLOCAL      SlurmV0041GetNodesParamsFlags = "LOCAL"
	SlurmV0041GetNodesParamsFlagsMIXED      SlurmV0041GetNodesParamsFlags = "MIXED"
	SlurmV0041GetNodesParamsFlagsSIBLING    SlurmV0041GetNodesParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetPartitionParamsFlags.
const (
	SlurmV0041GetPartitionParamsFlagsALL        SlurmV0041GetPartitionParamsFlags = "ALL"
	SlurmV0041GetPartitionParamsFlagsDETAIL     SlurmV0041GetPartitionParamsFlags = "DETAIL"
	SlurmV0041GetPartitionParamsFlagsFEDERATION SlurmV0041GetPartitionParamsFlags = "FEDERATION"
	SlurmV0041GetPartitionParamsFlagsFUTURE     SlurmV0041GetPartitionParamsFlags = "FUTURE"
	SlurmV0041GetPartitionParamsFlagsLOCAL      SlurmV0041GetPartitionParamsFlags = "LOCAL"
	SlurmV0041GetPartitionParamsFlagsMIXED      SlurmV0041GetPartitionParamsFlags = "MIXED"
	SlurmV0041GetPartitionParamsFlagsSIBLING    SlurmV0041GetPartitionParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetPartitionsParamsFlags.
const (
	SlurmV0041GetPartitionsParamsFlagsALL        SlurmV0041GetPartitionsParamsFlags = "ALL"
	SlurmV0041GetPartitionsParamsFlagsDETAIL     SlurmV0041GetPartitionsParamsFlags = "DETAIL"
	SlurmV0041GetPartitionsParamsFlagsFEDERATION SlurmV0041GetPartitionsParamsFlags = "FEDERATION"
	SlurmV0041GetPartitionsParamsFlagsFUTURE     SlurmV0041GetPartitionsParamsFlags = "FUTURE"
	SlurmV0041GetPartitionsParamsFlagsLOCAL      SlurmV0041GetPartitionsParamsFlags = "LOCAL"
	SlurmV0041GetPartitionsParamsFlagsMIXED      SlurmV0041GetPartitionsParamsFlags = "MIXED"
	SlurmV0041GetPartitionsParamsFlagsSIBLING    SlurmV0041GetPartitionsParamsFlags = "SIBLING"
)

// Defines values for SlurmdbV0041DeleteClusterParamsClassification.
const (
	SlurmdbV0041DeleteClusterParamsClassificationCAPABILITY                          SlurmdbV0041DeleteClusterParamsClassification = "CAPABILITY"
	SlurmdbV0041DeleteClusterParamsClassificationCAPACITY                            SlurmdbV0041DeleteClusterParamsClassification = "CAPACITY"
	SlurmdbV0041DeleteClusterParamsClassificationCAPAPACITYBothCAPABILITYAndCAPACITY SlurmdbV0041DeleteClusterParamsClassification = "CAPAPACITY (both CAPABILITY and CAPACITY)"
	SlurmdbV0041DeleteClusterParamsClassificationUNCLASSIFIED                        SlurmdbV0041DeleteClusterParamsClassification = "UNCLASSIFIED"
)

// Defines values for SlurmdbV0041DeleteClusterParamsFlags.
const (
	SlurmdbV0041DeleteClusterParamsFlagsEXTERNAL       SlurmdbV0041DeleteClusterParamsFlags = "EXTERNAL"
	SlurmdbV0041DeleteClusterParamsFlagsFEDERATION     SlurmdbV0041DeleteClusterParamsFlags = "FEDERATION"
	SlurmdbV0041DeleteClusterParamsFlagsMULTIPLESLURMD SlurmdbV0041DeleteClusterParamsFlags = "MULTIPLE_SLURMD"
	SlurmdbV0041DeleteClusterParamsFlagsREGISTERING    SlurmdbV0041DeleteClusterParamsFlags = "REGISTERING"
)

// Defines values for SlurmdbV0041GetClusterParamsClassification.
const (
	SlurmdbV0041GetClusterParamsClassificationCAPABILITY                          SlurmdbV0041GetClusterParamsClassification = "CAPABILITY"
	SlurmdbV0041GetClusterParamsClassificationCAPACITY                            SlurmdbV0041GetClusterParamsClassification = "CAPACITY"
	SlurmdbV0041GetClusterParamsClassificationCAPAPACITYBothCAPABILITYAndCAPACITY SlurmdbV0041GetClusterParamsClassification = "CAPAPACITY (both CAPABILITY and CAPACITY)"
	SlurmdbV0041GetClusterParamsClassificationUNCLASSIFIED                        SlurmdbV0041GetClusterParamsClassification = "UNCLASSIFIED"
)

// Defines values for SlurmdbV0041GetClusterParamsFlags.
const (
	SlurmdbV0041GetClusterParamsFlagsEXTERNAL       SlurmdbV0041GetClusterParamsFlags = "EXTERNAL"
	SlurmdbV0041GetClusterParamsFlagsFEDERATION     SlurmdbV0041GetClusterParamsFlags = "FEDERATION"
	SlurmdbV0041GetClusterParamsFlagsMULTIPLESLURMD SlurmdbV0041GetClusterParamsFlags = "MULTIPLE_SLURMD"
	SlurmdbV0041GetClusterParamsFlagsREGISTERING    SlurmdbV0041GetClusterParamsFlags = "REGISTERING"
)

// Defines values for SlurmdbV0041GetQosParamsPreemptMode.
const (
	SlurmdbV0041GetQosParamsPreemptModeCANCEL   SlurmdbV0041GetQosParamsPreemptMode = "CANCEL"
	SlurmdbV0041GetQosParamsPreemptModeDISABLED SlurmdbV0041GetQosParamsPreemptMode = "DISABLED"
	SlurmdbV0041GetQosParamsPreemptModeGANG     SlurmdbV0041GetQosParamsPreemptMode = "GANG"
	SlurmdbV0041GetQosParamsPreemptModeREQUEUE  SlurmdbV0041GetQosParamsPreemptMode = "REQUEUE"
	SlurmdbV0041GetQosParamsPreemptModeSUSPEND  SlurmdbV0041GetQosParamsPreemptMode = "SUSPEND"
)

// Defines values for SlurmdbV0041PostQosParamsPreemptMode.
const (
	SlurmdbV0041PostQosParamsPreemptModeCANCEL   SlurmdbV0041PostQosParamsPreemptMode = "CANCEL"
	SlurmdbV0041PostQosParamsPreemptModeDISABLED SlurmdbV0041PostQosParamsPreemptMode = "DISABLED"
	SlurmdbV0041PostQosParamsPreemptModeGANG     SlurmdbV0041PostQosParamsPreemptMode = "GANG"
	SlurmdbV0041PostQosParamsPreemptModeREQUEUE  SlurmdbV0041PostQosParamsPreemptMode = "REQUEUE"
	SlurmdbV0041PostQosParamsPreemptModeSUSPEND  SlurmdbV0041PostQosParamsPreemptMode = "SUSPEND"
)

// Defines values for SlurmdbV0041GetUsersParamsAdminLevel.
const (
	SlurmdbV0041GetUsersParamsAdminLevelAdministrator SlurmdbV0041GetUsersParamsAdminLevel = "Administrator"
	SlurmdbV0041GetUsersParamsAdminLevelNone          SlurmdbV0041GetUsersParamsAdminLevel = "None"
	SlurmdbV0041GetUsersParamsAdminLevelNotSet        SlurmdbV0041GetUsersParamsAdminLevel = "Not Set"
	SlurmdbV0041GetUsersParamsAdminLevelOperator      SlurmdbV0041GetUsersParamsAdminLevel = "Operator"
)

// Defines values for SlurmdbV0041PostUsersAssociationParamsFlags.
const (
	SlurmdbV0041PostUsersAssociationParamsFlagsALL        SlurmdbV0041PostUsersAssociationParamsFlags = "ALL"
	SlurmdbV0041PostUsersAssociationParamsFlagsDETAIL     SlurmdbV0041PostUsersAssociationParamsFlags = "DETAIL"
	SlurmdbV0041PostUsersAssociationParamsFlagsFEDERATION SlurmdbV0041PostUsersAssociationParamsFlags = "FEDERATION"
	SlurmdbV0041PostUsersAssociationParamsFlagsFUTURE     SlurmdbV0041PostUsersAssociationParamsFlags = "FUTURE"
	SlurmdbV0041PostUsersAssociationParamsFlagsLOCAL      SlurmdbV0041PostUsersAssociationParamsFlags = "LOCAL"
	SlurmdbV0041PostUsersAssociationParamsFlagsMIXED      SlurmdbV0041PostUsersAssociationParamsFlags = "MIXED"
	SlurmdbV0041PostUsersAssociationParamsFlagsSIBLING    SlurmdbV0041PostUsersAssociationParamsFlags = "SIBLING"
)

// Defines values for SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel.
const (
	SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevelAdministrator SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel = "Administrator"
	SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevelNone          SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel = "None"
	SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevelNotSet        SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel = "Not Set"
	SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevelOperator      SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel = "Operator"
)

// V0041OpenapiAccountsResp defines model for v0.0.41_openapi_accounts_resp.
type V0041OpenapiAccountsResp struct {
	// Accounts accounts
	Accounts []struct {
		// Associations Associations involving this account (only populated if requested)
		Associations *[]struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"associations,omitempty"`

		// Coordinators List of users that are a coordinator of this account (only populated if requested)
		Coordinators *[]struct {
			// Direct Indicates whether the coordinator was directly assigned to this account
			Direct *bool `json:"direct,omitempty"`

			// Name User name
			Name string `json:"name"`
		} `json:"coordinators,omitempty"`

		// Description Arbitrary string describing the account
		Description string `json:"description"`

		// Flags Flags associated with the account
		Flags *[]V0041OpenapiAccountsRespAccountsFlags `json:"flags,omitempty"`

		// Name Account name
		Name string `json:"name"`

		// Organization Organization to which the account belongs
		Organization string `json:"organization"`
	} `json:"accounts"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiAccountsRespAccountsFlags defines model for V0041OpenapiAccountsResp.Accounts.Flags.
type V0041OpenapiAccountsRespAccountsFlags string

// V0041OpenapiAssocsRemovedResp defines model for v0.0.41_openapi_assocs_removed_resp.
type V0041OpenapiAssocsRemovedResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// RemovedAssociations removed_associations
	RemovedAssociations []string `json:"removed_associations"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiAssocsResp defines model for v0.0.41_openapi_assocs_resp.
type V0041OpenapiAssocsResp struct {
	// Associations associations
	Associations []struct {
		// Account Account
		Account *string `json:"account,omitempty"`

		// Accounting Accounting records containing related resource usage
		Accounting *[]struct {
			// TRES Trackable resources
			TRES *struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"TRES,omitempty"`
			Allocated *struct {
				// Seconds Number of cpu seconds allocated
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"allocated,omitempty"`

			// Id Association ID or Workload characterization key ID
			Id *int32 `json:"id,omitempty"`

			// Start When the record was started
			Start *int64 `json:"start,omitempty"`
		} `json:"accounting,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Comment Arbitrary comment
		Comment *string `json:"comment,omitempty"`
		Default *struct {
			// Qos Default QOS
			Qos *string `json:"qos,omitempty"`
		} `json:"default,omitempty"`

		// Flags Flags on the association
		Flags *[]V0041OpenapiAssocsRespAssociationsFlags `json:"flags,omitempty"`

		// Id Unique ID
		Id *int32 `json:"id,omitempty"`

		// IsDefault Is default association for user
		IsDefault *bool `json:"is_default,omitempty"`

		// Lineage Complete path up the hierarchy to the root association
		Lineage *string `json:"lineage,omitempty"`
		Max     *struct {
			Jobs *struct {
				// Accruing MaxJobsAccrue
				Accruing *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"accruing,omitempty"`

				// Active MaxJobs
				Active *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"active,omitempty"`
				Per *struct {
					// Accruing GrpJobsAccrue
					Accruing *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"accruing,omitempty"`

					// Count GrpJobs
					Count *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"count,omitempty"`

					// Submitted GrpSubmitJobs
					Submitted *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"submitted,omitempty"`

					// WallClock MaxWallDurationPerJob
					WallClock *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"wall_clock,omitempty"`
				} `json:"per,omitempty"`

				// Total MaxSubmitJobs
				Total *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"total,omitempty"`
			} `json:"jobs,omitempty"`
			Per *struct {
				Account *struct {
					// WallClock GrpWall
					WallClock *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"wall_clock,omitempty"`
				} `json:"account,omitempty"`
			} `json:"per,omitempty"`
			Tres *struct {
				Group *struct {
					// Active GrpTRESRunMins
					Active *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"active,omitempty"`

					// Minutes GrpTRESMins
					Minutes *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"minutes,omitempty"`
				} `json:"group,omitempty"`
				Minutes *struct {
					Per *struct {
						// Job MaxTRESMinsPerJob
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`
					} `json:"per,omitempty"`

					// Total MaxTRESMinsPerJob
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"minutes,omitempty"`
				Per *struct {
					// Job MaxTRESPerJob
					Job *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"job,omitempty"`

					// Node MaxTRESPerNode
					Node *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"node,omitempty"`
				} `json:"per,omitempty"`

				// Total GrpTRES
				Total *[]struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"total,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"max,omitempty"`
		Min *struct {
			// PriorityThreshold MinPrioThreshold
			PriorityThreshold *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority_threshold,omitempty"`
		} `json:"min,omitempty"`

		// ParentAccount Name of parent account
		ParentAccount *string `json:"parent_account,omitempty"`

		// Partition Partition name
		Partition *string `json:"partition,omitempty"`

		// Priority Association priority factor
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Qos List of available QOS names
		Qos *[]string `json:"qos,omitempty"`

		// SharesRaw Allocated shares used for fairshare calculation
		SharesRaw *int32 `json:"shares_raw,omitempty"`

		// User User name
		User string `json:"user"`
	} `json:"associations"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiAssocsRespAssociationsFlags defines model for V0041OpenapiAssocsResp.Associations.Flags.
type V0041OpenapiAssocsRespAssociationsFlags string

// V0041OpenapiClustersResp defines model for v0.0.41_openapi_clusters_resp.
type V0041OpenapiClustersResp struct {
	// Clusters clusters
	Clusters []struct {
		Associations *struct {
			// Root Root association information
			Root *struct {
				// Account Account
				Account *string `json:"account,omitempty"`

				// Cluster Cluster
				Cluster *string `json:"cluster,omitempty"`

				// Id Numeric association ID
				Id *int32 `json:"id,omitempty"`

				// Partition Partition
				Partition *string `json:"partition,omitempty"`

				// User User name
				User string `json:"user"`
			} `json:"root,omitempty"`
		} `json:"associations,omitempty"`
		Controller *struct {
			// Host ControlHost
			Host *string `json:"host,omitempty"`

			// Port ControlPort
			Port *int32 `json:"port,omitempty"`
		} `json:"controller,omitempty"`

		// Flags Flags
		Flags *[]V0041OpenapiClustersRespClustersFlags `json:"flags,omitempty"`

		// Name ClusterName
		Name *string `json:"name,omitempty"`

		// Nodes Node names
		Nodes *string `json:"nodes,omitempty"`

		// RpcVersion RPC version used in the cluster
		RpcVersion *int32 `json:"rpc_version,omitempty"`
		// Deprecated:
		SelectPlugin *string `json:"select_plugin,omitempty"`

		// Tres Trackable resources
		Tres *[]struct {
			// Count TRES count (0 if listed generically)
			Count *int64 `json:"count,omitempty"`

			// Id ID used in database
			Id *int32 `json:"id,omitempty"`

			// Name TRES name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type TRES type (CPU, MEM, etc)
			Type string `json:"type"`
		} `json:"tres,omitempty"`
	} `json:"clusters"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiClustersRespClustersFlags defines model for V0041OpenapiClustersResp.Clusters.Flags.
type V0041OpenapiClustersRespClustersFlags string

// V0041OpenapiInstancesResp defines model for v0.0.41_openapi_instances_resp.
type V0041OpenapiInstancesResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Instances instances
	Instances []struct {
		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// InstanceId Cloud instance ID
		InstanceId *string `json:"instance_id,omitempty"`

		// InstanceType Cloud instance type
		InstanceType *string `json:"instance_type,omitempty"`

		// NodeName NodeName
		NodeName *string `json:"node_name,omitempty"`
		Time     *struct {
			// TimeEnd When the instance will end (UNIX timestamp)
			TimeEnd *int64 `json:"time_end,omitempty"`

			// TimeStart When the instance will start (UNIX timestamp)
			TimeStart *int64 `json:"time_start,omitempty"`
		} `json:"time,omitempty"`
	} `json:"instances"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiJobInfoResp defines model for v0.0.41_openapi_job_info_resp.
type V0041OpenapiJobInfoResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Jobs List of jobs
	Jobs []struct {
		// Account Account associated with the job
		Account *string `json:"account,omitempty"`

		// AccrueTime When the job started accruing age priority (UNIX timestamp)
		AccrueTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"accrue_time,omitempty"`

		// AdminComment Arbitrary comment made by administrator
		AdminComment *string `json:"admin_comment,omitempty"`

		// AllocatingNode Local node making the resource allocation
		AllocatingNode *string `json:"allocating_node,omitempty"`

		// ArrayJobId Job ID of job array, or 0 if N/A
		ArrayJobId *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"array_job_id,omitempty"`

		// ArrayMaxTasks Maximum number of simultaneously running array tasks, 0 if no limit
		ArrayMaxTasks *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"array_max_tasks,omitempty"`

		// ArrayTaskId Task ID of this task in job array
		ArrayTaskId *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"array_task_id,omitempty"`

		// ArrayTaskString String expression of task IDs in this record
		ArrayTaskString *string `json:"array_task_string,omitempty"`

		// AssociationId Unique identifier for the association
		AssociationId *int32 `json:"association_id,omitempty"`

		// BatchFeatures Features required for batch script's node
		BatchFeatures *string `json:"batch_features,omitempty"`

		// BatchFlag True if batch job
		BatchFlag *bool `json:"batch_flag,omitempty"`

		// BatchHost Name of host running batch script
		BatchHost *string `json:"batch_host,omitempty"`

		// BillableTres Billable TRES
		BillableTres *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"billable_tres,omitempty"`

		// BurstBuffer Burst buffer specifications
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// BurstBufferState Burst buffer state details
		BurstBufferState *string `json:"burst_buffer_state,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// ClusterFeatures List of required cluster features
		ClusterFeatures *string `json:"cluster_features,omitempty"`

		// Command Executed command
		Command *string `json:"command,omitempty"`

		// Comment Arbitrary comment
		Comment *string `json:"comment,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// ContainerId OCI container ID
		ContainerId *string `json:"container_id,omitempty"`

		// Contiguous True if job requires contiguous nodes
		Contiguous *bool `json:"contiguous,omitempty"`

		// CoreSpec Specialized core count
		CoreSpec *int32 `json:"core_spec,omitempty"`

		// CoresPerSocket Cores per socket required
		CoresPerSocket *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cores_per_socket,omitempty"`

		// CpuFrequencyGovernor CPU frequency governor
		CpuFrequencyGovernor *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpu_frequency_governor,omitempty"`

		// CpuFrequencyMaximum Maximum CPU frequency
		CpuFrequencyMaximum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpu_frequency_maximum,omitempty"`

		// CpuFrequencyMinimum Minimum CPU frequency
		CpuFrequencyMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpu_frequency_minimum,omitempty"`

		// Cpus Minimum number of CPUs required
		Cpus *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpus,omitempty"`

		// CpusPerTask Number of CPUs required by each task
		CpusPerTask *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpus_per_task,omitempty"`

		// CpusPerTres Semicolon delimited list of TRES=# values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
		CpusPerTres *string `json:"cpus_per_tres,omitempty"`

		// Cron Time specification for scrontab job
		Cron *string `json:"cron,omitempty"`

		// CurrentWorkingDirectory Working directory to use for the job
		CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

		// Deadline Latest time that the job may start (UNIX timestamp)
		Deadline *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"deadline,omitempty"`

		// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
		DelayBoot *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"delay_boot,omitempty"`

		// Dependency Other jobs that must meet certain criteria before this job can start
		Dependency *string `json:"dependency,omitempty"`

		// DerivedExitCode Highest exit code of all job steps
		DerivedExitCode *struct {
			// ReturnCode Process return code (numeric)
			ReturnCode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"return_code,omitempty"`
			Signal *struct {
				// Id Signal sent to process (numeric)
				Id *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"id,omitempty"`

				// Name Signal sent to process
				Name *string `json:"name,omitempty"`
			} `json:"signal,omitempty"`

			// Status Status given by return code
			Status *[]V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus `json:"status,omitempty"`
		} `json:"derived_exit_code,omitempty"`

		// EligibleTime Time when the job became eligible to run (UNIX timestamp)
		EligibleTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"eligible_time,omitempty"`

		// EndTime End time, real or expected (UNIX timestamp)
		EndTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"end_time,omitempty"`

		// ExcludedNodes Comma separated list of nodes that may not be used
		ExcludedNodes *string `json:"excluded_nodes,omitempty"`
		// Deprecated:
		Exclusive *[]V0041OpenapiJobInfoRespJobsExclusive `json:"exclusive,omitempty"`

		// ExitCode Exit code of the job
		ExitCode *struct {
			// ReturnCode Process return code (numeric)
			ReturnCode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"return_code,omitempty"`
			Signal *struct {
				// Id Signal sent to process (numeric)
				Id *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"id,omitempty"`

				// Name Signal sent to process
				Name *string `json:"name,omitempty"`
			} `json:"signal,omitempty"`

			// Status Status given by return code
			Status *[]V0041OpenapiJobInfoRespJobsExitCodeStatus `json:"status,omitempty"`
		} `json:"exit_code,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// FailedNode Name of node that caused job failure
		FailedNode *string `json:"failed_node,omitempty"`

		// Features Comma separated list of features that are required
		Features *string `json:"features,omitempty"`

		// FederationOrigin Origin cluster's name (when using federation)
		FederationOrigin *string `json:"federation_origin,omitempty"`

		// FederationSiblingsActive Active sibling job names
		FederationSiblingsActive *string `json:"federation_siblings_active,omitempty"`

		// FederationSiblingsViable Viable sibling job names
		FederationSiblingsViable *string `json:"federation_siblings_viable,omitempty"`

		// Flags Job flags
		Flags *[]V0041OpenapiJobInfoRespJobsFlags `json:"flags,omitempty"`

		// GresDetail List of GRES index and counts allocated per node
		GresDetail *[]string `json:"gres_detail,omitempty"`

		// GroupId Group ID of the user that owns the job
		GroupId *int32 `json:"group_id,omitempty"`

		// GroupName Group name of the user that owns the job
		GroupName *string `json:"group_name,omitempty"`

		// HetJobId Heterogeneous job ID, if applicable
		HetJobId *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"het_job_id,omitempty"`

		// HetJobIdSet Job ID range for all heterogeneous job components
		HetJobIdSet *string `json:"het_job_id_set,omitempty"`

		// HetJobOffset Unique sequence number applied to this component of the heterogeneous job
		HetJobOffset *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"het_job_offset,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// JobResources Resources used by the job
		JobResources *struct {
			// Cpus Number of allocated CPUs
			Cpus  int32 `json:"cpus"`
			Nodes *struct {
				// Allocation Allocated node resources
				Allocation *[]struct {
					Cpus *struct {
						// Count Total number of CPUs assigned to job
						Count *int32 `json:"count,omitempty"`

						// Used Total number of CPUs used by job
						Used *int32 `json:"used,omitempty"`
					} `json:"cpus,omitempty"`

					// Index Node index
					Index  int32 `json:"index"`
					Memory *struct {
						// Allocated Total memory (MiB) allocated to job
						Allocated *int64 `json:"allocated,omitempty"`

						// Used Total memory (MiB) used by job
						Used *int64 `json:"used,omitempty"`
					} `json:"memory,omitempty"`

					// Name Node name
					Name string `json:"name"`

					// Sockets Socket allocations in node
					Sockets []struct {
						// Cores Core in socket
						Cores []struct {
							// Index Core index
							Index int32 `json:"index"`

							// Status Core status
							Status []V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus `json:"status"`
						} `json:"cores"`

						// Index Core index
						Index int32 `json:"index"`
					} `json:"sockets"`
				} `json:"allocation,omitempty"`

				// Count Number of allocated nodes
				Count *int32 `json:"count,omitempty"`

				// List Node(s) allocated to the job
				List *string `json:"list,omitempty"`

				// SelectType Node scheduling selection method
				SelectType *[]V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType `json:"select_type,omitempty"`

				// Whole Whether whole nodes were allocated
				Whole *bool `json:"whole,omitempty"`
			} `json:"nodes,omitempty"`

			// SelectType Scheduler consumable resource selection type
			SelectType []V0041OpenapiJobInfoRespJobsJobResourcesSelectType `json:"select_type"`

			// ThreadsPerCore Number of processor threads per CPU core
			ThreadsPerCore struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"threads_per_core"`
		} `json:"job_resources,omitempty"`

		// JobSizeStr Number of nodes (in a range) required for this job
		JobSizeStr *[]string `json:"job_size_str,omitempty"`

		// JobState Current state
		JobState *[]V0041OpenapiJobInfoRespJobsJobState `json:"job_state,omitempty"`

		// LastSchedEvaluation Last time job was evaluated for scheduling (UNIX timestamp)
		LastSchedEvaluation *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"last_sched_evaluation,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`

		// MailType Mail event type(s)
		MailType *[]V0041OpenapiJobInfoRespJobsMailType `json:"mail_type,omitempty"`

		// MailUser User to receive email notifications
		MailUser *string `json:"mail_user,omitempty"`

		// MaxCpus Maximum number of CPUs usable by the job
		MaxCpus *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"max_cpus,omitempty"`

		// MaxNodes Maximum number of nodes usable by the job
		MaxNodes *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"max_nodes,omitempty"`

		// MaximumSwitchWaitTime Maximum time to wait for switches in seconds
		MaximumSwitchWaitTime *int32 `json:"maximum_switch_wait_time,omitempty"`

		// McsLabel Multi-Category Security label on the job
		McsLabel *string `json:"mcs_label,omitempty"`

		// MemoryPerCpu Minimum memory in megabytes per allocated CPU
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Minimum memory in megabytes per allocated node
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`

		// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
		MemoryPerTres *string `json:"memory_per_tres,omitempty"`

		// MinimumCpusPerNode Minimum number of CPUs per node
		MinimumCpusPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"minimum_cpus_per_node,omitempty"`

		// MinimumSwitches Maximum number of switches (the 'minimum' in the key is incorrect)
		MinimumSwitches *int32 `json:"minimum_switches,omitempty"`

		// MinimumTmpDiskPerNode Minimum tmp disk space required per node
		MinimumTmpDiskPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"minimum_tmp_disk_per_node,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Network Network specs for the job
		Network *string `json:"network,omitempty"`

		// Nice Requested job priority change
		Nice *int32 `json:"nice,omitempty"`

		// NodeCount Minimum number of nodes required
		NodeCount *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"node_count,omitempty"`

		// Nodes Node(s) allocated to the job
		Nodes *string `json:"nodes,omitempty"`
		// Deprecated:
		Oversubscribe *bool `json:"oversubscribe,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`
		Power     *struct {
			// Deprecated:
			Flags *[]interface{} `json:"flags,omitempty"`
		} `json:"power,omitempty"`

		// PreSusTime Total run time prior to last suspend in seconds
		PreSusTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"pre_sus_time,omitempty"`

		// PreemptTime Time job received preemption signal (UNIX timestamp)
		PreemptTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"preempt_time,omitempty"`

		// PreemptableTime Time job becomes eligible for preemption (UNIX timestamp)
		PreemptableTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"preemptable_time,omitempty"`

		// Prefer Feature(s) the job requested but that are not required
		Prefer *string `json:"prefer,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Profile Profile used by the acct_gather_profile plugin
		Profile *[]V0041OpenapiJobInfoRespJobsProfile `json:"profile,omitempty"`

		// Qos Quality of Service assigned to the job, if pending the QOS requested
		Qos *string `json:"qos,omitempty"`

		// Reboot Node reboot requested before start
		Reboot *bool `json:"reboot,omitempty"`

		// Requeue Determines whether the job may be requeued
		Requeue *bool `json:"requeue,omitempty"`

		// RequiredNodes Comma separated list of required nodes
		RequiredNodes *string `json:"required_nodes,omitempty"`

		// ResizeTime Time of last size change (UNIX timestamp)
		ResizeTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"resize_time,omitempty"`

		// RestartCnt Number of job restarts
		RestartCnt *int32 `json:"restart_cnt,omitempty"`

		// ResvName Name of reservation to use
		ResvName *string `json:"resv_name,omitempty"`

		// ScheduledNodes List of nodes scheduled to be used for the job
		ScheduledNodes *string `json:"scheduled_nodes,omitempty"`

		// SelinuxContext SELinux context
		SelinuxContext *string `json:"selinux_context,omitempty"`

		// Shared How the job can share resources with other jobs, if at all
		Shared *[]V0041OpenapiJobInfoRespJobsShared `json:"shared,omitempty"`
		// Deprecated:
		ShowFlags *[]V0041OpenapiJobInfoRespJobsShowFlags `json:"show_flags,omitempty"`

		// SocketsPerBoard Number of sockets per board required
		SocketsPerBoard *int32 `json:"sockets_per_board,omitempty"`

		// SocketsPerNode Number of sockets per node required
		SocketsPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"sockets_per_node,omitempty"`

		// StandardError Path to stderr file
		StandardError *string `json:"standard_error,omitempty"`

		// StandardInput Path to stdin file
		StandardInput *string `json:"standard_input,omitempty"`

		// StandardOutput Path to stdout file
		StandardOutput *string `json:"standard_output,omitempty"`

		// StartTime Time execution began, or is expected to begin (UNIX timestamp)
		StartTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"start_time,omitempty"`

		// StateDescription Optional details for state_reason
		StateDescription *string `json:"state_description,omitempty"`

		// StateReason Reason for current Pending or Failed state
		StateReason *string `json:"state_reason,omitempty"`

		// SubmitTime Time when the job was submitted (UNIX timestamp)
		SubmitTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"submit_time,omitempty"`

		// SuspendTime Time the job was last suspended or resumed (UNIX timestamp)
		SuspendTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"suspend_time,omitempty"`

		// SystemComment Arbitrary comment from slurmctld
		SystemComment *string `json:"system_comment,omitempty"`

		// Tasks Number of tasks
		Tasks *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks,omitempty"`

		// TasksPerBoard Number of tasks invoked on each board
		TasksPerBoard *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_board,omitempty"`

		// TasksPerCore Number of tasks invoked on each core
		TasksPerCore *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_core,omitempty"`

		// TasksPerNode Number of tasks invoked on each node
		TasksPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_node,omitempty"`

		// TasksPerSocket Number of tasks invoked on each socket
		TasksPerSocket *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_socket,omitempty"`

		// TasksPerTres Number of tasks that can assess each GPU
		TasksPerTres *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_tres,omitempty"`

		// ThreadSpec Specialized thread count
		ThreadSpec *int32 `json:"thread_spec,omitempty"`

		// ThreadsPerCore Number of processor threads per CPU core required
		ThreadsPerCore *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"threads_per_core,omitempty"`

		// TimeLimit Maximum run time in minutes
		TimeLimit *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Minimum run time in minutes
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`

		// TresAllocStr TRES used by the job
		TresAllocStr *string `json:"tres_alloc_str,omitempty"`

		// TresBind Task to TRES binding directives
		TresBind *string `json:"tres_bind,omitempty"`

		// TresFreq TRES frequency directives
		TresFreq *string `json:"tres_freq,omitempty"`

		// TresPerJob Comma separated list of TRES=# values to be allocated per job
		TresPerJob *string `json:"tres_per_job,omitempty"`

		// TresPerNode Comma separated list of TRES=# values to be allocated per node
		TresPerNode *string `json:"tres_per_node,omitempty"`

		// TresPerSocket Comma separated list of TRES=# values to be allocated per socket
		TresPerSocket *string `json:"tres_per_socket,omitempty"`

		// TresPerTask Comma separated list of TRES=# values to be allocated per task
		TresPerTask *string `json:"tres_per_task,omitempty"`

		// TresReqStr TRES requested by the job
		TresReqStr *string `json:"tres_req_str,omitempty"`

		// UserId User ID that owns the job
		UserId *int32 `json:"user_id,omitempty"`

		// UserName User name that owns the job
		UserName *string `json:"user_name,omitempty"`

		// Wckey Workload characterization key
		Wckey *string `json:"wckey,omitempty"`
	} `json:"jobs"`

	// LastBackfill Time of last backfill scheduler run (UNIX timestamp)
	LastBackfill struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_backfill"`

	// LastUpdate Time of last job change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus defines model for V0041OpenapiJobInfoResp.Jobs.DerivedExitCode.Status.
type V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus string

// V0041OpenapiJobInfoRespJobsExclusive defines model for V0041OpenapiJobInfoResp.Jobs.Exclusive.
type V0041OpenapiJobInfoRespJobsExclusive string

// V0041OpenapiJobInfoRespJobsExitCodeStatus defines model for V0041OpenapiJobInfoResp.Jobs.ExitCode.Status.
type V0041OpenapiJobInfoRespJobsExitCodeStatus string

// V0041OpenapiJobInfoRespJobsFlags defines model for V0041OpenapiJobInfoResp.Jobs.Flags.
type V0041OpenapiJobInfoRespJobsFlags string

// V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus defines model for V0041OpenapiJobInfoResp.Jobs.JobResources.Nodes.Allocation.Sockets.Cores.Status.
type V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus string

// V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType defines model for V0041OpenapiJobInfoResp.Jobs.JobResources.Nodes.SelectType.
type V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType string

// V0041OpenapiJobInfoRespJobsJobResourcesSelectType defines model for V0041OpenapiJobInfoResp.Jobs.JobResources.SelectType.
type V0041OpenapiJobInfoRespJobsJobResourcesSelectType string

// V0041OpenapiJobInfoRespJobsJobState defines model for V0041OpenapiJobInfoResp.Jobs.JobState.
type V0041OpenapiJobInfoRespJobsJobState string

// V0041OpenapiJobInfoRespJobsMailType defines model for V0041OpenapiJobInfoResp.Jobs.MailType.
type V0041OpenapiJobInfoRespJobsMailType string

// V0041OpenapiJobInfoRespJobsProfile defines model for V0041OpenapiJobInfoResp.Jobs.Profile.
type V0041OpenapiJobInfoRespJobsProfile string

// V0041OpenapiJobInfoRespJobsShared defines model for V0041OpenapiJobInfoResp.Jobs.Shared.
type V0041OpenapiJobInfoRespJobsShared string

// V0041OpenapiJobInfoRespJobsShowFlags defines model for V0041OpenapiJobInfoResp.Jobs.ShowFlags.
type V0041OpenapiJobInfoRespJobsShowFlags string

// V0041OpenapiNodesResp defines model for v0.0.41_openapi_nodes_resp.
type V0041OpenapiNodesResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// LastUpdate Time of last node change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Nodes List of nodes
	Nodes []struct {
		// ActiveFeatures Currently active features
		ActiveFeatures *[]string `json:"active_features,omitempty"`

		// Address NodeAddr, used to establish a communication path
		Address *string `json:"address,omitempty"`

		// AllocCpus Total number of CPUs currently allocated for jobs
		AllocCpus *int32 `json:"alloc_cpus,omitempty"`

		// AllocIdleCpus Total number of idle CPUs
		AllocIdleCpus *int32 `json:"alloc_idle_cpus,omitempty"`

		// AllocMemory Total memory in MB currently allocated for jobs
		AllocMemory *int64 `json:"alloc_memory,omitempty"`

		// Architecture Computer architecture
		Architecture *string `json:"architecture,omitempty"`

		// Boards Number of Baseboards in nodes with a baseboard controller
		Boards *int32 `json:"boards,omitempty"`

		// BootTime Time when the node booted (UNIX timestamp)
		BootTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"boot_time,omitempty"`

		// BurstbufferNetworkAddress Alternate network path to be used for sbcast network traffic
		BurstbufferNetworkAddress *string `json:"burstbuffer_network_address,omitempty"`

		// ClusterName Cluster name (only set in federated environments)
		ClusterName *string `json:"cluster_name,omitempty"`

		// Comment Arbitrary comment
		Comment *string `json:"comment,omitempty"`

		// Cores Number of cores in a single physical processor socket
		Cores *int32 `json:"cores,omitempty"`

		// CpuBinding Default method for binding tasks to allocated CPUs
		CpuBinding *int32 `json:"cpu_binding,omitempty"`

		// CpuLoad CPU load as reported by the OS
		CpuLoad *int32 `json:"cpu_load,omitempty"`

		// Cpus Total CPUs, including cores and threads
		Cpus *int32 `json:"cpus,omitempty"`

		// EffectiveCpus Number of effective CPUs (excluding specialized CPUs)
		EffectiveCpus *int32 `json:"effective_cpus,omitempty"`

		// Energy Energy usage data
		Energy *struct {
			// AverageWatts Average power consumption, in watts
			AverageWatts *int32 `json:"average_watts,omitempty"`

			// BaseConsumedEnergy The energy consumed between when the node was powered on and the last time it was registered by slurmd, in joules
			BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`

			// ConsumedEnergy The energy consumed between the last time the node was registered by the slurmd daemon and the last node energy accounting sample, in joules
			ConsumedEnergy *int64 `json:"consumed_energy,omitempty"`

			// CurrentWatts The instantaneous power consumption at the time of the last node energy accounting sample, in watts
			CurrentWatts *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"current_watts,omitempty"`

			// LastCollected Time when energy data was last retrieved (UNIX timestamp)
			LastCollected *int64 `json:"last_collected,omitempty"`

			// PreviousConsumedEnergy Previous value of consumed_energy
			PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
		} `json:"energy,omitempty"`
		// Deprecated:
		ExternalSensors *map[string]interface{} `json:"external_sensors,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// Features Available features
		Features *[]string `json:"features,omitempty"`

		// FreeMem Total memory in MB currently free as reported by the OS
		FreeMem *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"free_mem,omitempty"`

		// GpuSpec CPU cores reserved for jobs that also use a GPU
		GpuSpec *string `json:"gpu_spec,omitempty"`

		// Gres Generic resources
		Gres *string `json:"gres,omitempty"`

		// GresDrained Drained generic resources
		GresDrained *string `json:"gres_drained,omitempty"`

		// GresUsed Generic resources currently in use
		GresUsed *string `json:"gres_used,omitempty"`

		// Hostname NodeHostname
		Hostname *string `json:"hostname,omitempty"`

		// InstanceId Cloud instance ID
		InstanceId *string `json:"instance_id,omitempty"`

		// InstanceType Cloud instance type
		InstanceType *string `json:"instance_type,omitempty"`

		// LastBusy Time when the node was last busy (UNIX timestamp)
		LastBusy *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"last_busy,omitempty"`

		// McsLabel Multi-Category Security label
		McsLabel *string `json:"mcs_label,omitempty"`

		// Name NodeName
		Name *string `json:"name,omitempty"`

		// NextStateAfterReboot The state the node will be assigned after rebooting
		NextStateAfterReboot *[]V0041OpenapiNodesRespNodesNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`

		// OperatingSystem Operating system reported by the node
		OperatingSystem *string `json:"operating_system,omitempty"`

		// Owner User allowed to run jobs on this node (unset if no restriction)
		Owner *string `json:"owner,omitempty"`

		// Partitions Partitions containing this node
		Partitions *[]string `json:"partitions,omitempty"`

		// Port TCP port number of the slurmd
		Port *int32 `json:"port,omitempty"`
		// Deprecated:
		Power *map[string]interface{} `json:"power,omitempty"`

		// RealMemory Total memory in MB on the node
		RealMemory *int64 `json:"real_memory,omitempty"`

		// Reason Describes why the node is in a "DOWN", "DRAINED", "DRAINING", "FAILING" or "FAIL" state
		Reason *string `json:"reason,omitempty"`

		// ReasonChangedAt When the reason changed (UNIX timestamp)
		ReasonChangedAt *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"reason_changed_at,omitempty"`

		// ReasonSetByUser User who set the reason
		ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`

		// ResCoresPerGpu Number of CPU cores per GPU restricted to GPU jobs
		ResCoresPerGpu *int32 `json:"res_cores_per_gpu,omitempty"`

		// Reservation Name of reservation containing this node
		Reservation *string `json:"reservation,omitempty"`

		// ResumeAfter Number of seconds after the node's state is updated to "DOWN" or "DRAIN" before scheduling a node state resume
		ResumeAfter *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"resume_after,omitempty"`

		// SlurmdStartTime Time when the slurmd started (UNIX timestamp)
		SlurmdStartTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"slurmd_start_time,omitempty"`

		// Sockets Number of physical processor sockets/chips on the node
		Sockets *int32 `json:"sockets,omitempty"`

		// SpecializedCores Number of cores reserved for system use
		SpecializedCores *int32 `json:"specialized_cores,omitempty"`

		// SpecializedCpus Abstract CPU IDs on this node reserved for exclusive use by slurmd and slurmstepd
		SpecializedCpus *string `json:"specialized_cpus,omitempty"`

		// SpecializedMemory Combined memory limit, in MB, for Slurm compute node daemons
		SpecializedMemory *int64 `json:"specialized_memory,omitempty"`

		// State Node state(s) applicable to this node
		State *[]V0041OpenapiNodesRespNodesState `json:"state,omitempty"`

		// TemporaryDisk Total size in MB of temporary disk storage in TmpFS
		TemporaryDisk *int32 `json:"temporary_disk,omitempty"`

		// Threads Number of logical threads in a single physical core
		Threads *int32 `json:"threads,omitempty"`

		// Tres Configured trackable resources
		Tres *string `json:"tres,omitempty"`

		// TresUsed Trackable resources currently allocated for jobs
		TresUsed *string `json:"tres_used,omitempty"`

		// TresWeighted Ignored. Was weighted number of billable trackable resources allocated
		// Deprecated:
		TresWeighted *float64 `json:"tres_weighted,omitempty"`

		// Version Slurmd version
		Version *string `json:"version,omitempty"`

		// Weight Weight of the node for scheduling purposes
		Weight *int32 `json:"weight,omitempty"`
	} `json:"nodes"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiNodesRespNodesNextStateAfterReboot defines model for V0041OpenapiNodesResp.Nodes.NextStateAfterReboot.
type V0041OpenapiNodesRespNodesNextStateAfterReboot string

// V0041OpenapiNodesRespNodesState defines model for V0041OpenapiNodesResp.Nodes.State.
type V0041OpenapiNodesRespNodesState string

// V0041OpenapiPartitionResp defines model for v0.0.41_openapi_partition_resp.
type V0041OpenapiPartitionResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// LastUpdate Time of last partition change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Partitions List of partitions
	Partitions []struct {
		Accounts *struct {
			// Allowed AllowAccounts
			Allowed *string `json:"allowed,omitempty"`

			// Deny DenyAccounts
			Deny *string `json:"deny,omitempty"`
		} `json:"accounts,omitempty"`

		// Alternate Alternate
		Alternate *string `json:"alternate,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`
		Cpus    *struct {
			// TaskBinding CpuBind
			TaskBinding *int32 `json:"task_binding,omitempty"`

			// Total TotalCPUs
			Total *int32 `json:"total,omitempty"`
		} `json:"cpus,omitempty"`
		Defaults *struct {
			// Job JobDefaults
			Job *string `json:"job,omitempty"`

			// MemoryPerCpu DefMemPerCPU or DefMemPerNode
			MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

			// PartitionMemoryPerCpu DefMemPerCPU
			PartitionMemoryPerCpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"partition_memory_per_cpu,omitempty"`

			// PartitionMemoryPerNode DefMemPerNode
			PartitionMemoryPerNode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"partition_memory_per_node,omitempty"`

			// Time DefaultTime in minutes
			Time *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time,omitempty"`
		} `json:"defaults,omitempty"`

		// GraceTime GraceTime
		GraceTime *int32 `json:"grace_time,omitempty"`
		Groups    *struct {
			// Allowed AllowGroups
			Allowed *string `json:"allowed,omitempty"`
		} `json:"groups,omitempty"`
		Maximums *struct {
			// CpusPerNode MaxCPUsPerNode
			CpusPerNode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus_per_node,omitempty"`

			// CpusPerSocket MaxCPUsPerSocket
			CpusPerSocket *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus_per_socket,omitempty"`

			// MemoryPerCpu MaxMemPerCPU or MaxMemPerNode
			MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

			// Nodes MaxNodes
			Nodes *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nodes,omitempty"`

			// OverTimeLimit OverTimeLimit
			OverTimeLimit *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"over_time_limit,omitempty"`
			Oversubscribe *struct {
				// Flags Flags applicable to the OverSubscribe setting
				Flags *[]V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags `json:"flags,omitempty"`

				// Jobs Maximum number of jobs allowed to oversubscribe resources
				Jobs *int32 `json:"jobs,omitempty"`
			} `json:"oversubscribe,omitempty"`

			// PartitionMemoryPerCpu MaxMemPerCPU
			PartitionMemoryPerCpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"partition_memory_per_cpu,omitempty"`

			// PartitionMemoryPerNode MaxMemPerNode
			PartitionMemoryPerNode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"partition_memory_per_node,omitempty"`

			// Shares OverSubscribe
			Shares *int32 `json:"shares,omitempty"`

			// Time MaxTime
			Time *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time,omitempty"`
		} `json:"maximums,omitempty"`
		Minimums *struct {
			// Nodes MinNodes
			Nodes *int32 `json:"nodes,omitempty"`
		} `json:"minimums,omitempty"`

		// Name PartitionName
		Name *string `json:"name,omitempty"`

		// NodeSets NodeSets
		NodeSets *string `json:"node_sets,omitempty"`
		Nodes    *struct {
			// AllowedAllocation AllocNodes
			AllowedAllocation *string `json:"allowed_allocation,omitempty"`

			// Configured Nodes
			Configured *string `json:"configured,omitempty"`

			// Total TotalNodes
			Total *int32 `json:"total,omitempty"`
		} `json:"nodes,omitempty"`
		Partition *struct {
			// State Current state(s)
			State *[]V0041OpenapiPartitionRespPartitionsPartitionState `json:"state,omitempty"`
		} `json:"partition,omitempty"`
		Priority *struct {
			// JobFactor PriorityJobFactor
			JobFactor *int32 `json:"job_factor,omitempty"`

			// Tier PriorityTier
			Tier *int32 `json:"tier,omitempty"`
		} `json:"priority,omitempty"`
		Qos *struct {
			// Allowed AllowQOS
			Allowed *string `json:"allowed,omitempty"`

			// Assigned QOS
			Assigned *string `json:"assigned,omitempty"`

			// Deny DenyQOS
			Deny *string `json:"deny,omitempty"`
		} `json:"qos,omitempty"`

		// SelectType Scheduler consumable resource selection type
		SelectType *[]V0041OpenapiPartitionRespPartitionsSelectType `json:"select_type,omitempty"`

		// SuspendTime SuspendTime (GLOBAL if both set and infinite are false)
		SuspendTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"suspend_time,omitempty"`
		Timeouts *struct {
			// Resume ResumeTimeout (GLOBAL if both set and infinite are false)
			Resume *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"resume,omitempty"`

			// Suspend SuspendTimeout (GLOBAL if both set and infinite are false)
			Suspend *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"suspend,omitempty"`
		} `json:"timeouts,omitempty"`
		Tres *struct {
			// BillingWeights TRESBillingWeights
			BillingWeights *string `json:"billing_weights,omitempty"`

			// Configured TRES
			Configured *string `json:"configured,omitempty"`
		} `json:"tres,omitempty"`
	} `json:"partitions"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags defines model for V0041OpenapiPartitionResp.Partitions.Maximums.Oversubscribe.Flags.
type V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags string

// V0041OpenapiPartitionRespPartitionsPartitionState defines model for V0041OpenapiPartitionResp.Partitions.Partition.State.
type V0041OpenapiPartitionRespPartitionsPartitionState string

// V0041OpenapiPartitionRespPartitionsSelectType defines model for V0041OpenapiPartitionResp.Partitions.SelectType.
type V0041OpenapiPartitionRespPartitionsSelectType string

// V0041OpenapiReservationResp defines model for v0.0.41_openapi_reservation_resp.
type V0041OpenapiReservationResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// LastUpdate Time of last reservation change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Reservations List of reservations
	Reservations []struct {
		// Accounts Comma separated list of permitted accounts
		Accounts *string `json:"accounts,omitempty"`

		// BurstBuffer BurstBuffer
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// CoreCount CoreCnt
		CoreCount *int32 `json:"core_count,omitempty"`

		// CoreSpecializations Reserved cores specification
		CoreSpecializations *[]struct {
			// Core IDs of reserved cores
			Core *string `json:"core,omitempty"`

			// Node Name of reserved node
			Node *string `json:"node,omitempty"`
		} `json:"core_specializations,omitempty"`

		// EndTime EndTime (UNIX timestamp)
		EndTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"end_time,omitempty"`

		// Features Features
		Features *string `json:"features,omitempty"`

		// Flags Flags associated with the reservation
		Flags *[]V0041OpenapiReservationRespReservationsFlags `json:"flags,omitempty"`

		// Groups Groups
		Groups *string `json:"groups,omitempty"`

		// Licenses Licenses
		Licenses *string `json:"licenses,omitempty"`

		// MaxStartDelay MaxStartDelay in seconds
		MaxStartDelay *int32 `json:"max_start_delay,omitempty"`

		// Name ReservationName
		Name *string `json:"name,omitempty"`

		// NodeCount NodeCnt
		NodeCount *int32 `json:"node_count,omitempty"`

		// NodeList Nodes
		NodeList *string `json:"node_list,omitempty"`

		// Partition PartitionName
		Partition      *string `json:"partition,omitempty"`
		PurgeCompleted *struct {
			// Time If PURGE_COMP flag is set, the number of seconds this reservation will sit idle until it is revoked
			Time *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time,omitempty"`
		} `json:"purge_completed,omitempty"`

		// StartTime StartTime (UNIX timestamp)
		StartTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"start_time,omitempty"`

		// Tres Comma separated list of required TRES
		Tres *string `json:"tres,omitempty"`

		// Users Comma separated list of permitted users
		Users *string `json:"users,omitempty"`

		// Watts 32 bit integer number with flags
		// Deprecated:
		Watts *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"watts,omitempty"`
	} `json:"reservations"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiReservationRespReservationsFlags defines model for V0041OpenapiReservationResp.Reservations.Flags.
type V0041OpenapiReservationRespReservationsFlags string

// V0041OpenapiResp defines model for v0.0.41_openapi_resp.
type V0041OpenapiResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSharesResp defines model for v0.0.41_openapi_shares_resp.
type V0041OpenapiSharesResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Shares fairshare info
	Shares struct {
		// Shares Association shares
		Shares *[]struct {
			// Cluster Cluster name
			Cluster *string `json:"cluster,omitempty"`

			// EffectiveUsage Effective, normalized usage
			EffectiveUsage *float64 `json:"effective_usage,omitempty"`
			Fairshare      *struct {
				// Factor Fairshare factor
				Factor *float64 `json:"factor,omitempty"`

				// Level Fairshare factor at this level; stored on an assoc as a long double, but that is not needed for display in sshare
				Level *float64 `json:"level,omitempty"`
			} `json:"fairshare,omitempty"`

			// Id Association ID
			Id *int32 `json:"id,omitempty"`

			// Name Share name
			Name *string `json:"name,omitempty"`

			// Parent Parent name
			Parent *string `json:"parent,omitempty"`

			// Partition Partition name
			Partition *string `json:"partition,omitempty"`

			// Shares Number of shares allocated
			Shares *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"shares,omitempty"`

			// SharesNormalized Normalized shares
			SharesNormalized *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"shares_normalized,omitempty"`
			Tres *struct {
				// GroupMinutes TRES-minute limit
				GroupMinutes *[]struct {
					// Name TRES name
					Name *string `json:"name,omitempty"`

					// Value TRES value
					Value *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"value,omitempty"`
				} `json:"group_minutes,omitempty"`

				// RunSeconds Currently running tres-secs = grp_used_tres_run_secs
				RunSeconds *[]struct {
					// Name TRES name
					Name *string `json:"name,omitempty"`

					// Value TRES value
					Value *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"value,omitempty"`
				} `json:"run_seconds,omitempty"`

				// Usage Measure of each TRES usage
				Usage *[]struct {
					// Name TRES name
					Name *string `json:"name,omitempty"`

					// Value TRES value
					Value *float32 `json:"value,omitempty"`
				} `json:"usage,omitempty"`
			} `json:"tres,omitempty"`

			// Type User or account association
			Type *[]V0041OpenapiSharesRespSharesSharesType `json:"type,omitempty"`

			// Usage Measure of tresbillableunits usage
			Usage *int64 `json:"usage,omitempty"`

			// UsageNormalized Normalized usage
			UsageNormalized *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"usage_normalized,omitempty"`
		} `json:"shares,omitempty"`

		// TotalShares Total number of shares
		TotalShares *int64 `json:"total_shares,omitempty"`
	} `json:"shares"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSharesRespSharesSharesType defines model for V0041OpenapiSharesResp.Shares.Shares.Type.
type V0041OpenapiSharesRespSharesSharesType string

// V0041OpenapiSlurmdbdConfigResp defines model for v0.0.41_openapi_slurmdbd_config_resp.
type V0041OpenapiSlurmdbdConfigResp struct {
	// Accounts Accounts
	Accounts *[]struct {
		// Associations Associations involving this account (only populated if requested)
		Associations *[]struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"associations,omitempty"`

		// Coordinators List of users that are a coordinator of this account (only populated if requested)
		Coordinators *[]struct {
			// Direct Indicates whether the coordinator was directly assigned to this account
			Direct *bool `json:"direct,omitempty"`

			// Name User name
			Name string `json:"name"`
		} `json:"coordinators,omitempty"`

		// Description Arbitrary string describing the account
		Description string `json:"description"`

		// Flags Flags associated with the account
		Flags *[]V0041OpenapiSlurmdbdConfigRespAccountsFlags `json:"flags,omitempty"`

		// Name Account name
		Name string `json:"name"`

		// Organization Organization to which the account belongs
		Organization string `json:"organization"`
	} `json:"accounts,omitempty"`

	// Associations Associations
	Associations *[]struct {
		// Account Account
		Account *string `json:"account,omitempty"`

		// Accounting Accounting records containing related resource usage
		Accounting *[]struct {
			// TRES Trackable resources
			TRES *struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"TRES,omitempty"`
			Allocated *struct {
				// Seconds Number of cpu seconds allocated
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"allocated,omitempty"`

			// Id Association ID or Workload characterization key ID
			Id *int32 `json:"id,omitempty"`

			// Start When the record was started
			Start *int64 `json:"start,omitempty"`
		} `json:"accounting,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Comment Arbitrary comment
		Comment *string `json:"comment,omitempty"`
		Default *struct {
			// Qos Default QOS
			Qos *string `json:"qos,omitempty"`
		} `json:"default,omitempty"`

		// Flags Flags on the association
		Flags *[]V0041OpenapiSlurmdbdConfigRespAssociationsFlags `json:"flags,omitempty"`

		// Id Unique ID
		Id *int32 `json:"id,omitempty"`

		// IsDefault Is default association for user
		IsDefault *bool `json:"is_default,omitempty"`

		// Lineage Complete path up the hierarchy to the root association
		Lineage *string `json:"lineage,omitempty"`
		Max     *struct {
			Jobs *struct {
				// Accruing MaxJobsAccrue
				Accruing *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"accruing,omitempty"`

				// Active MaxJobs
				Active *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"active,omitempty"`
				Per *struct {
					// Accruing GrpJobsAccrue
					Accruing *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"accruing,omitempty"`

					// Count GrpJobs
					Count *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"count,omitempty"`

					// Submitted GrpSubmitJobs
					Submitted *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"submitted,omitempty"`

					// WallClock MaxWallDurationPerJob
					WallClock *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"wall_clock,omitempty"`
				} `json:"per,omitempty"`

				// Total MaxSubmitJobs
				Total *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"total,omitempty"`
			} `json:"jobs,omitempty"`
			Per *struct {
				Account *struct {
					// WallClock GrpWall
					WallClock *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"wall_clock,omitempty"`
				} `json:"account,omitempty"`
			} `json:"per,omitempty"`
			Tres *struct {
				Group *struct {
					// Active GrpTRESRunMins
					Active *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"active,omitempty"`

					// Minutes GrpTRESMins
					Minutes *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"minutes,omitempty"`
				} `json:"group,omitempty"`
				Minutes *struct {
					Per *struct {
						// Job MaxTRESMinsPerJob
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`
					} `json:"per,omitempty"`

					// Total MaxTRESMinsPerJob
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"minutes,omitempty"`
				Per *struct {
					// Job MaxTRESPerJob
					Job *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"job,omitempty"`

					// Node MaxTRESPerNode
					Node *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"node,omitempty"`
				} `json:"per,omitempty"`

				// Total GrpTRES
				Total *[]struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"total,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"max,omitempty"`
		Min *struct {
			// PriorityThreshold MinPrioThreshold
			PriorityThreshold *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority_threshold,omitempty"`
		} `json:"min,omitempty"`

		// ParentAccount Name of parent account
		ParentAccount *string `json:"parent_account,omitempty"`

		// Partition Partition name
		Partition *string `json:"partition,omitempty"`

		// Priority Association priority factor
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Qos List of available QOS names
		Qos *[]string `json:"qos,omitempty"`

		// SharesRaw Allocated shares used for fairshare calculation
		SharesRaw *int32 `json:"shares_raw,omitempty"`

		// User User name
		User string `json:"user"`
	} `json:"associations,omitempty"`

	// Clusters Clusters
	Clusters *[]struct {
		Associations *struct {
			// Root Root association information
			Root *struct {
				// Account Account
				Account *string `json:"account,omitempty"`

				// Cluster Cluster
				Cluster *string `json:"cluster,omitempty"`

				// Id Numeric association ID
				Id *int32 `json:"id,omitempty"`

				// Partition Partition
				Partition *string `json:"partition,omitempty"`

				// User User name
				User string `json:"user"`
			} `json:"root,omitempty"`
		} `json:"associations,omitempty"`
		Controller *struct {
			// Host ControlHost
			Host *string `json:"host,omitempty"`

			// Port ControlPort
			Port *int32 `json:"port,omitempty"`
		} `json:"controller,omitempty"`

		// Flags Flags
		Flags *[]V0041OpenapiSlurmdbdConfigRespClustersFlags `json:"flags,omitempty"`

		// Name ClusterName
		Name *string `json:"name,omitempty"`

		// Nodes Node names
		Nodes *string `json:"nodes,omitempty"`

		// RpcVersion RPC version used in the cluster
		RpcVersion *int32 `json:"rpc_version,omitempty"`
		// Deprecated:
		SelectPlugin *string `json:"select_plugin,omitempty"`

		// Tres Trackable resources
		Tres *[]struct {
			// Count TRES count (0 if listed generically)
			Count *int64 `json:"count,omitempty"`

			// Id ID used in database
			Id *int32 `json:"id,omitempty"`

			// Name TRES name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type TRES type (CPU, MEM, etc)
			Type string `json:"type"`
		} `json:"tres,omitempty"`
	} `json:"clusters,omitempty"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Instances Instances
	Instances *[]struct {
		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// InstanceId Cloud instance ID
		InstanceId *string `json:"instance_id,omitempty"`

		// InstanceType Cloud instance type
		InstanceType *string `json:"instance_type,omitempty"`

		// NodeName NodeName
		NodeName *string `json:"node_name,omitempty"`
		Time     *struct {
			// TimeEnd When the instance will end (UNIX timestamp)
			TimeEnd *int64 `json:"time_end,omitempty"`

			// TimeStart When the instance will start (UNIX timestamp)
			TimeStart *int64 `json:"time_start,omitempty"`
		} `json:"time,omitempty"`
	} `json:"instances,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Qos QOS
	Qos *[]struct {
		// Description Arbitrary description
		Description *string `json:"description,omitempty"`

		// Flags Flags, to avoid modifying current values specify NOT_SET
		Flags *[]V0041OpenapiSlurmdbdConfigRespQosFlags `json:"flags,omitempty"`

		// Id Unique ID
		Id     *int32 `json:"id,omitempty"`
		Limits *struct {
			// Factor LimitFactor
			Factor *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"factor,omitempty"`

			// GraceTime GraceTime
			GraceTime *int32 `json:"grace_time,omitempty"`
			Max       *struct {
				Accruing *struct {
					Per *struct {
						// Account MaxJobsAccruePerAccount
						Account *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"account,omitempty"`

						// User MaxJobsAccruePerUser
						User *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"accruing,omitempty"`
				ActiveJobs *struct {
					// Accruing GrpJobsAccrue
					Accruing *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"accruing,omitempty"`

					// Count GrpJobs
					Count *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"count,omitempty"`
				} `json:"active_jobs,omitempty"`
				Jobs *struct {
					ActiveJobs *struct {
						Per *struct {
							// Account MaxJobsPerAccount
							Account *struct {
								// Infinite True if number has been set to infinite; "set" and "number" will be ignored
								Infinite *bool `json:"infinite,omitempty"`

								// Number If "set" is True the number will be set with value; otherwise ignore number contents
								Number *int32 `json:"number,omitempty"`

								// Set True if number has been set; False if number is unset
								Set *bool `json:"set,omitempty"`
							} `json:"account,omitempty"`

							// User MaxJobsPerUser
							User *struct {
								// Infinite True if number has been set to infinite; "set" and "number" will be ignored
								Infinite *bool `json:"infinite,omitempty"`

								// Number If "set" is True the number will be set with value; otherwise ignore number contents
								Number *int32 `json:"number,omitempty"`

								// Set True if number has been set; False if number is unset
								Set *bool `json:"set,omitempty"`
							} `json:"user,omitempty"`
						} `json:"per,omitempty"`
					} `json:"active_jobs,omitempty"`
					Per *struct {
						// Account MaxSubmitJobsPerAccount
						Account *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"account,omitempty"`

						// User MaxSubmitJobsPerUser
						User *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"jobs,omitempty"`
				Tres *struct {
					Minutes *struct {
						Per *struct {
							// Account MaxTRESRunMinsPerAccount
							Account *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"account,omitempty"`

							// Job MaxTRESMinsPerJob
							Job *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"job,omitempty"`

							// Qos GrpTRESRunMins
							Qos *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"qos,omitempty"`

							// User MaxTRESRunMinsPerUser
							User *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"user,omitempty"`
						} `json:"per,omitempty"`
					} `json:"minutes,omitempty"`
					Per *struct {
						// Account MaxTRESPerAccount
						Account *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"account,omitempty"`

						// Job MaxTRESPerJob
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`

						// Node MaxTRESPerNode
						Node *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"node,omitempty"`

						// User MaxTRESPerUser
						User *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`

					// Total GrpTRES
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"tres,omitempty"`
				WallClock *struct {
					Per *struct {
						// Job MaxWallDurationPerJob
						Job *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"job,omitempty"`

						// Qos GrpWall
						Qos *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"qos,omitempty"`
					} `json:"per,omitempty"`
				} `json:"wall_clock,omitempty"`
			} `json:"max,omitempty"`
			Min *struct {
				// PriorityThreshold MinPrioThreshold
				PriorityThreshold *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"priority_threshold,omitempty"`
				Tres *struct {
					Per *struct {
						// Job MinTRES
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`
					} `json:"per,omitempty"`
				} `json:"tres,omitempty"`
			} `json:"min,omitempty"`
		} `json:"limits,omitempty"`

		// Name Name
		Name    *string `json:"name,omitempty"`
		Preempt *struct {
			// ExemptTime PreemptExemptTime
			ExemptTime *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"exempt_time,omitempty"`

			// List Other QOS's this QOS can preempt
			List *[]string `json:"list,omitempty"`

			// Mode PreemptMode
			Mode *[]V0041OpenapiSlurmdbdConfigRespQosPreemptMode `json:"mode,omitempty"`
		} `json:"preempt,omitempty"`

		// Priority Priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// UsageFactor UsageFactor
		UsageFactor *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"usage_factor,omitempty"`

		// UsageThreshold UsageThreshold
		UsageThreshold *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"usage_threshold,omitempty"`
	} `json:"qos,omitempty"`

	// Tres TRES
	Tres *[]struct {
		// Count TRES count (0 if listed generically)
		Count *int64 `json:"count,omitempty"`

		// Id ID used in database
		Id *int32 `json:"id,omitempty"`

		// Name TRES name (if applicable)
		Name *string `json:"name,omitempty"`

		// Type TRES type (CPU, MEM, etc)
		Type string `json:"type"`
	} `json:"tres,omitempty"`

	// Users Users
	Users *[]struct {
		// AdministratorLevel AdminLevel granted to the user
		AdministratorLevel *[]V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel `json:"administrator_level,omitempty"`

		// Associations Associations created for this user
		Associations *[]struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"associations,omitempty"`

		// Coordinators Accounts this user is a coordinator for
		Coordinators *[]struct {
			// Direct Indicates whether the coordinator was directly assigned to this account
			Direct *bool `json:"direct,omitempty"`

			// Name User name
			Name string `json:"name"`
		} `json:"coordinators,omitempty"`
		Default *struct {
			// Account Default Account
			Account *string `json:"account,omitempty"`

			// Wckey Default WCKey
			Wckey *string `json:"wckey,omitempty"`
		} `json:"default,omitempty"`

		// Flags Flags associated with user
		Flags *[]V0041OpenapiSlurmdbdConfigRespUsersFlags `json:"flags,omitempty"`

		// Name User name
		Name string `json:"name"`

		// OldName Previous user name
		OldName *string `json:"old_name,omitempty"`

		// Wckeys List of available WCKeys
		Wckeys *[]struct {
			// Accounting Accounting records containing related resource usage
			Accounting *[]struct {
				// TRES Trackable resources
				TRES *struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"TRES,omitempty"`
				Allocated *struct {
					// Seconds Number of cpu seconds allocated
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"allocated,omitempty"`

				// Id Association ID or Workload characterization key ID
				Id *int32 `json:"id,omitempty"`

				// Start When the record was started
				Start *int64 `json:"start,omitempty"`
			} `json:"accounting,omitempty"`

			// Cluster Cluster name
			Cluster string `json:"cluster"`

			// Flags Flags associated with the WCKey
			Flags *[]V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags `json:"flags,omitempty"`

			// Id Unique ID for this user-cluster-wckey combination
			Id *int32 `json:"id,omitempty"`

			// Name WCKey name
			Name string `json:"name"`

			// User User name
			User string `json:"user"`
		} `json:"wckeys,omitempty"`
	} `json:"users,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`

	// Wckeys WCKeys
	Wckeys *[]struct {
		// Accounting Accounting records containing related resource usage
		Accounting *[]struct {
			// TRES Trackable resources
			TRES *struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"TRES,omitempty"`
			Allocated *struct {
				// Seconds Number of cpu seconds allocated
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"allocated,omitempty"`

			// Id Association ID or Workload characterization key ID
			Id *int32 `json:"id,omitempty"`

			// Start When the record was started
			Start *int64 `json:"start,omitempty"`
		} `json:"accounting,omitempty"`

		// Cluster Cluster name
		Cluster string `json:"cluster"`

		// Flags Flags associated with the WCKey
		Flags *[]V0041OpenapiSlurmdbdConfigRespWckeysFlags `json:"flags,omitempty"`

		// Id Unique ID for this user-cluster-wckey combination
		Id *int32 `json:"id,omitempty"`

		// Name WCKey name
		Name string `json:"name"`

		// User User name
		User string `json:"user"`
	} `json:"wckeys,omitempty"`
}

// V0041OpenapiSlurmdbdConfigRespAccountsFlags defines model for V0041OpenapiSlurmdbdConfigResp.Accounts.Flags.
type V0041OpenapiSlurmdbdConfigRespAccountsFlags string

// V0041OpenapiSlurmdbdConfigRespAssociationsFlags defines model for V0041OpenapiSlurmdbdConfigResp.Associations.Flags.
type V0041OpenapiSlurmdbdConfigRespAssociationsFlags string

// V0041OpenapiSlurmdbdConfigRespClustersFlags defines model for V0041OpenapiSlurmdbdConfigResp.Clusters.Flags.
type V0041OpenapiSlurmdbdConfigRespClustersFlags string

// V0041OpenapiSlurmdbdConfigRespQosFlags defines model for V0041OpenapiSlurmdbdConfigResp.Qos.Flags.
type V0041OpenapiSlurmdbdConfigRespQosFlags string

// V0041OpenapiSlurmdbdConfigRespQosPreemptMode defines model for V0041OpenapiSlurmdbdConfigResp.Qos.Preempt.Mode.
type V0041OpenapiSlurmdbdConfigRespQosPreemptMode string

// V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel defines model for V0041OpenapiSlurmdbdConfigResp.Users.AdministratorLevel.
type V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel string

// V0041OpenapiSlurmdbdConfigRespUsersFlags defines model for V0041OpenapiSlurmdbdConfigResp.Users.Flags.
type V0041OpenapiSlurmdbdConfigRespUsersFlags string

// V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags defines model for V0041OpenapiSlurmdbdConfigResp.Users.Wckeys.Flags.
type V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags string

// V0041OpenapiSlurmdbdConfigRespWckeysFlags defines model for V0041OpenapiSlurmdbdConfigResp.Wckeys.Flags.
type V0041OpenapiSlurmdbdConfigRespWckeysFlags string

// V0041OpenapiSlurmdbdJobsResp defines model for v0.0.41_openapi_slurmdbd_jobs_resp.
type V0041OpenapiSlurmdbdJobsResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Jobs jobs
	Jobs []struct {
		// Account Account the job ran under
		Account *string `json:"account,omitempty"`

		// AllocationNodes List of nodes allocated to the job
		AllocationNodes *int32 `json:"allocation_nodes,omitempty"`
		Array           *struct {
			// JobId Job ID of job array, or 0 if N/A
			JobId  *int32 `json:"job_id,omitempty"`
			Limits *struct {
				Max *struct {
					Running *struct {
						// Tasks Maximum number of simultaneously running tasks, 0 if no limit
						Tasks *int32 `json:"tasks,omitempty"`
					} `json:"running,omitempty"`
				} `json:"max,omitempty"`
			} `json:"limits,omitempty"`

			// Task String expression of task IDs in this record
			Task *string `json:"task,omitempty"`

			// TaskId Task ID of this task in job array
			TaskId *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"task_id,omitempty"`
		} `json:"array,omitempty"`

		// Association Unique identifier for the association
		Association *struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"association,omitempty"`

		// Block The name of the block to be used (used with Blue Gene systems)
		Block *string `json:"block,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`
		Comment *struct {
			// Administrator Arbitrary comment made by administrator
			Administrator *string `json:"administrator,omitempty"`

			// Job Arbitrary comment made by user
			Job *string `json:"job,omitempty"`

			// System Arbitrary comment from slurmctld
			System *string `json:"system,omitempty"`
		} `json:"comment,omitempty"`

		// Constraints Feature(s) the job requested as a constraint
		Constraints *string `json:"constraints,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// DerivedExitCode Highest exit code of all job steps
		DerivedExitCode *struct {
			// ReturnCode Process return code (numeric)
			ReturnCode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"return_code,omitempty"`
			Signal *struct {
				// Id Signal sent to process (numeric)
				Id *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"id,omitempty"`

				// Name Signal sent to process
				Name *string `json:"name,omitempty"`
			} `json:"signal,omitempty"`

			// Status Status given by return code
			Status *[]V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus `json:"status,omitempty"`
		} `json:"derived_exit_code,omitempty"`

		// ExitCode Exit code
		ExitCode *struct {
			// ReturnCode Process return code (numeric)
			ReturnCode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"return_code,omitempty"`
			Signal *struct {
				// Id Signal sent to process (numeric)
				Id *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"id,omitempty"`

				// Name Signal sent to process
				Name *string `json:"name,omitempty"`
			} `json:"signal,omitempty"`

			// Status Status given by return code
			Status *[]V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus `json:"status,omitempty"`
		} `json:"exit_code,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// FailedNode Name of node that caused job failure
		FailedNode *string `json:"failed_node,omitempty"`

		// Flags Flags associated with the job
		Flags *[]V0041OpenapiSlurmdbdJobsRespJobsFlags `json:"flags,omitempty"`

		// Group Group ID of the user that owns the job
		Group *string `json:"group,omitempty"`
		Het   *struct {
			// JobId Heterogeneous job ID, if applicable
			JobId *int32 `json:"job_id,omitempty"`

			// JobOffset Unique sequence number applied to this component of the heterogeneous job
			JobOffset *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"job_offset,omitempty"`
		} `json:"het,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// KillRequestUser User ID that requested termination of the job
		KillRequestUser *string `json:"kill_request_user,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`
		Mcs      *struct {
			// Label Multi-Category Security label on the job
			Label *string `json:"label,omitempty"`
		} `json:"mcs,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Nodes Node(s) allocated to the job
		Nodes *string `json:"nodes,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Qos Quality of Service assigned to the job
		Qos      *string `json:"qos,omitempty"`
		Required *struct {
			// CPUs Minimum number of CPUs required
			CPUs *int32 `json:"CPUs,omitempty"`

			// MemoryPerCpu Minimum memory in megabytes per allocated CPU
			MemoryPerCpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_cpu,omitempty"`

			// MemoryPerNode Minimum memory in megabytes per allocated node
			MemoryPerNode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_node,omitempty"`
		} `json:"required,omitempty"`
		Reservation *struct {
			// Id Unique identifier of requested reservation
			Id *int32 `json:"id,omitempty"`

			// Name Name of reservation to use
			Name *string `json:"name,omitempty"`
		} `json:"reservation,omitempty"`

		// Script Job batch script; only the first component in a HetJob is populated or honored
		Script *string `json:"script,omitempty"`
		State  *struct {
			// Current Current state
			Current *[]V0041OpenapiSlurmdbdJobsRespJobsStateCurrent `json:"current,omitempty"`

			// Reason Reason for previous Pending or Failed state
			Reason *string `json:"reason,omitempty"`
		} `json:"state,omitempty"`

		// Stderr Path to stderr file
		Stderr *string `json:"stderr,omitempty"`

		// StderrExpanded Job stderr with expanded fields
		StderrExpanded *string `json:"stderr_expanded,omitempty"`

		// Stdin Path to stdin file
		Stdin *string `json:"stdin,omitempty"`

		// StdinExpanded Job stdin with expanded fields
		StdinExpanded *string `json:"stdin_expanded,omitempty"`

		// Stdout Path to stdout file
		Stdout *string `json:"stdout,omitempty"`

		// StdoutExpanded Job stdout with expanded fields
		StdoutExpanded *string `json:"stdout_expanded,omitempty"`

		// Steps Individual steps in the job
		Steps *[]struct {
			CPU *struct {
				// Governor Requested CPU frequency governor in kHz
				Governor           *string `json:"governor,omitempty"`
				RequestedFrequency *struct {
					// Max Maximum requested CPU frequency in kHz
					Max *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"max,omitempty"`

					// Min Minimum requested CPU frequency in kHz
					Min *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"min,omitempty"`
				} `json:"requested_frequency,omitempty"`
			} `json:"CPU,omitempty"`

			// ExitCode Exit code
			ExitCode *struct {
				// ReturnCode Process return code (numeric)
				ReturnCode *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"return_code,omitempty"`
				Signal *struct {
					// Id Signal sent to process (numeric)
					Id *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"id,omitempty"`

					// Name Signal sent to process
					Name *string `json:"name,omitempty"`
				} `json:"signal,omitempty"`

				// Status Status given by return code
				Status *[]V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus `json:"status,omitempty"`
			} `json:"exit_code,omitempty"`

			// KillRequestUser User ID that requested termination of the step
			KillRequestUser *string `json:"kill_request_user,omitempty"`
			Nodes           *struct {
				// Count Number of nodes in the job step
				Count *int32 `json:"count,omitempty"`

				// List List of nodes used by the step
				List *[]string `json:"list,omitempty"`

				// Range Node(s) allocated to the job step
				Range *string `json:"range,omitempty"`
			} `json:"nodes,omitempty"`

			// Pid Process ID
			Pid *string `json:"pid,omitempty"`

			// State Current state
			State      *[]V0041OpenapiSlurmdbdJobsRespJobsStepsState `json:"state,omitempty"`
			Statistics *struct {
				CPU *struct {
					// ActualFrequency Average weighted CPU frequency of all tasks in kHz
					ActualFrequency *int64 `json:"actual_frequency,omitempty"`
				} `json:"CPU,omitempty"`
				Energy *struct {
					// Consumed Total energy consumed by all tasks in a job in joules
					Consumed *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"consumed,omitempty"`
				} `json:"energy,omitempty"`
			} `json:"statistics,omitempty"`
			Step *struct {
				// Id Step ID
				Id *string `json:"id,omitempty"`

				// Name Step name
				Name *string `json:"name,omitempty"`
			} `json:"step,omitempty"`
			Task *struct {
				// Distribution The layout of the step was when it was running
				Distribution *string `json:"distribution,omitempty"`
			} `json:"task,omitempty"`
			Tasks *struct {
				// Count Total number of tasks
				Count *int32 `json:"count,omitempty"`
			} `json:"tasks,omitempty"`
			Time *struct {
				// Elapsed Elapsed time in seconds
				Elapsed *int32 `json:"elapsed,omitempty"`

				// End End time (UNIX timestamp)
				End *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"end,omitempty"`

				// Start Time execution began (UNIX timestamp)
				Start *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"start,omitempty"`

				// Suspended Time in suspended state in seconds
				Suspended *int32 `json:"suspended,omitempty"`
				System    *struct {
					// Microseconds System CPU time used by the step in microseconds
					Microseconds *int32 `json:"microseconds,omitempty"`

					// Seconds System CPU time used by the step in seconds
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"system,omitempty"`
				Total *struct {
					// Microseconds Total CPU time used by the step in microseconds
					Microseconds *int32 `json:"microseconds,omitempty"`

					// Seconds Total CPU time used by the step in seconds
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"total,omitempty"`
				User *struct {
					// Microseconds User CPU time used by the step in microseconds
					Microseconds *int32 `json:"microseconds,omitempty"`

					// Seconds User CPU time used by the step in seconds
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"user,omitempty"`
			} `json:"time,omitempty"`
			Tres *struct {
				// Allocated Trackable resources allocated to the step
				Allocated *[]struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"allocated,omitempty"`
				Consumed *struct {
					// Average Average TRES usage consumed among all tasks
					Average *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"average,omitempty"`

					// Max Maximum TRES usage consumed among all tasks
					Max *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"max,omitempty"`

					// Min Minimum TRES usage consumed among all tasks
					Min *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"min,omitempty"`

					// Total Total TRES usage consumed among all tasks
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"consumed,omitempty"`
				Requested *struct {
					// Average Average TRES usage requested among all tasks
					Average *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"average,omitempty"`

					// Max Maximum TRES usage requested among all tasks
					Max *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"max,omitempty"`

					// Min Minimum TRES usage requested among all tasks
					Min *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"min,omitempty"`

					// Total Total TRES usage requested among all tasks
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"requested,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"steps,omitempty"`

		// SubmitLine Command used to submit the job
		SubmitLine *string `json:"submit_line,omitempty"`
		Time       *struct {
			// Elapsed Elapsed time in seconds
			Elapsed *int32 `json:"elapsed,omitempty"`

			// Eligible Time when the job became eligible to run (UNIX timestamp)
			Eligible *int64 `json:"eligible,omitempty"`

			// End End time (UNIX timestamp)
			End *int64 `json:"end,omitempty"`

			// Limit Maximum run time in minutes
			Limit *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"limit,omitempty"`

			// Planned Time required to start job after becoming eligible to run in seconds
			Planned *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"planned,omitempty"`

			// Start Time execution began (UNIX timestamp)
			Start *int64 `json:"start,omitempty"`

			// Submission Time when the job was submitted (UNIX timestamp)
			Submission *int64 `json:"submission,omitempty"`

			// Suspended Total time in suspended state in seconds
			Suspended *int32 `json:"suspended,omitempty"`
			System    *struct {
				// Microseconds System CPU time used by the job in microseconds
				Microseconds *int64 `json:"microseconds,omitempty"`

				// Seconds System CPU time used by the job in seconds
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"system,omitempty"`
			Total *struct {
				// Microseconds Sum of System and User CPU time used by the job in microseconds
				Microseconds *int64 `json:"microseconds,omitempty"`

				// Seconds Sum of System and User CPU time used by the job in seconds
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"total,omitempty"`
			User *struct {
				// Microseconds User CPU time used by the job in microseconds
				Microseconds *int64 `json:"microseconds,omitempty"`

				// Seconds User CPU time used by the job in seconds
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"user,omitempty"`
		} `json:"time,omitempty"`
		Tres *struct {
			// Allocated Trackable resources allocated to the job
			Allocated *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"allocated,omitempty"`

			// Requested Trackable resources requested by job
			Requested *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"requested,omitempty"`
		} `json:"tres,omitempty"`

		// UsedGres Generic resources used by job
		UsedGres *string `json:"used_gres,omitempty"`

		// User User that owns the job
		User *string `json:"user,omitempty"`

		// Wckey Workload characterization key
		Wckey *struct {
			// Flags Active flags
			Flags []V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags `json:"flags"`

			// Wckey WCKey name
			Wckey string `json:"wckey"`
		} `json:"wckey,omitempty"`

		// WorkingDirectory Path to current working directory
		WorkingDirectory *string `json:"working_directory,omitempty"`
	} `json:"jobs"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.DerivedExitCode.Status.
type V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus string

// V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.ExitCode.Status.
type V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus string

// V0041OpenapiSlurmdbdJobsRespJobsFlags defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.Flags.
type V0041OpenapiSlurmdbdJobsRespJobsFlags string

// V0041OpenapiSlurmdbdJobsRespJobsStateCurrent defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.State.Current.
type V0041OpenapiSlurmdbdJobsRespJobsStateCurrent string

// V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.Steps.ExitCode.Status.
type V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus string

// V0041OpenapiSlurmdbdJobsRespJobsStepsState defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.Steps.State.
type V0041OpenapiSlurmdbdJobsRespJobsStepsState string

// V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.Wckey.Flags.
type V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags string

// V0041OpenapiSlurmdbdQosResp defines model for v0.0.41_openapi_slurmdbd_qos_resp.
type V0041OpenapiSlurmdbdQosResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Qos List of QOS
	Qos []struct {
		// Description Arbitrary description
		Description *string `json:"description,omitempty"`

		// Flags Flags, to avoid modifying current values specify NOT_SET
		Flags *[]V0041OpenapiSlurmdbdQosRespQosFlags `json:"flags,omitempty"`

		// Id Unique ID
		Id     *int32 `json:"id,omitempty"`
		Limits *struct {
			// Factor LimitFactor
			Factor *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"factor,omitempty"`

			// GraceTime GraceTime
			GraceTime *int32 `json:"grace_time,omitempty"`
			Max       *struct {
				Accruing *struct {
					Per *struct {
						// Account MaxJobsAccruePerAccount
						Account *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"account,omitempty"`

						// User MaxJobsAccruePerUser
						User *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"accruing,omitempty"`
				ActiveJobs *struct {
					// Accruing GrpJobsAccrue
					Accruing *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"accruing,omitempty"`

					// Count GrpJobs
					Count *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"count,omitempty"`
				} `json:"active_jobs,omitempty"`
				Jobs *struct {
					ActiveJobs *struct {
						Per *struct {
							// Account MaxJobsPerAccount
							Account *struct {
								// Infinite True if number has been set to infinite; "set" and "number" will be ignored
								Infinite *bool `json:"infinite,omitempty"`

								// Number If "set" is True the number will be set with value; otherwise ignore number contents
								Number *int32 `json:"number,omitempty"`

								// Set True if number has been set; False if number is unset
								Set *bool `json:"set,omitempty"`
							} `json:"account,omitempty"`

							// User MaxJobsPerUser
							User *struct {
								// Infinite True if number has been set to infinite; "set" and "number" will be ignored
								Infinite *bool `json:"infinite,omitempty"`

								// Number If "set" is True the number will be set with value; otherwise ignore number contents
								Number *int32 `json:"number,omitempty"`

								// Set True if number has been set; False if number is unset
								Set *bool `json:"set,omitempty"`
							} `json:"user,omitempty"`
						} `json:"per,omitempty"`
					} `json:"active_jobs,omitempty"`
					Per *struct {
						// Account MaxSubmitJobsPerAccount
						Account *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"account,omitempty"`

						// User MaxSubmitJobsPerUser
						User *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"jobs,omitempty"`
				Tres *struct {
					Minutes *struct {
						Per *struct {
							// Account MaxTRESRunMinsPerAccount
							Account *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"account,omitempty"`

							// Job MaxTRESMinsPerJob
							Job *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"job,omitempty"`

							// Qos GrpTRESRunMins
							Qos *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"qos,omitempty"`

							// User MaxTRESRunMinsPerUser
							User *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"user,omitempty"`
						} `json:"per,omitempty"`
					} `json:"minutes,omitempty"`
					Per *struct {
						// Account MaxTRESPerAccount
						Account *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"account,omitempty"`

						// Job MaxTRESPerJob
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`

						// Node MaxTRESPerNode
						Node *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"node,omitempty"`

						// User MaxTRESPerUser
						User *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`

					// Total GrpTRES
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"tres,omitempty"`
				WallClock *struct {
					Per *struct {
						// Job MaxWallDurationPerJob
						Job *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"job,omitempty"`

						// Qos GrpWall
						Qos *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"qos,omitempty"`
					} `json:"per,omitempty"`
				} `json:"wall_clock,omitempty"`
			} `json:"max,omitempty"`
			Min *struct {
				// PriorityThreshold MinPrioThreshold
				PriorityThreshold *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"priority_threshold,omitempty"`
				Tres *struct {
					Per *struct {
						// Job MinTRES
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`
					} `json:"per,omitempty"`
				} `json:"tres,omitempty"`
			} `json:"min,omitempty"`
		} `json:"limits,omitempty"`

		// Name Name
		Name    *string `json:"name,omitempty"`
		Preempt *struct {
			// ExemptTime PreemptExemptTime
			ExemptTime *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"exempt_time,omitempty"`

			// List Other QOS's this QOS can preempt
			List *[]string `json:"list,omitempty"`

			// Mode PreemptMode
			Mode *[]V0041OpenapiSlurmdbdQosRespQosPreemptMode `json:"mode,omitempty"`
		} `json:"preempt,omitempty"`

		// Priority Priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// UsageFactor UsageFactor
		UsageFactor *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"usage_factor,omitempty"`

		// UsageThreshold UsageThreshold
		UsageThreshold *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"usage_threshold,omitempty"`
	} `json:"qos"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSlurmdbdQosRespQosFlags defines model for V0041OpenapiSlurmdbdQosResp.Qos.Flags.
type V0041OpenapiSlurmdbdQosRespQosFlags string

// V0041OpenapiSlurmdbdQosRespQosPreemptMode defines model for V0041OpenapiSlurmdbdQosResp.Qos.Preempt.Mode.
type V0041OpenapiSlurmdbdQosRespQosPreemptMode string

// V0041OpenapiTresResp defines model for v0.0.41_openapi_tres_resp.
type V0041OpenapiTresResp struct {
	// TRES TRES
	TRES []struct {
		// Count TRES count (0 if listed generically)
		Count *int64 `json:"count,omitempty"`

		// Id ID used in database
		Id *int32 `json:"id,omitempty"`

		// Name TRES name (if applicable)
		Name *string `json:"name,omitempty"`

		// Type TRES type (CPU, MEM, etc)
		Type string `json:"type"`
	} `json:"TRES"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiUsersResp defines model for v0.0.41_openapi_users_resp.
type V0041OpenapiUsersResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Users users
	Users []struct {
		// AdministratorLevel AdminLevel granted to the user
		AdministratorLevel *[]V0041OpenapiUsersRespUsersAdministratorLevel `json:"administrator_level,omitempty"`

		// Associations Associations created for this user
		Associations *[]struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"associations,omitempty"`

		// Coordinators Accounts this user is a coordinator for
		Coordinators *[]struct {
			// Direct Indicates whether the coordinator was directly assigned to this account
			Direct *bool `json:"direct,omitempty"`

			// Name User name
			Name string `json:"name"`
		} `json:"coordinators,omitempty"`
		Default *struct {
			// Account Default Account
			Account *string `json:"account,omitempty"`

			// Wckey Default WCKey
			Wckey *string `json:"wckey,omitempty"`
		} `json:"default,omitempty"`

		// Flags Flags associated with user
		Flags *[]V0041OpenapiUsersRespUsersFlags `json:"flags,omitempty"`

		// Name User name
		Name string `json:"name"`

		// OldName Previous user name
		OldName *string `json:"old_name,omitempty"`

		// Wckeys List of available WCKeys
		Wckeys *[]struct {
			// Accounting Accounting records containing related resource usage
			Accounting *[]struct {
				// TRES Trackable resources
				TRES *struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"TRES,omitempty"`
				Allocated *struct {
					// Seconds Number of cpu seconds allocated
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"allocated,omitempty"`

				// Id Association ID or Workload characterization key ID
				Id *int32 `json:"id,omitempty"`

				// Start When the record was started
				Start *int64 `json:"start,omitempty"`
			} `json:"accounting,omitempty"`

			// Cluster Cluster name
			Cluster string `json:"cluster"`

			// Flags Flags associated with the WCKey
			Flags *[]V0041OpenapiUsersRespUsersWckeysFlags `json:"flags,omitempty"`

			// Id Unique ID for this user-cluster-wckey combination
			Id *int32 `json:"id,omitempty"`

			// Name WCKey name
			Name string `json:"name"`

			// User User name
			User string `json:"user"`
		} `json:"wckeys,omitempty"`
	} `json:"users"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiUsersRespUsersAdministratorLevel defines model for V0041OpenapiUsersResp.Users.AdministratorLevel.
type V0041OpenapiUsersRespUsersAdministratorLevel string

// V0041OpenapiUsersRespUsersFlags defines model for V0041OpenapiUsersResp.Users.Flags.
type V0041OpenapiUsersRespUsersFlags string

// V0041OpenapiUsersRespUsersWckeysFlags defines model for V0041OpenapiUsersResp.Users.Wckeys.Flags.
type V0041OpenapiUsersRespUsersWckeysFlags string

// V0041OpenapiWckeyResp defines model for v0.0.41_openapi_wckey_resp.
type V0041OpenapiWckeyResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`

	// Wckeys wckeys
	Wckeys []struct {
		// Accounting Accounting records containing related resource usage
		Accounting *[]struct {
			// TRES Trackable resources
			TRES *struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"TRES,omitempty"`
			Allocated *struct {
				// Seconds Number of cpu seconds allocated
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"allocated,omitempty"`

			// Id Association ID or Workload characterization key ID
			Id *int32 `json:"id,omitempty"`

			// Start When the record was started
			Start *int64 `json:"start,omitempty"`
		} `json:"accounting,omitempty"`

		// Cluster Cluster name
		Cluster string `json:"cluster"`

		// Flags Flags associated with the WCKey
		Flags *[]V0041OpenapiWckeyRespWckeysFlags `json:"flags,omitempty"`

		// Id Unique ID for this user-cluster-wckey combination
		Id *int32 `json:"id,omitempty"`

		// Name WCKey name
		Name string `json:"name"`

		// User User name
		User string `json:"user"`
	} `json:"wckeys"`
}

// V0041OpenapiWckeyRespWckeysFlags defines model for V0041OpenapiWckeyResp.Wckeys.Flags.
type V0041OpenapiWckeyRespWckeysFlags string

// V0041UpdateNodeMsg defines model for v0.0.41_update_node_msg.
type V0041UpdateNodeMsg struct {
	// Address NodeAddr, used to establish a communication path
	Address *[]string `json:"address,omitempty"`

	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// CpuBind Default method for binding tasks to allocated CPUs
	CpuBind *int32 `json:"cpu_bind,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// Features Available features
	Features *[]string `json:"features,omitempty"`

	// FeaturesAct Currently active features
	FeaturesAct *[]string `json:"features_act,omitempty"`

	// Gres Generic resources
	Gres *string `json:"gres,omitempty"`

	// Hostname NodeHostname
	Hostname *[]string `json:"hostname,omitempty"`

	// Name NodeName
	Name *[]string `json:"name,omitempty"`

	// Reason Reason for node being DOWN or DRAINING
	Reason *string `json:"reason,omitempty"`

	// ReasonUid User ID to associate with the reason (needed if user root is sending message)
	ReasonUid *string `json:"reason_uid,omitempty"`

	// ResumeAfter Number of seconds after which to automatically resume DOWN or DRAINED node
	ResumeAfter *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"resume_after,omitempty"`

	// State New state to assign to the node
	State *[]V0041UpdateNodeMsgState `json:"state,omitempty"`

	// Weight Weight of the node for scheduling purposes
	Weight *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"weight,omitempty"`
}

// V0041UpdateNodeMsgState defines model for V0041UpdateNodeMsg.State.
type V0041UpdateNodeMsgState string

// SlurmV0041PostJobAllocateJSONBody defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBody struct {
	// Hetjob HetJob description
	Hetjob *[]struct {
		// Account Account associated with the job
		Account *string `json:"account,omitempty"`

		// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
		AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

		// AdminComment Arbitrary comment made by administrator
		AdminComment *string `json:"admin_comment,omitempty"`

		// AllocationNodeList Local node making the resource allocation
		AllocationNodeList *string `json:"allocation_node_list,omitempty"`

		// AllocationNodePort Port to send allocation confirmation to
		AllocationNodePort *int32 `json:"allocation_node_port,omitempty"`

		// Argv Arguments to the script
		Argv *[]string `json:"argv,omitempty"`

		// Array Job array index value specification
		Array *string `json:"array,omitempty"`

		// BatchFeatures Features required for batch script's node
		BatchFeatures *string `json:"batch_features,omitempty"`

		// BeginTime Defer the allocation of the job until the specified time (UNIX timestamp)
		BeginTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"begin_time,omitempty"`

		// BurstBuffer Burst buffer specifications
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
		ClusterConstraint *string `json:"cluster_constraint,omitempty"`

		// Clusters Clusters that a federated job can run on
		Clusters *string `json:"clusters,omitempty"`

		// Comment Arbitrary comment made by user
		Comment *string `json:"comment,omitempty"`

		// Constraints Comma separated list of features that are required
		Constraints *string `json:"constraints,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// ContainerId OCI container ID
		ContainerId *string `json:"container_id,omitempty"`

		// Contiguous True if job requires contiguous nodes
		Contiguous *bool `json:"contiguous,omitempty"`

		// CoreSpecification Specialized core count
		CoreSpecification *int32 `json:"core_specification,omitempty"`

		// CpuBinding Method for binding tasks to allocated CPUs
		CpuBinding *string `json:"cpu_binding,omitempty"`

		// CpuBindingFlags Flags for CPU binding
		CpuBindingFlags *[]SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

		// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
		CpuFrequency *string `json:"cpu_frequency,omitempty"`

		// CpusPerTask Number of CPUs required by each task
		CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

		// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
		CpusPerTres *string `json:"cpus_per_tres,omitempty"`

		// Crontab Specification for scrontab job
		Crontab *struct {
			// Command Command to run
			Command *string `json:"command,omitempty"`

			// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
			DayOfMonth *string `json:"day_of_month,omitempty"`

			// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
			DayOfWeek *string `json:"day_of_week,omitempty"`

			// Flags Flags
			Flags *[]SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags `json:"flags,omitempty"`

			// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
			Hour *string `json:"hour,omitempty"`
			Line *struct {
				// End End of this entry in file
				End *int32 `json:"end,omitempty"`

				// Start Start of this entry in file
				Start *int32 `json:"start,omitempty"`
			} `json:"line,omitempty"`

			// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
			Minute *string `json:"minute,omitempty"`

			// Month Ranged string specifying eligible month values (e.g. 0-5,12)
			Month *string `json:"month,omitempty"`

			// Specification Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
			Specification *string `json:"specification,omitempty"`
		} `json:"crontab,omitempty"`

		// CurrentWorkingDirectory Working directory to use for the job
		CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

		// Deadline Latest time that the job may start (UNIX timestamp)
		Deadline *int64 `json:"deadline,omitempty"`

		// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
		DelayBoot *int32 `json:"delay_boot,omitempty"`

		// Dependency Other jobs that must meet certain criteria before this job can start
		Dependency *string `json:"dependency,omitempty"`

		// Distribution Layout
		Distribution *string `json:"distribution,omitempty"`

		// DistributionPlaneSize Plane size specification when distribution specifies plane
		DistributionPlaneSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"distribution_plane_size,omitempty"`

		// EndTime Expected end time (UNIX timestamp)
		EndTime *int64 `json:"end_time,omitempty"`

		// Environment Environment variables to be set for the job
		Environment *[]string `json:"environment,omitempty"`

		// ExcludedNodes Comma separated list of nodes that may not be used
		ExcludedNodes *[]string `json:"excluded_nodes,omitempty"`
		// Deprecated:
		Exclusive *[]SlurmV0041PostJobAllocateJSONBodyHetjobExclusive `json:"exclusive,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// Flags Job flags
		Flags *[]SlurmV0041PostJobAllocateJSONBodyHetjobFlags `json:"flags,omitempty"`

		// GroupId Group ID of the user that owns the job
		GroupId *string `json:"group_id,omitempty"`

		// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
		HetjobGroup *int32 `json:"hetjob_group,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// Immediate If true, exit if resources are not available within the time period specified
		Immediate *bool `json:"immediate,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// KillOnNodeFail If true, kill job on node failure
		KillOnNodeFail *bool `json:"kill_on_node_fail,omitempty"`

		// KillWarningDelay Number of seconds before end time to send the warning signal
		KillWarningDelay *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"kill_warning_delay,omitempty"`

		// KillWarningFlags Flags related to job signals
		KillWarningFlags *[]SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags `json:"kill_warning_flags,omitempty"`

		// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
		KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`

		// MailType Mail event type(s)
		MailType *[]SlurmV0041PostJobAllocateJSONBodyHetjobMailType `json:"mail_type,omitempty"`

		// MailUser User to receive email notifications
		MailUser *string `json:"mail_user,omitempty"`

		// MaximumCpus Maximum number of CPUs required
		MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

		// MaximumNodes Maximum node count
		MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

		// McsLabel Multi-Category Security label on the job
		McsLabel *string `json:"mcs_label,omitempty"`

		// MemoryBinding Binding map for map/mask_cpu
		MemoryBinding *string `json:"memory_binding,omitempty"`

		// MemoryBindingType Method for binding tasks to memory
		MemoryBindingType *[]SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType `json:"memory_binding_type,omitempty"`

		// MemoryPerCpu Minimum memory in megabytes per allocated CPU
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Minimum memory in megabytes per allocated CPU
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`

		// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
		MemoryPerTres *string `json:"memory_per_tres,omitempty"`

		// MinimumBoardsPerNode Boards per node required
		MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

		// MinimumCpus Minimum number of CPUs required
		MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

		// MinimumCpusPerNode Minimum number of CPUs per node
		MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

		// MinimumNodes Minimum node count
		MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

		// MinimumSocketsPerBoard Sockets per board required
		MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Network Network specs for job step
		Network *string `json:"network,omitempty"`

		// Nice Requested job priority change
		Nice *int32 `json:"nice,omitempty"`

		// Nodes Node count range specification (e.g. 1-15:4)
		Nodes *string `json:"nodes,omitempty"`

		// NtasksPerTres Number of tasks that can access each GPU
		NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

		// OpenMode Open mode used for stdout and stderr files
		OpenMode *[]SlurmV0041PostJobAllocateJSONBodyHetjobOpenMode `json:"open_mode,omitempty"`

		// Overcommit Overcommit resources
		Overcommit *bool `json:"overcommit,omitempty"`
		// Deprecated:
		Oversubscribe *bool `json:"oversubscribe,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`
		// Deprecated:
		PowerFlags *[]interface{} `json:"power_flags,omitempty"`

		// Prefer Comma separated list of features that are preferred but not required
		Prefer *string `json:"prefer,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Profile Profile used by the acct_gather_profile plugin
		Profile *[]SlurmV0041PostJobAllocateJSONBodyHetjobProfile `json:"profile,omitempty"`

		// Qos Quality of Service assigned to the job
		Qos *string `json:"qos,omitempty"`

		// Reboot Node reboot requested before start
		Reboot *bool `json:"reboot,omitempty"`

		// Requeue Determines whether the job may be requeued
		Requeue *bool `json:"requeue,omitempty"`

		// RequiredNodes Comma separated list of required nodes
		RequiredNodes *[]string `json:"required_nodes,omitempty"`

		// RequiredSwitches Maximum number of switches
		RequiredSwitches *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"required_switches,omitempty"`

		// Reservation Name of reservation to use
		Reservation *string `json:"reservation,omitempty"`

		// ReservePorts Port to send various notification msg to
		ReservePorts *int32 `json:"reserve_ports,omitempty"`

		// ResvMpiPorts Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
		ResvMpiPorts *int32 `json:"resv_mpi_ports,omitempty"`
		Rlimits      *struct {
			// As Address space limit.
			As *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"as,omitempty"`

			// Core Largest core file that can be created, in bytes.
			Core *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"core,omitempty"`

			// Cpu Per-process CPU limit, in seconds.
			Cpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu,omitempty"`

			// Data Maximum size of data segment, in bytes.
			Data *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"data,omitempty"`

			// Fsize Largest file that can be created, in bytes.
			Fsize *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"fsize,omitempty"`

			// Memlock Locked-in-memory address space
			Memlock *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memlock,omitempty"`

			// Nofile Number of open files.
			Nofile *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nofile,omitempty"`

			// Nproc Number of processes.
			Nproc *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nproc,omitempty"`

			// Rss Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size will be more likely to have physical memory taken from them.
			Rss *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"rss,omitempty"`

			// Stack Maximum size of stack segment, in bytes.
			Stack *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"stack,omitempty"`
		} `json:"rlimits,omitempty"`

		// Script Job batch script; only the first component in a HetJob is populated or honored
		Script *string `json:"script,omitempty"`

		// SegmentSize Segment size for topology/block
		SegmentSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"segment_size,omitempty"`

		// SelinuxContext SELinux context
		SelinuxContext *string `json:"selinux_context,omitempty"`

		// Shared How the job can share resources with other jobs, if at all
		Shared *[]SlurmV0041PostJobAllocateJSONBodyHetjobShared `json:"shared,omitempty"`

		// SiteFactor Site-specific priority factor
		SiteFactor *int32 `json:"site_factor,omitempty"`

		// SocketsPerNode Sockets per node required
		SocketsPerNode *int32 `json:"sockets_per_node,omitempty"`

		// SpankEnvironment Environment variables for job prolog/epilog scripts as set by SPANK plugins
		SpankEnvironment *[]string `json:"spank_environment,omitempty"`

		// StandardError Path to stderr file
		StandardError *string `json:"standard_error,omitempty"`

		// StandardInput Path to stdin file
		StandardInput *string `json:"standard_input,omitempty"`

		// StandardOutput Path to stdout file
		StandardOutput *string `json:"standard_output,omitempty"`

		// Tasks Number of tasks
		Tasks *int32 `json:"tasks,omitempty"`

		// TasksPerBoard Number of tasks to invoke on each board
		TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

		// TasksPerCore Number of tasks to invoke on each core
		TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

		// TasksPerNode Number of tasks to invoke on each node
		TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

		// TasksPerSocket Number of tasks to invoke on each socket
		TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

		// TemporaryDiskPerNode Minimum tmp disk space required per node
		TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

		// ThreadSpecification Specialized thread count
		ThreadSpecification *int32 `json:"thread_specification,omitempty"`

		// ThreadsPerCore Threads per core required
		ThreadsPerCore *int32 `json:"threads_per_core,omitempty"`

		// TimeLimit Maximum run time in minutes
		TimeLimit *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Minimum run time in minutes
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`

		// TresBind Task to TRES binding directives
		TresBind *string `json:"tres_bind,omitempty"`

		// TresFreq TRES frequency directives
		TresFreq *string `json:"tres_freq,omitempty"`

		// TresPerJob Comma separated list of TRES=# values to be allocated for every job
		TresPerJob *string `json:"tres_per_job,omitempty"`

		// TresPerNode Comma separated list of TRES=# values to be allocated for every node
		TresPerNode *string `json:"tres_per_node,omitempty"`

		// TresPerSocket Comma separated list of TRES=# values to be allocated for every socket
		TresPerSocket *string `json:"tres_per_socket,omitempty"`

		// TresPerTask Comma separated list of TRES=# values to be allocated for every task
		TresPerTask *string `json:"tres_per_task,omitempty"`

		// UserId User ID that owns the job
		UserId *string `json:"user_id,omitempty"`

		// WaitAllNodes If true, wait to start until after all nodes have booted
		WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

		// WaitForSwitch Maximum time to wait for switches in seconds
		WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

		// Wckey Workload characterization key
		Wckey *string `json:"wckey,omitempty"`

		// X11 X11 forwarding options
		X11 *[]SlurmV0041PostJobAllocateJSONBodyHetjobX11 `json:"x11,omitempty"`

		// X11MagicCookie Magic cookie for X11 forwarding
		X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

		// X11TargetHost Hostname or UNIX socket if x11_target_port=0
		X11TargetHost *string `json:"x11_target_host,omitempty"`

		// X11TargetPort TCP port
		X11TargetPort *int32 `json:"x11_target_port,omitempty"`
	} `json:"hetjob,omitempty"`

	// Job Job description
	Job *struct {
		// Account Account associated with the job
		Account *string `json:"account,omitempty"`

		// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
		AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

		// AdminComment Arbitrary comment made by administrator
		AdminComment *string `json:"admin_comment,omitempty"`

		// AllocationNodeList Local node making the resource allocation
		AllocationNodeList *string `json:"allocation_node_list,omitempty"`

		// AllocationNodePort Port to send allocation confirmation to
		AllocationNodePort *int32 `json:"allocation_node_port,omitempty"`

		// Argv Arguments to the script
		Argv *[]string `json:"argv,omitempty"`

		// Array Job array index value specification
		Array *string `json:"array,omitempty"`

		// BatchFeatures Features required for batch script's node
		BatchFeatures *string `json:"batch_features,omitempty"`

		// BeginTime Defer the allocation of the job until the specified time (UNIX timestamp)
		BeginTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"begin_time,omitempty"`

		// BurstBuffer Burst buffer specifications
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
		ClusterConstraint *string `json:"cluster_constraint,omitempty"`

		// Clusters Clusters that a federated job can run on
		Clusters *string `json:"clusters,omitempty"`

		// Comment Arbitrary comment made by user
		Comment *string `json:"comment,omitempty"`

		// Constraints Comma separated list of features that are required
		Constraints *string `json:"constraints,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// ContainerId OCI container ID
		ContainerId *string `json:"container_id,omitempty"`

		// Contiguous True if job requires contiguous nodes
		Contiguous *bool `json:"contiguous,omitempty"`

		// CoreSpecification Specialized core count
		CoreSpecification *int32 `json:"core_specification,omitempty"`

		// CpuBinding Method for binding tasks to allocated CPUs
		CpuBinding *string `json:"cpu_binding,omitempty"`

		// CpuBindingFlags Flags for CPU binding
		CpuBindingFlags *[]SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

		// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
		CpuFrequency *string `json:"cpu_frequency,omitempty"`

		// CpusPerTask Number of CPUs required by each task
		CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

		// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
		CpusPerTres *string `json:"cpus_per_tres,omitempty"`

		// Crontab Specification for scrontab job
		Crontab *struct {
			// Command Command to run
			Command *string `json:"command,omitempty"`

			// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
			DayOfMonth *string `json:"day_of_month,omitempty"`

			// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
			DayOfWeek *string `json:"day_of_week,omitempty"`

			// Flags Flags
			Flags *[]SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags `json:"flags,omitempty"`

			// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
			Hour *string `json:"hour,omitempty"`
			Line *struct {
				// End End of this entry in file
				End *int32 `json:"end,omitempty"`

				// Start Start of this entry in file
				Start *int32 `json:"start,omitempty"`
			} `json:"line,omitempty"`

			// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
			Minute *string `json:"minute,omitempty"`

			// Month Ranged string specifying eligible month values (e.g. 0-5,12)
			Month *string `json:"month,omitempty"`

			// Specification Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
			Specification *string `json:"specification,omitempty"`
		} `json:"crontab,omitempty"`

		// CurrentWorkingDirectory Working directory to use for the job
		CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

		// Deadline Latest time that the job may start (UNIX timestamp)
		Deadline *int64 `json:"deadline,omitempty"`

		// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
		DelayBoot *int32 `json:"delay_boot,omitempty"`

		// Dependency Other jobs that must meet certain criteria before this job can start
		Dependency *string `json:"dependency,omitempty"`

		// Distribution Layout
		Distribution *string `json:"distribution,omitempty"`

		// DistributionPlaneSize Plane size specification when distribution specifies plane
		DistributionPlaneSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"distribution_plane_size,omitempty"`

		// EndTime Expected end time (UNIX timestamp)
		EndTime *int64 `json:"end_time,omitempty"`

		// Environment Environment variables to be set for the job
		Environment *[]string `json:"environment,omitempty"`

		// ExcludedNodes Comma separated list of nodes that may not be used
		ExcludedNodes *[]string `json:"excluded_nodes,omitempty"`
		// Deprecated:
		Exclusive *[]SlurmV0041PostJobAllocateJSONBodyJobExclusive `json:"exclusive,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// Flags Job flags
		Flags *[]SlurmV0041PostJobAllocateJSONBodyJobFlags `json:"flags,omitempty"`

		// GroupId Group ID of the user that owns the job
		GroupId *string `json:"group_id,omitempty"`

		// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
		HetjobGroup *int32 `json:"hetjob_group,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// Immediate If true, exit if resources are not available within the time period specified
		Immediate *bool `json:"immediate,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// KillOnNodeFail If true, kill job on node failure
		KillOnNodeFail *bool `json:"kill_on_node_fail,omitempty"`

		// KillWarningDelay Number of seconds before end time to send the warning signal
		KillWarningDelay *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"kill_warning_delay,omitempty"`

		// KillWarningFlags Flags related to job signals
		KillWarningFlags *[]SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags `json:"kill_warning_flags,omitempty"`

		// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
		KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`

		// MailType Mail event type(s)
		MailType *[]SlurmV0041PostJobAllocateJSONBodyJobMailType `json:"mail_type,omitempty"`

		// MailUser User to receive email notifications
		MailUser *string `json:"mail_user,omitempty"`

		// MaximumCpus Maximum number of CPUs required
		MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

		// MaximumNodes Maximum node count
		MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

		// McsLabel Multi-Category Security label on the job
		McsLabel *string `json:"mcs_label,omitempty"`

		// MemoryBinding Binding map for map/mask_cpu
		MemoryBinding *string `json:"memory_binding,omitempty"`

		// MemoryBindingType Method for binding tasks to memory
		MemoryBindingType *[]SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType `json:"memory_binding_type,omitempty"`

		// MemoryPerCpu Minimum memory in megabytes per allocated CPU
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Minimum memory in megabytes per allocated CPU
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`

		// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
		MemoryPerTres *string `json:"memory_per_tres,omitempty"`

		// MinimumBoardsPerNode Boards per node required
		MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

		// MinimumCpus Minimum number of CPUs required
		MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

		// MinimumCpusPerNode Minimum number of CPUs per node
		MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

		// MinimumNodes Minimum node count
		MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

		// MinimumSocketsPerBoard Sockets per board required
		MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Network Network specs for job step
		Network *string `json:"network,omitempty"`

		// Nice Requested job priority change
		Nice *int32 `json:"nice,omitempty"`

		// Nodes Node count range specification (e.g. 1-15:4)
		Nodes *string `json:"nodes,omitempty"`

		// NtasksPerTres Number of tasks that can access each GPU
		NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

		// OpenMode Open mode used for stdout and stderr files
		OpenMode *[]SlurmV0041PostJobAllocateJSONBodyJobOpenMode `json:"open_mode,omitempty"`

		// Overcommit Overcommit resources
		Overcommit *bool `json:"overcommit,omitempty"`
		// Deprecated:
		Oversubscribe *bool `json:"oversubscribe,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`
		// Deprecated:
		PowerFlags *[]interface{} `json:"power_flags,omitempty"`

		// Prefer Comma separated list of features that are preferred but not required
		Prefer *string `json:"prefer,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Profile Profile used by the acct_gather_profile plugin
		Profile *[]SlurmV0041PostJobAllocateJSONBodyJobProfile `json:"profile,omitempty"`

		// Qos Quality of Service assigned to the job
		Qos *string `json:"qos,omitempty"`

		// Reboot Node reboot requested before start
		Reboot *bool `json:"reboot,omitempty"`

		// Requeue Determines whether the job may be requeued
		Requeue *bool `json:"requeue,omitempty"`

		// RequiredNodes Comma separated list of required nodes
		RequiredNodes *[]string `json:"required_nodes,omitempty"`

		// RequiredSwitches Maximum number of switches
		RequiredSwitches *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"required_switches,omitempty"`

		// Reservation Name of reservation to use
		Reservation *string `json:"reservation,omitempty"`

		// ReservePorts Port to send various notification msg to
		ReservePorts *int32 `json:"reserve_ports,omitempty"`

		// ResvMpiPorts Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
		ResvMpiPorts *int32 `json:"resv_mpi_ports,omitempty"`
		Rlimits      *struct {
			// As Address space limit.
			As *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"as,omitempty"`

			// Core Largest core file that can be created, in bytes.
			Core *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"core,omitempty"`

			// Cpu Per-process CPU limit, in seconds.
			Cpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu,omitempty"`

			// Data Maximum size of data segment, in bytes.
			Data *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"data,omitempty"`

			// Fsize Largest file that can be created, in bytes.
			Fsize *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"fsize,omitempty"`

			// Memlock Locked-in-memory address space
			Memlock *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memlock,omitempty"`

			// Nofile Number of open files.
			Nofile *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nofile,omitempty"`

			// Nproc Number of processes.
			Nproc *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nproc,omitempty"`

			// Rss Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size will be more likely to have physical memory taken from them.
			Rss *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"rss,omitempty"`

			// Stack Maximum size of stack segment, in bytes.
			Stack *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"stack,omitempty"`
		} `json:"rlimits,omitempty"`

		// Script Job batch script; only the first component in a HetJob is populated or honored
		Script *string `json:"script,omitempty"`

		// SegmentSize Segment size for topology/block
		SegmentSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"segment_size,omitempty"`

		// SelinuxContext SELinux context
		SelinuxContext *string `json:"selinux_context,omitempty"`

		// Shared How the job can share resources with other jobs, if at all
		Shared *[]SlurmV0041PostJobAllocateJSONBodyJobShared `json:"shared,omitempty"`

		// SiteFactor Site-specific priority factor
		SiteFactor *int32 `json:"site_factor,omitempty"`

		// SocketsPerNode Sockets per node required
		SocketsPerNode *int32 `json:"sockets_per_node,omitempty"`

		// SpankEnvironment Environment variables for job prolog/epilog scripts as set by SPANK plugins
		SpankEnvironment *[]string `json:"spank_environment,omitempty"`

		// StandardError Path to stderr file
		StandardError *string `json:"standard_error,omitempty"`

		// StandardInput Path to stdin file
		StandardInput *string `json:"standard_input,omitempty"`

		// StandardOutput Path to stdout file
		StandardOutput *string `json:"standard_output,omitempty"`

		// Tasks Number of tasks
		Tasks *int32 `json:"tasks,omitempty"`

		// TasksPerBoard Number of tasks to invoke on each board
		TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

		// TasksPerCore Number of tasks to invoke on each core
		TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

		// TasksPerNode Number of tasks to invoke on each node
		TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

		// TasksPerSocket Number of tasks to invoke on each socket
		TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

		// TemporaryDiskPerNode Minimum tmp disk space required per node
		TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

		// ThreadSpecification Specialized thread count
		ThreadSpecification *int32 `json:"thread_specification,omitempty"`

		// ThreadsPerCore Threads per core required
		ThreadsPerCore *int32 `json:"threads_per_core,omitempty"`

		// TimeLimit Maximum run time in minutes
		TimeLimit *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Minimum run time in minutes
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`

		// TresBind Task to TRES binding directives
		TresBind *string `json:"tres_bind,omitempty"`

		// TresFreq TRES frequency directives
		TresFreq *string `json:"tres_freq,omitempty"`

		// TresPerJob Comma separated list of TRES=# values to be allocated for every job
		TresPerJob *string `json:"tres_per_job,omitempty"`

		// TresPerNode Comma separated list of TRES=# values to be allocated for every node
		TresPerNode *string `json:"tres_per_node,omitempty"`

		// TresPerSocket Comma separated list of TRES=# values to be allocated for every socket
		TresPerSocket *string `json:"tres_per_socket,omitempty"`

		// TresPerTask Comma separated list of TRES=# values to be allocated for every task
		TresPerTask *string `json:"tres_per_task,omitempty"`

		// UserId User ID that owns the job
		UserId *string `json:"user_id,omitempty"`

		// WaitAllNodes If true, wait to start until after all nodes have booted
		WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

		// WaitForSwitch Maximum time to wait for switches in seconds
		WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

		// Wckey Workload characterization key
		Wckey *string `json:"wckey,omitempty"`

		// X11 X11 forwarding options
		X11 *[]SlurmV0041PostJobAllocateJSONBodyJobX11 `json:"x11,omitempty"`

		// X11MagicCookie Magic cookie for X11 forwarding
		X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

		// X11TargetHost Hostname or UNIX socket if x11_target_port=0
		X11TargetHost *string `json:"x11_target_host,omitempty"`

		// X11TargetPort TCP port
		X11TargetPort *int32 `json:"x11_target_port,omitempty"`
	} `json:"job,omitempty"`
}

// SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags string

// SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags string

// SlurmV0041PostJobAllocateJSONBodyHetjobExclusive defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobExclusive string

// SlurmV0041PostJobAllocateJSONBodyHetjobFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobFlags string

// SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags string

// SlurmV0041PostJobAllocateJSONBodyHetjobMailType defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobMailType string

// SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType string

// SlurmV0041PostJobAllocateJSONBodyHetjobOpenMode defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobOpenMode string

// SlurmV0041PostJobAllocateJSONBodyHetjobProfile defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobProfile string

// SlurmV0041PostJobAllocateJSONBodyHetjobShared defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobShared string

// SlurmV0041PostJobAllocateJSONBodyHetjobX11 defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobX11 string

// SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags string

// SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags string

// SlurmV0041PostJobAllocateJSONBodyJobExclusive defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobExclusive string

// SlurmV0041PostJobAllocateJSONBodyJobFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobFlags string

// SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags string

// SlurmV0041PostJobAllocateJSONBodyJobMailType defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobMailType string

// SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType string

// SlurmV0041PostJobAllocateJSONBodyJobOpenMode defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobOpenMode string

// SlurmV0041PostJobAllocateJSONBodyJobProfile defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobProfile string

// SlurmV0041PostJobAllocateJSONBodyJobShared defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobShared string

// SlurmV0041PostJobAllocateJSONBodyJobX11 defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobX11 string

// SlurmV0041PostJobSubmitJSONBody defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBody struct {
	// Job Job description
	Job *struct {
		// Account Account associated with the job
		Account *string `json:"account,omitempty"`

		// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
		AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

		// AdminComment Arbitrary comment made by administrator
		AdminComment *string `json:"admin_comment,omitempty"`

		// AllocationNodeList Local node making the resource allocation
		AllocationNodeList *string `json:"allocation_node_list,omitempty"`

		// AllocationNodePort Port to send allocation confirmation to
		AllocationNodePort *int32 `json:"allocation_node_port,omitempty"`

		// Argv Arguments to the script
		Argv *[]string `json:"argv,omitempty"`

		// Array Job array index value specification
		Array *string `json:"array,omitempty"`

		// BatchFeatures Features required for batch script's node
		BatchFeatures *string `json:"batch_features,omitempty"`

		// BeginTime Defer the allocation of the job until the specified time (UNIX timestamp)
		BeginTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"begin_time,omitempty"`

		// BurstBuffer Burst buffer specifications
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
		ClusterConstraint *string `json:"cluster_constraint,omitempty"`

		// Clusters Clusters that a federated job can run on
		Clusters *string `json:"clusters,omitempty"`

		// Comment Arbitrary comment made by user
		Comment *string `json:"comment,omitempty"`

		// Constraints Comma separated list of features that are required
		Constraints *string `json:"constraints,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// ContainerId OCI container ID
		ContainerId *string `json:"container_id,omitempty"`

		// Contiguous True if job requires contiguous nodes
		Contiguous *bool `json:"contiguous,omitempty"`

		// CoreSpecification Specialized core count
		CoreSpecification *int32 `json:"core_specification,omitempty"`

		// CpuBinding Method for binding tasks to allocated CPUs
		CpuBinding *string `json:"cpu_binding,omitempty"`

		// CpuBindingFlags Flags for CPU binding
		CpuBindingFlags *[]SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

		// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
		CpuFrequency *string `json:"cpu_frequency,omitempty"`

		// CpusPerTask Number of CPUs required by each task
		CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

		// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
		CpusPerTres *string `json:"cpus_per_tres,omitempty"`

		// Crontab Specification for scrontab job
		Crontab *struct {
			// Command Command to run
			Command *string `json:"command,omitempty"`

			// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
			DayOfMonth *string `json:"day_of_month,omitempty"`

			// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
			DayOfWeek *string `json:"day_of_week,omitempty"`

			// Flags Flags
			Flags *[]SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags `json:"flags,omitempty"`

			// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
			Hour *string `json:"hour,omitempty"`
			Line *struct {
				// End End of this entry in file
				End *int32 `json:"end,omitempty"`

				// Start Start of this entry in file
				Start *int32 `json:"start,omitempty"`
			} `json:"line,omitempty"`

			// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
			Minute *string `json:"minute,omitempty"`

			// Month Ranged string specifying eligible month values (e.g. 0-5,12)
			Month *string `json:"month,omitempty"`

			// Specification Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
			Specification *string `json:"specification,omitempty"`
		} `json:"crontab,omitempty"`

		// CurrentWorkingDirectory Working directory to use for the job
		CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

		// Deadline Latest time that the job may start (UNIX timestamp)
		Deadline *int64 `json:"deadline,omitempty"`

		// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
		DelayBoot *int32 `json:"delay_boot,omitempty"`

		// Dependency Other jobs that must meet certain criteria before this job can start
		Dependency *string `json:"dependency,omitempty"`

		// Distribution Layout
		Distribution *string `json:"distribution,omitempty"`

		// DistributionPlaneSize Plane size specification when distribution specifies plane
		DistributionPlaneSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"distribution_plane_size,omitempty"`

		// EndTime Expected end time (UNIX timestamp)
		EndTime *int64 `json:"end_time,omitempty"`

		// Environment Environment variables to be set for the job
		Environment *[]string `json:"environment,omitempty"`

		// ExcludedNodes Comma separated list of nodes that may not be used
		ExcludedNodes *[]string `json:"excluded_nodes,omitempty"`
		// Deprecated:
		Exclusive *[]SlurmV0041PostJobSubmitJSONBodyJobExclusive `json:"exclusive,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// Flags Job flags
		Flags *[]SlurmV0041PostJobSubmitJSONBodyJobFlags `json:"flags,omitempty"`

		// GroupId Group ID of the user that owns the job
		GroupId *string `json:"group_id,omitempty"`

		// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
		HetjobGroup *int32 `json:"hetjob_group,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// Immediate If true, exit if resources are not available within the time period specified
		Immediate *bool `json:"immediate,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// KillOnNodeFail If true, kill job on node failure
		KillOnNodeFail *bool `json:"kill_on_node_fail,omitempty"`

		// KillWarningDelay Number of seconds before end time to send the warning signal
		KillWarningDelay *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"kill_warning_delay,omitempty"`

		// KillWarningFlags Flags related to job signals
		KillWarningFlags *[]SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags `json:"kill_warning_flags,omitempty"`

		// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
		KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`

		// MailType Mail event type(s)
		MailType *[]SlurmV0041PostJobSubmitJSONBodyJobMailType `json:"mail_type,omitempty"`

		// MailUser User to receive email notifications
		MailUser *string `json:"mail_user,omitempty"`

		// MaximumCpus Maximum number of CPUs required
		MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

		// MaximumNodes Maximum node count
		MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

		// McsLabel Multi-Category Security label on the job
		McsLabel *string `json:"mcs_label,omitempty"`

		// MemoryBinding Binding map for map/mask_cpu
		MemoryBinding *string `json:"memory_binding,omitempty"`

		// MemoryBindingType Method for binding tasks to memory
		MemoryBindingType *[]SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType `json:"memory_binding_type,omitempty"`

		// MemoryPerCpu Minimum memory in megabytes per allocated CPU
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Minimum memory in megabytes per allocated CPU
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`

		// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
		MemoryPerTres *string `json:"memory_per_tres,omitempty"`

		// MinimumBoardsPerNode Boards per node required
		MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

		// MinimumCpus Minimum number of CPUs required
		MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

		// MinimumCpusPerNode Minimum number of CPUs per node
		MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

		// MinimumNodes Minimum node count
		MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

		// MinimumSocketsPerBoard Sockets per board required
		MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Network Network specs for job step
		Network *string `json:"network,omitempty"`

		// Nice Requested job priority change
		Nice *int32 `json:"nice,omitempty"`

		// Nodes Node count range specification (e.g. 1-15:4)
		Nodes *string `json:"nodes,omitempty"`

		// NtasksPerTres Number of tasks that can access each GPU
		NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

		// OpenMode Open mode used for stdout and stderr files
		OpenMode *[]SlurmV0041PostJobSubmitJSONBodyJobOpenMode `json:"open_mode,omitempty"`

		// Overcommit Overcommit resources
		Overcommit *bool `json:"overcommit,omitempty"`
		// Deprecated:
		Oversubscribe *bool `json:"oversubscribe,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`
		// Deprecated:
		PowerFlags *[]interface{} `json:"power_flags,omitempty"`

		// Prefer Comma separated list of features that are preferred but not required
		Prefer *string `json:"prefer,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Profile Profile used by the acct_gather_profile plugin
		Profile *[]SlurmV0041PostJobSubmitJSONBodyJobProfile `json:"profile,omitempty"`

		// Qos Quality of Service assigned to the job
		Qos *string `json:"qos,omitempty"`

		// Reboot Node reboot requested before start
		Reboot *bool `json:"reboot,omitempty"`

		// Requeue Determines whether the job may be requeued
		Requeue *bool `json:"requeue,omitempty"`

		// RequiredNodes Comma separated list of required nodes
		RequiredNodes *[]string `json:"required_nodes,omitempty"`

		// RequiredSwitches Maximum number of switches
		RequiredSwitches *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"required_switches,omitempty"`

		// Reservation Name of reservation to use
		Reservation *string `json:"reservation,omitempty"`

		// ReservePorts Port to send various notification msg to
		ReservePorts *int32 `json:"reserve_ports,omitempty"`

		// ResvMpiPorts Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
		ResvMpiPorts *int32 `json:"resv_mpi_ports,omitempty"`
		Rlimits      *struct {
			// As Address space limit.
			As *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"as,omitempty"`

			// Core Largest core file that can be created, in bytes.
			Core *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"core,omitempty"`

			// Cpu Per-process CPU limit, in seconds.
			Cpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu,omitempty"`

			// Data Maximum size of data segment, in bytes.
			Data *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"data,omitempty"`

			// Fsize Largest file that can be created, in bytes.
			Fsize *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"fsize,omitempty"`

			// Memlock Locked-in-memory address space
			Memlock *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memlock,omitempty"`

			// Nofile Number of open files.
			Nofile *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nofile,omitempty"`

			// Nproc Number of processes.
			Nproc *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nproc,omitempty"`

			// Rss Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size will be more likely to have physical memory taken from them.
			Rss *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"rss,omitempty"`

			// Stack Maximum size of stack segment, in bytes.
			Stack *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"stack,omitempty"`
		} `json:"rlimits,omitempty"`

		// Script Job batch script; only the first component in a HetJob is populated or honored
		Script *string `json:"script,omitempty"`

		// SegmentSize Segment size for topology/block
		SegmentSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"segment_size,omitempty"`

		// SelinuxContext SELinux context
		SelinuxContext *string `json:"selinux_context,omitempty"`

		// Shared How the job can share resources with other jobs, if at all
		Shared *[]SlurmV0041PostJobSubmitJSONBodyJobShared `json:"shared,omitempty"`

		// SiteFactor Site-specific priority factor
		SiteFactor *int32 `json:"site_factor,omitempty"`

		// SocketsPerNode Sockets per node required
		SocketsPerNode *int32 `json:"sockets_per_node,omitempty"`

		// SpankEnvironment Environment variables for job prolog/epilog scripts as set by SPANK plugins
		SpankEnvironment *[]string `json:"spank_environment,omitempty"`

		// StandardError Path to stderr file
		StandardError *string `json:"standard_error,omitempty"`

		// StandardInput Path to stdin file
		StandardInput *string `json:"standard_input,omitempty"`

		// StandardOutput Path to stdout file
		StandardOutput *string `json:"standard_output,omitempty"`

		// Tasks Number of tasks
		Tasks *int32 `json:"tasks,omitempty"`

		// TasksPerBoard Number of tasks to invoke on each board
		TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

		// TasksPerCore Number of tasks to invoke on each core
		TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

		// TasksPerNode Number of tasks to invoke on each node
		TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

		// TasksPerSocket Number of tasks to invoke on each socket
		TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

		// TemporaryDiskPerNode Minimum tmp disk space required per node
		TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

		// ThreadSpecification Specialized thread count
		ThreadSpecification *int32 `json:"thread_specification,omitempty"`

		// ThreadsPerCore Threads per core required
		ThreadsPerCore *int32 `json:"threads_per_core,omitempty"`

		// TimeLimit Maximum run time in minutes
		TimeLimit *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Minimum run time in minutes
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`

		// TresBind Task to TRES binding directives
		TresBind *string `json:"tres_bind,omitempty"`

		// TresFreq TRES frequency directives
		TresFreq *string `json:"tres_freq,omitempty"`

		// TresPerJob Comma separated list of TRES=# values to be allocated for every job
		TresPerJob *string `json:"tres_per_job,omitempty"`

		// TresPerNode Comma separated list of TRES=# values to be allocated for every node
		TresPerNode *string `json:"tres_per_node,omitempty"`

		// TresPerSocket Comma separated list of TRES=# values to be allocated for every socket
		TresPerSocket *string `json:"tres_per_socket,omitempty"`

		// TresPerTask Comma separated list of TRES=# values to be allocated for every task
		TresPerTask *string `json:"tres_per_task,omitempty"`

		// UserId User ID that owns the job
		UserId *string `json:"user_id,omitempty"`

		// WaitAllNodes If true, wait to start until after all nodes have booted
		WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

		// WaitForSwitch Maximum time to wait for switches in seconds
		WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

		// Wckey Workload characterization key
		Wckey *string `json:"wckey,omitempty"`

		// X11 X11 forwarding options
		X11 *[]SlurmV0041PostJobSubmitJSONBodyJobX11 `json:"x11,omitempty"`

		// X11MagicCookie Magic cookie for X11 forwarding
		X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

		// X11TargetHost Hostname or UNIX socket if x11_target_port=0
		X11TargetHost *string `json:"x11_target_host,omitempty"`

		// X11TargetPort TCP port
		X11TargetPort *int32 `json:"x11_target_port,omitempty"`
	} `json:"job,omitempty"`

	// Jobs HetJob description
	Jobs *[]struct {
		// Account Account associated with the job
		Account *string `json:"account,omitempty"`

		// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
		AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

		// AdminComment Arbitrary comment made by administrator
		AdminComment *string `json:"admin_comment,omitempty"`

		// AllocationNodeList Local node making the resource allocation
		AllocationNodeList *string `json:"allocation_node_list,omitempty"`

		// AllocationNodePort Port to send allocation confirmation to
		AllocationNodePort *int32 `json:"allocation_node_port,omitempty"`

		// Argv Arguments to the script
		Argv *[]string `json:"argv,omitempty"`

		// Array Job array index value specification
		Array *string `json:"array,omitempty"`

		// BatchFeatures Features required for batch script's node
		BatchFeatures *string `json:"batch_features,omitempty"`

		// BeginTime Defer the allocation of the job until the specified time (UNIX timestamp)
		BeginTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"begin_time,omitempty"`

		// BurstBuffer Burst buffer specifications
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
		ClusterConstraint *string `json:"cluster_constraint,omitempty"`

		// Clusters Clusters that a federated job can run on
		Clusters *string `json:"clusters,omitempty"`

		// Comment Arbitrary comment made by user
		Comment *string `json:"comment,omitempty"`

		// Constraints Comma separated list of features that are required
		Constraints *string `json:"constraints,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// ContainerId OCI container ID
		ContainerId *string `json:"container_id,omitempty"`

		// Contiguous True if job requires contiguous nodes
		Contiguous *bool `json:"contiguous,omitempty"`

		// CoreSpecification Specialized core count
		CoreSpecification *int32 `json:"core_specification,omitempty"`

		// CpuBinding Method for binding tasks to allocated CPUs
		CpuBinding *string `json:"cpu_binding,omitempty"`

		// CpuBindingFlags Flags for CPU binding
		CpuBindingFlags *[]SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

		// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
		CpuFrequency *string `json:"cpu_frequency,omitempty"`

		// CpusPerTask Number of CPUs required by each task
		CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

		// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
		CpusPerTres *string `json:"cpus_per_tres,omitempty"`

		// Crontab Specification for scrontab job
		Crontab *struct {
			// Command Command to run
			Command *string `json:"command,omitempty"`

			// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
			DayOfMonth *string `json:"day_of_month,omitempty"`

			// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
			DayOfWeek *string `json:"day_of_week,omitempty"`

			// Flags Flags
			Flags *[]SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags `json:"flags,omitempty"`

			// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
			Hour *string `json:"hour,omitempty"`
			Line *struct {
				// End End of this entry in file
				End *int32 `json:"end,omitempty"`

				// Start Start of this entry in file
				Start *int32 `json:"start,omitempty"`
			} `json:"line,omitempty"`

			// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
			Minute *string `json:"minute,omitempty"`

			// Month Ranged string specifying eligible month values (e.g. 0-5,12)
			Month *string `json:"month,omitempty"`

			// Specification Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
			Specification *string `json:"specification,omitempty"`
		} `json:"crontab,omitempty"`

		// CurrentWorkingDirectory Working directory to use for the job
		CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

		// Deadline Latest time that the job may start (UNIX timestamp)
		Deadline *int64 `json:"deadline,omitempty"`

		// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
		DelayBoot *int32 `json:"delay_boot,omitempty"`

		// Dependency Other jobs that must meet certain criteria before this job can start
		Dependency *string `json:"dependency,omitempty"`

		// Distribution Layout
		Distribution *string `json:"distribution,omitempty"`

		// DistributionPlaneSize Plane size specification when distribution specifies plane
		DistributionPlaneSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"distribution_plane_size,omitempty"`

		// EndTime Expected end time (UNIX timestamp)
		EndTime *int64 `json:"end_time,omitempty"`

		// Environment Environment variables to be set for the job
		Environment *[]string `json:"environment,omitempty"`

		// ExcludedNodes Comma separated list of nodes that may not be used
		ExcludedNodes *[]string `json:"excluded_nodes,omitempty"`
		// Deprecated:
		Exclusive *[]SlurmV0041PostJobSubmitJSONBodyJobsExclusive `json:"exclusive,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// Flags Job flags
		Flags *[]SlurmV0041PostJobSubmitJSONBodyJobsFlags `json:"flags,omitempty"`

		// GroupId Group ID of the user that owns the job
		GroupId *string `json:"group_id,omitempty"`

		// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
		HetjobGroup *int32 `json:"hetjob_group,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// Immediate If true, exit if resources are not available within the time period specified
		Immediate *bool `json:"immediate,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// KillOnNodeFail If true, kill job on node failure
		KillOnNodeFail *bool `json:"kill_on_node_fail,omitempty"`

		// KillWarningDelay Number of seconds before end time to send the warning signal
		KillWarningDelay *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"kill_warning_delay,omitempty"`

		// KillWarningFlags Flags related to job signals
		KillWarningFlags *[]SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags `json:"kill_warning_flags,omitempty"`

		// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
		KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`

		// MailType Mail event type(s)
		MailType *[]SlurmV0041PostJobSubmitJSONBodyJobsMailType `json:"mail_type,omitempty"`

		// MailUser User to receive email notifications
		MailUser *string `json:"mail_user,omitempty"`

		// MaximumCpus Maximum number of CPUs required
		MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

		// MaximumNodes Maximum node count
		MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

		// McsLabel Multi-Category Security label on the job
		McsLabel *string `json:"mcs_label,omitempty"`

		// MemoryBinding Binding map for map/mask_cpu
		MemoryBinding *string `json:"memory_binding,omitempty"`

		// MemoryBindingType Method for binding tasks to memory
		MemoryBindingType *[]SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType `json:"memory_binding_type,omitempty"`

		// MemoryPerCpu Minimum memory in megabytes per allocated CPU
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Minimum memory in megabytes per allocated CPU
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`

		// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
		MemoryPerTres *string `json:"memory_per_tres,omitempty"`

		// MinimumBoardsPerNode Boards per node required
		MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

		// MinimumCpus Minimum number of CPUs required
		MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

		// MinimumCpusPerNode Minimum number of CPUs per node
		MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

		// MinimumNodes Minimum node count
		MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

		// MinimumSocketsPerBoard Sockets per board required
		MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Network Network specs for job step
		Network *string `json:"network,omitempty"`

		// Nice Requested job priority change
		Nice *int32 `json:"nice,omitempty"`

		// Nodes Node count range specification (e.g. 1-15:4)
		Nodes *string `json:"nodes,omitempty"`

		// NtasksPerTres Number of tasks that can access each GPU
		NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

		// OpenMode Open mode used for stdout and stderr files
		OpenMode *[]SlurmV0041PostJobSubmitJSONBodyJobsOpenMode `json:"open_mode,omitempty"`

		// Overcommit Overcommit resources
		Overcommit *bool `json:"overcommit,omitempty"`
		// Deprecated:
		Oversubscribe *bool `json:"oversubscribe,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`
		// Deprecated:
		PowerFlags *[]interface{} `json:"power_flags,omitempty"`

		// Prefer Comma separated list of features that are preferred but not required
		Prefer *string `json:"prefer,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Profile Profile used by the acct_gather_profile plugin
		Profile *[]SlurmV0041PostJobSubmitJSONBodyJobsProfile `json:"profile,omitempty"`

		// Qos Quality of Service assigned to the job
		Qos *string `json:"qos,omitempty"`

		// Reboot Node reboot requested before start
		Reboot *bool `json:"reboot,omitempty"`

		// Requeue Determines whether the job may be requeued
		Requeue *bool `json:"requeue,omitempty"`

		// RequiredNodes Comma separated list of required nodes
		RequiredNodes *[]string `json:"required_nodes,omitempty"`

		// RequiredSwitches Maximum number of switches
		RequiredSwitches *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"required_switches,omitempty"`

		// Reservation Name of reservation to use
		Reservation *string `json:"reservation,omitempty"`

		// ReservePorts Port to send various notification msg to
		ReservePorts *int32 `json:"reserve_ports,omitempty"`

		// ResvMpiPorts Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
		ResvMpiPorts *int32 `json:"resv_mpi_ports,omitempty"`
		Rlimits      *struct {
			// As Address space limit.
			As *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"as,omitempty"`

			// Core Largest core file that can be created, in bytes.
			Core *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"core,omitempty"`

			// Cpu Per-process CPU limit, in seconds.
			Cpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu,omitempty"`

			// Data Maximum size of data segment, in bytes.
			Data *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"data,omitempty"`

			// Fsize Largest file that can be created, in bytes.
			Fsize *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"fsize,omitempty"`

			// Memlock Locked-in-memory address space
			Memlock *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memlock,omitempty"`

			// Nofile Number of open files.
			Nofile *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nofile,omitempty"`

			// Nproc Number of processes.
			Nproc *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nproc,omitempty"`

			// Rss Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size will be more likely to have physical memory taken from them.
			Rss *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"rss,omitempty"`

			// Stack Maximum size of stack segment, in bytes.
			Stack *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"stack,omitempty"`
		} `json:"rlimits,omitempty"`

		// Script Job batch script; only the first component in a HetJob is populated or honored
		Script *string `json:"script,omitempty"`

		// SegmentSize Segment size for topology/block
		SegmentSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"segment_size,omitempty"`

		// SelinuxContext SELinux context
		SelinuxContext *string `json:"selinux_context,omitempty"`

		// Shared How the job can share resources with other jobs, if at all
		Shared *[]SlurmV0041PostJobSubmitJSONBodyJobsShared `json:"shared,omitempty"`

		// SiteFactor Site-specific priority factor
		SiteFactor *int32 `json:"site_factor,omitempty"`

		// SocketsPerNode Sockets per node required
		SocketsPerNode *int32 `json:"sockets_per_node,omitempty"`

		// SpankEnvironment Environment variables for job prolog/epilog scripts as set by SPANK plugins
		SpankEnvironment *[]string `json:"spank_environment,omitempty"`

		// StandardError Path to stderr file
		StandardError *string `json:"standard_error,omitempty"`

		// StandardInput Path to stdin file
		StandardInput *string `json:"standard_input,omitempty"`

		// StandardOutput Path to stdout file
		StandardOutput *string `json:"standard_output,omitempty"`

		// Tasks Number of tasks
		Tasks *int32 `json:"tasks,omitempty"`

		// TasksPerBoard Number of tasks to invoke on each board
		TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

		// TasksPerCore Number of tasks to invoke on each core
		TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

		// TasksPerNode Number of tasks to invoke on each node
		TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

		// TasksPerSocket Number of tasks to invoke on each socket
		TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

		// TemporaryDiskPerNode Minimum tmp disk space required per node
		TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

		// ThreadSpecification Specialized thread count
		ThreadSpecification *int32 `json:"thread_specification,omitempty"`

		// ThreadsPerCore Threads per core required
		ThreadsPerCore *int32 `json:"threads_per_core,omitempty"`

		// TimeLimit Maximum run time in minutes
		TimeLimit *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Minimum run time in minutes
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`

		// TresBind Task to TRES binding directives
		TresBind *string `json:"tres_bind,omitempty"`

		// TresFreq TRES frequency directives
		TresFreq *string `json:"tres_freq,omitempty"`

		// TresPerJob Comma separated list of TRES=# values to be allocated for every job
		TresPerJob *string `json:"tres_per_job,omitempty"`

		// TresPerNode Comma separated list of TRES=# values to be allocated for every node
		TresPerNode *string `json:"tres_per_node,omitempty"`

		// TresPerSocket Comma separated list of TRES=# values to be allocated for every socket
		TresPerSocket *string `json:"tres_per_socket,omitempty"`

		// TresPerTask Comma separated list of TRES=# values to be allocated for every task
		TresPerTask *string `json:"tres_per_task,omitempty"`

		// UserId User ID that owns the job
		UserId *string `json:"user_id,omitempty"`

		// WaitAllNodes If true, wait to start until after all nodes have booted
		WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

		// WaitForSwitch Maximum time to wait for switches in seconds
		WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

		// Wckey Workload characterization key
		Wckey *string `json:"wckey,omitempty"`

		// X11 X11 forwarding options
		X11 *[]SlurmV0041PostJobSubmitJSONBodyJobsX11 `json:"x11,omitempty"`

		// X11MagicCookie Magic cookie for X11 forwarding
		X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

		// X11TargetHost Hostname or UNIX socket if x11_target_port=0
		X11TargetHost *string `json:"x11_target_host,omitempty"`

		// X11TargetPort TCP port
		X11TargetPort *int32 `json:"x11_target_port,omitempty"`
	} `json:"jobs,omitempty"`

	// Script Deprecated; Populate script field in jobs[0] or job
	// Deprecated:
	Script *string `json:"script,omitempty"`
}

// SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags string

// SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags string

// SlurmV0041PostJobSubmitJSONBodyJobExclusive defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobExclusive string

// SlurmV0041PostJobSubmitJSONBodyJobFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobFlags string

// SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags string

// SlurmV0041PostJobSubmitJSONBodyJobMailType defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobMailType string

// SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType string

// SlurmV0041PostJobSubmitJSONBodyJobOpenMode defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobOpenMode string

// SlurmV0041PostJobSubmitJSONBodyJobProfile defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobProfile string

// SlurmV0041PostJobSubmitJSONBodyJobShared defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobShared string

// SlurmV0041PostJobSubmitJSONBodyJobX11 defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobX11 string

// SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags string

// SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags string

// SlurmV0041PostJobSubmitJSONBodyJobsExclusive defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsExclusive string

// SlurmV0041PostJobSubmitJSONBodyJobsFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsFlags string

// SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags string

// SlurmV0041PostJobSubmitJSONBodyJobsMailType defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsMailType string

// SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType string

// SlurmV0041PostJobSubmitJSONBodyJobsOpenMode defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsOpenMode string

// SlurmV0041PostJobSubmitJSONBodyJobsProfile defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsProfile string

// SlurmV0041PostJobSubmitJSONBodyJobsShared defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsShared string

// SlurmV0041PostJobSubmitJSONBodyJobsX11 defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsX11 string

// SlurmV0041DeleteJobParams defines parameters for SlurmV0041DeleteJob.
type SlurmV0041DeleteJobParams struct {
	// Signal Signal to send to Job
	Signal *string `form:"signal,omitempty" json:"signal,omitempty"`

	// Flags Signalling flags
	Flags *SlurmV0041DeleteJobParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041DeleteJobParamsFlags defines parameters for SlurmV0041DeleteJob.
type SlurmV0041DeleteJobParamsFlags string

// SlurmV0041GetJobParams defines parameters for SlurmV0041GetJob.
type SlurmV0041GetJobParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetJobParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetJobParamsFlags defines parameters for SlurmV0041GetJob.
type SlurmV0041GetJobParamsFlags string

// SlurmV0041PostJobJSONBody defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBody struct {
	// Account Account associated with the job
	Account *string `json:"account,omitempty"`

	// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
	AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

	// AdminComment Arbitrary comment made by administrator
	AdminComment *string `json:"admin_comment,omitempty"`

	// AllocationNodeList Local node making the resource allocation
	AllocationNodeList *string `json:"allocation_node_list,omitempty"`

	// AllocationNodePort Port to send allocation confirmation to
	AllocationNodePort *int32 `json:"allocation_node_port,omitempty"`

	// Argv Arguments to the script
	Argv *[]string `json:"argv,omitempty"`

	// Array Job array index value specification
	Array *string `json:"array,omitempty"`

	// BatchFeatures Features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// BeginTime Defer the allocation of the job until the specified time (UNIX timestamp)
	BeginTime *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"begin_time,omitempty"`

	// BurstBuffer Burst buffer specifications
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
	ClusterConstraint *string `json:"cluster_constraint,omitempty"`

	// Clusters Clusters that a federated job can run on
	Clusters *string `json:"clusters,omitempty"`

	// Comment Arbitrary comment made by user
	Comment *string `json:"comment,omitempty"`

	// Constraints Comma separated list of features that are required
	Constraints *string `json:"constraints,omitempty"`

	// Container Absolute path to OCI container bundle
	Container *string `json:"container,omitempty"`

	// ContainerId OCI container ID
	ContainerId *string `json:"container_id,omitempty"`

	// Contiguous True if job requires contiguous nodes
	Contiguous *bool `json:"contiguous,omitempty"`

	// CoreSpecification Specialized core count
	CoreSpecification *int32 `json:"core_specification,omitempty"`

	// CpuBinding Method for binding tasks to allocated CPUs
	CpuBinding *string `json:"cpu_binding,omitempty"`

	// CpuBindingFlags Flags for CPU binding
	CpuBindingFlags *[]SlurmV0041PostJobJSONBodyCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

	// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
	CpuFrequency *string `json:"cpu_frequency,omitempty"`

	// CpusPerTask Number of CPUs required by each task
	CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

	// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
	CpusPerTres *string `json:"cpus_per_tres,omitempty"`

	// Crontab Specification for scrontab job
	Crontab *struct {
		// Command Command to run
		Command *string `json:"command,omitempty"`

		// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
		DayOfMonth *string `json:"day_of_month,omitempty"`

		// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
		DayOfWeek *string `json:"day_of_week,omitempty"`

		// Flags Flags
		Flags *[]SlurmV0041PostJobJSONBodyCrontabFlags `json:"flags,omitempty"`

		// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
		Hour *string `json:"hour,omitempty"`
		Line *struct {
			// End End of this entry in file
			End *int32 `json:"end,omitempty"`

			// Start Start of this entry in file
			Start *int32 `json:"start,omitempty"`
		} `json:"line,omitempty"`

		// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
		Minute *string `json:"minute,omitempty"`

		// Month Ranged string specifying eligible month values (e.g. 0-5,12)
		Month *string `json:"month,omitempty"`

		// Specification Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
		Specification *string `json:"specification,omitempty"`
	} `json:"crontab,omitempty"`

	// CurrentWorkingDirectory Working directory to use for the job
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Deadline Latest time that the job may start (UNIX timestamp)
	Deadline *int64 `json:"deadline,omitempty"`

	// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
	DelayBoot *int32 `json:"delay_boot,omitempty"`

	// Dependency Other jobs that must meet certain criteria before this job can start
	Dependency *string `json:"dependency,omitempty"`

	// Distribution Layout
	Distribution *string `json:"distribution,omitempty"`

	// DistributionPlaneSize Plane size specification when distribution specifies plane
	DistributionPlaneSize *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"distribution_plane_size,omitempty"`

	// EndTime Expected end time (UNIX timestamp)
	EndTime *int64 `json:"end_time,omitempty"`

	// Environment Environment variables to be set for the job
	Environment *[]string `json:"environment,omitempty"`

	// ExcludedNodes Comma separated list of nodes that may not be used
	ExcludedNodes *[]string `json:"excluded_nodes,omitempty"`
	// Deprecated:
	Exclusive *[]SlurmV0041PostJobJSONBodyExclusive `json:"exclusive,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// Flags Job flags
	Flags *[]SlurmV0041PostJobJSONBodyFlags `json:"flags,omitempty"`

	// GroupId Group ID of the user that owns the job
	GroupId *string `json:"group_id,omitempty"`

	// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
	HetjobGroup *int32 `json:"hetjob_group,omitempty"`

	// Hold Hold (true) or release (false) job
	Hold *bool `json:"hold,omitempty"`

	// Immediate If true, exit if resources are not available within the time period specified
	Immediate *bool `json:"immediate,omitempty"`

	// JobId Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// KillOnNodeFail If true, kill job on node failure
	KillOnNodeFail *bool `json:"kill_on_node_fail,omitempty"`

	// KillWarningDelay Number of seconds before end time to send the warning signal
	KillWarningDelay *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"kill_warning_delay,omitempty"`

	// KillWarningFlags Flags related to job signals
	KillWarningFlags *[]SlurmV0041PostJobJSONBodyKillWarningFlags `json:"kill_warning_flags,omitempty"`

	// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
	KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

	// Licenses License(s) required by the job
	Licenses *string `json:"licenses,omitempty"`

	// MailType Mail event type(s)
	MailType *[]SlurmV0041PostJobJSONBodyMailType `json:"mail_type,omitempty"`

	// MailUser User to receive email notifications
	MailUser *string `json:"mail_user,omitempty"`

	// MaximumCpus Maximum number of CPUs required
	MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

	// MaximumNodes Maximum node count
	MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

	// McsLabel Multi-Category Security label on the job
	McsLabel *string `json:"mcs_label,omitempty"`

	// MemoryBinding Binding map for map/mask_cpu
	MemoryBinding *string `json:"memory_binding,omitempty"`

	// MemoryBindingType Method for binding tasks to memory
	MemoryBindingType *[]SlurmV0041PostJobJSONBodyMemoryBindingType `json:"memory_binding_type,omitempty"`

	// MemoryPerCpu Minimum memory in megabytes per allocated CPU
	MemoryPerCpu *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"memory_per_cpu,omitempty"`

	// MemoryPerNode Minimum memory in megabytes per allocated CPU
	MemoryPerNode *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"memory_per_node,omitempty"`

	// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
	MemoryPerTres *string `json:"memory_per_tres,omitempty"`

	// MinimumBoardsPerNode Boards per node required
	MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

	// MinimumCpus Minimum number of CPUs required
	MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

	// MinimumCpusPerNode Minimum number of CPUs per node
	MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

	// MinimumNodes Minimum node count
	MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

	// MinimumSocketsPerBoard Sockets per board required
	MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

	// Name Job name
	Name *string `json:"name,omitempty"`

	// Network Network specs for job step
	Network *string `json:"network,omitempty"`

	// Nice Requested job priority change
	Nice *int32 `json:"nice,omitempty"`

	// Nodes Node count range specification (e.g. 1-15:4)
	Nodes *string `json:"nodes,omitempty"`

	// NtasksPerTres Number of tasks that can access each GPU
	NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

	// OpenMode Open mode used for stdout and stderr files
	OpenMode *[]SlurmV0041PostJobJSONBodyOpenMode `json:"open_mode,omitempty"`

	// Overcommit Overcommit resources
	Overcommit *bool `json:"overcommit,omitempty"`
	// Deprecated:
	Oversubscribe *bool `json:"oversubscribe,omitempty"`

	// Partition Partition assigned to the job
	Partition *string `json:"partition,omitempty"`
	// Deprecated:
	PowerFlags *[]interface{} `json:"power_flags,omitempty"`

	// Prefer Comma separated list of features that are preferred but not required
	Prefer *string `json:"prefer,omitempty"`

	// Priority Request specific job priority
	Priority *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"priority,omitempty"`

	// Profile Profile used by the acct_gather_profile plugin
	Profile *[]SlurmV0041PostJobJSONBodyProfile `json:"profile,omitempty"`

	// Qos Quality of Service assigned to the job
	Qos *string `json:"qos,omitempty"`

	// Reboot Node reboot requested before start
	Reboot *bool `json:"reboot,omitempty"`

	// Requeue Determines whether the job may be requeued
	Requeue *bool `json:"requeue,omitempty"`

	// RequiredNodes Comma separated list of required nodes
	RequiredNodes *[]string `json:"required_nodes,omitempty"`

	// RequiredSwitches Maximum number of switches
	RequiredSwitches *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"required_switches,omitempty"`

	// Reservation Name of reservation to use
	Reservation *string `json:"reservation,omitempty"`

	// ReservePorts Port to send various notification msg to
	ReservePorts *int32 `json:"reserve_ports,omitempty"`

	// ResvMpiPorts Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
	ResvMpiPorts *int32 `json:"resv_mpi_ports,omitempty"`
	Rlimits      *struct {
		// As Address space limit.
		As *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"as,omitempty"`

		// Core Largest core file that can be created, in bytes.
		Core *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"core,omitempty"`

		// Cpu Per-process CPU limit, in seconds.
		Cpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpu,omitempty"`

		// Data Maximum size of data segment, in bytes.
		Data *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"data,omitempty"`

		// Fsize Largest file that can be created, in bytes.
		Fsize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"fsize,omitempty"`

		// Memlock Locked-in-memory address space
		Memlock *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memlock,omitempty"`

		// Nofile Number of open files.
		Nofile *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"nofile,omitempty"`

		// Nproc Number of processes.
		Nproc *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"nproc,omitempty"`

		// Rss Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size will be more likely to have physical memory taken from them.
		Rss *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"rss,omitempty"`

		// Stack Maximum size of stack segment, in bytes.
		Stack *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"stack,omitempty"`
	} `json:"rlimits,omitempty"`

	// Script Job batch script; only the first component in a HetJob is populated or honored
	Script *string `json:"script,omitempty"`

	// SegmentSize Segment size for topology/block
	SegmentSize *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"segment_size,omitempty"`

	// SelinuxContext SELinux context
	SelinuxContext *string `json:"selinux_context,omitempty"`

	// Shared How the job can share resources with other jobs, if at all
	Shared *[]SlurmV0041PostJobJSONBodyShared `json:"shared,omitempty"`

	// SiteFactor Site-specific priority factor
	SiteFactor *int32 `json:"site_factor,omitempty"`

	// SocketsPerNode Sockets per node required
	SocketsPerNode *int32 `json:"sockets_per_node,omitempty"`

	// SpankEnvironment Environment variables for job prolog/epilog scripts as set by SPANK plugins
	SpankEnvironment *[]string `json:"spank_environment,omitempty"`

	// StandardError Path to stderr file
	StandardError *string `json:"standard_error,omitempty"`

	// StandardInput Path to stdin file
	StandardInput *string `json:"standard_input,omitempty"`

	// StandardOutput Path to stdout file
	StandardOutput *string `json:"standard_output,omitempty"`

	// Tasks Number of tasks
	Tasks *int32 `json:"tasks,omitempty"`

	// TasksPerBoard Number of tasks to invoke on each board
	TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

	// TasksPerCore Number of tasks to invoke on each core
	TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

	// TasksPerNode Number of tasks to invoke on each node
	TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

	// TasksPerSocket Number of tasks to invoke on each socket
	TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

	// TemporaryDiskPerNode Minimum tmp disk space required per node
	TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

	// ThreadSpecification Specialized thread count
	ThreadSpecification *int32 `json:"thread_specification,omitempty"`

	// ThreadsPerCore Threads per core required
	ThreadsPerCore *int32 `json:"threads_per_core,omitempty"`

	// TimeLimit Maximum run time in minutes
	TimeLimit *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"time_limit,omitempty"`

	// TimeMinimum Minimum run time in minutes
	TimeMinimum *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"time_minimum,omitempty"`

	// TresBind Task to TRES binding directives
	TresBind *string `json:"tres_bind,omitempty"`

	// TresFreq TRES frequency directives
	TresFreq *string `json:"tres_freq,omitempty"`

	// TresPerJob Comma separated list of TRES=# values to be allocated for every job
	TresPerJob *string `json:"tres_per_job,omitempty"`

	// TresPerNode Comma separated list of TRES=# values to be allocated for every node
	TresPerNode *string `json:"tres_per_node,omitempty"`

	// TresPerSocket Comma separated list of TRES=# values to be allocated for every socket
	TresPerSocket *string `json:"tres_per_socket,omitempty"`

	// TresPerTask Comma separated list of TRES=# values to be allocated for every task
	TresPerTask *string `json:"tres_per_task,omitempty"`

	// UserId User ID that owns the job
	UserId *string `json:"user_id,omitempty"`

	// WaitAllNodes If true, wait to start until after all nodes have booted
	WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

	// WaitForSwitch Maximum time to wait for switches in seconds
	WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

	// Wckey Workload characterization key
	Wckey *string `json:"wckey,omitempty"`

	// X11 X11 forwarding options
	X11 *[]SlurmV0041PostJobJSONBodyX11 `json:"x11,omitempty"`

	// X11MagicCookie Magic cookie for X11 forwarding
	X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

	// X11TargetHost Hostname or UNIX socket if x11_target_port=0
	X11TargetHost *string `json:"x11_target_host,omitempty"`

	// X11TargetPort TCP port
	X11TargetPort *int32 `json:"x11_target_port,omitempty"`
}

// SlurmV0041PostJobJSONBodyCpuBindingFlags defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyCpuBindingFlags string

// SlurmV0041PostJobJSONBodyCrontabFlags defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyCrontabFlags string

// SlurmV0041PostJobJSONBodyExclusive defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyExclusive string

// SlurmV0041PostJobJSONBodyFlags defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyFlags string

// SlurmV0041PostJobJSONBodyKillWarningFlags defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyKillWarningFlags string

// SlurmV0041PostJobJSONBodyMailType defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyMailType string

// SlurmV0041PostJobJSONBodyMemoryBindingType defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyMemoryBindingType string

// SlurmV0041PostJobJSONBodyOpenMode defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyOpenMode string

// SlurmV0041PostJobJSONBodyProfile defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyProfile string

// SlurmV0041PostJobJSONBodyShared defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyShared string

// SlurmV0041PostJobJSONBodyX11 defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyX11 string

// SlurmV0041DeleteJobsJSONBody defines parameters for SlurmV0041DeleteJobs.
type SlurmV0041DeleteJobsJSONBody struct {
	// Account Filter jobs to a specific account
	Account *string `json:"account,omitempty"`

	// Flags Filter jobs according to flags
	Flags *[]SlurmV0041DeleteJobsJSONBodyFlags `json:"flags,omitempty"`

	// JobName Filter jobs to a specific name
	JobName *string `json:"job_name,omitempty"`

	// JobState Filter jobs to a specific state
	JobState *[]SlurmV0041DeleteJobsJSONBodyJobState `json:"job_state,omitempty"`

	// Jobs List of jobs to signal
	Jobs *[]string `json:"jobs,omitempty"`

	// Nodes Filter jobs to a set of nodes
	Nodes *[]string `json:"nodes,omitempty"`

	// Partition Filter jobs to a specific partition
	Partition *string `json:"partition,omitempty"`

	// Qos Filter jobs to a specific QOS
	Qos *string `json:"qos,omitempty"`

	// Reservation Filter jobs to a specific reservation
	Reservation *string `json:"reservation,omitempty"`

	// Signal Signal to send to jobs
	Signal *string `json:"signal,omitempty"`

	// UserId Filter jobs to a specific numeric user id
	UserId *string `json:"user_id,omitempty"`

	// UserName Filter jobs to a specific user name
	UserName *string `json:"user_name,omitempty"`

	// Wckey Filter jobs to a specific wckey
	Wckey *string `json:"wckey,omitempty"`
}

// SlurmV0041DeleteJobsJSONBodyFlags defines parameters for SlurmV0041DeleteJobs.
type SlurmV0041DeleteJobsJSONBodyFlags string

// SlurmV0041DeleteJobsJSONBodyJobState defines parameters for SlurmV0041DeleteJobs.
type SlurmV0041DeleteJobsJSONBodyJobState string

// SlurmV0041GetJobsParams defines parameters for SlurmV0041GetJobs.
type SlurmV0041GetJobsParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetJobsParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetJobsParamsFlags defines parameters for SlurmV0041GetJobs.
type SlurmV0041GetJobsParamsFlags string

// SlurmV0041GetJobsStateParams defines parameters for SlurmV0041GetJobsState.
type SlurmV0041GetJobsStateParams struct {
	// JobId Search for CSV list of Job IDs
	JobId *string `form:"job_id,omitempty" json:"job_id,omitempty"`
}

// SlurmV0041GetNodeParams defines parameters for SlurmV0041GetNode.
type SlurmV0041GetNodeParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetNodeParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetNodeParamsFlags defines parameters for SlurmV0041GetNode.
type SlurmV0041GetNodeParamsFlags string

// SlurmV0041GetNodesParams defines parameters for SlurmV0041GetNodes.
type SlurmV0041GetNodesParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetNodesParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetNodesParamsFlags defines parameters for SlurmV0041GetNodes.
type SlurmV0041GetNodesParamsFlags string

// SlurmV0041GetPartitionParams defines parameters for SlurmV0041GetPartition.
type SlurmV0041GetPartitionParams struct {
	// UpdateTime Filter partitions since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetPartitionParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetPartitionParamsFlags defines parameters for SlurmV0041GetPartition.
type SlurmV0041GetPartitionParamsFlags string

// SlurmV0041GetPartitionsParams defines parameters for SlurmV0041GetPartitions.
type SlurmV0041GetPartitionsParams struct {
	// UpdateTime Filter partitions since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetPartitionsParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetPartitionsParamsFlags defines parameters for SlurmV0041GetPartitions.
type SlurmV0041GetPartitionsParamsFlags string

// SlurmV0041GetReservationParams defines parameters for SlurmV0041GetReservation.
type SlurmV0041GetReservationParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0041GetReservationsParams defines parameters for SlurmV0041GetReservations.
type SlurmV0041GetReservationsParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0041GetSharesParams defines parameters for SlurmV0041GetShares.
type SlurmV0041GetSharesParams struct {
	// Accounts Accounts to query
	Accounts *string `form:"accounts,omitempty" json:"accounts,omitempty"`

	// Users Users to query
	Users *string `form:"users,omitempty" json:"users,omitempty"`
}

// SlurmdbV0041GetAccountParams defines parameters for SlurmdbV0041GetAccount.
type SlurmdbV0041GetAccountParams struct {
	// WithAssocs Include associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords Include coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithDeleted Include deleted
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041GetAccountsParams defines parameters for SlurmdbV0041GetAccounts.
type SlurmdbV0041GetAccountsParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// DELETED include deleted associations
	DELETED *string `form:"DELETED,omitempty" json:"DELETED,omitempty"`

	// WithAssociations query includes associations
	WithAssociations *string `form:"WithAssociations,omitempty" json:"WithAssociations,omitempty"`

	// WithCoordinators query includes coordinators
	WithCoordinators *string `form:"WithCoordinators,omitempty" json:"WithCoordinators,omitempty"`

	// NoUsersAreCoords remove users as coordinators
	NoUsersAreCoords *string `form:"NoUsersAreCoords,omitempty" json:"NoUsersAreCoords,omitempty"`

	// UsersAreCoords users are coordinators
	UsersAreCoords *string `form:"UsersAreCoords,omitempty" json:"UsersAreCoords,omitempty"`
}

// SlurmdbV0041PostAccountsAssociationJSONBody defines parameters for SlurmdbV0041PostAccountsAssociation.
type SlurmdbV0041PostAccountsAssociationJSONBody struct {
	// Account Account organization and description
	Account *struct {
		// Description Arbitrary string describing the account
		Description *string `json:"description,omitempty"`

		// Organization Organization to which the account belongs
		Organization *string `json:"organization,omitempty"`
	} `json:"account,omitempty"`

	// AssociationCondition CSV list of accounts, association limits and options, CSV list of clusters
	AssociationCondition *struct {
		// Accounts CSV accounts list
		Accounts []string `json:"accounts"`

		// Association Association limits and options
		Association *struct {
			// Comment Arbitrary comment
			Comment *string `json:"comment,omitempty"`

			// Defaultqos Default QOS
			Defaultqos *string `json:"defaultqos,omitempty"`

			// Fairshare Allocated shares used for fairshare calculation
			Fairshare *int32 `json:"fairshare,omitempty"`

			// Grpjobs Maximum number of running jobs in this association and its children
			Grpjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpjobs,omitempty"`

			// Grpjobsaccrue Maximum number of pending jobs able to accrue age priority in this association and its children
			Grpjobsaccrue *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpjobsaccrue,omitempty"`

			// Grpsubmitjobs Maximum number of jobs which can be in a pending or running state at any time in this association and its children
			Grpsubmitjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpsubmitjobs,omitempty"`

			// Grptres Maximum number of TRES able to be allocated by running jobs in this association and its children
			Grptres *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptres,omitempty"`

			// Grptresmins Total number of TRES minutes that can possibly be used by past, present and future jobs in this association and its children
			Grptresmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptresmins,omitempty"`

			// Grptresrunmins Maximum number of TRES minutes able to be allocated by running jobs in this association and its children
			Grptresrunmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptresrunmins,omitempty"`

			// Grpwall Maximum wall clock time in minutes able to be allocated by running jobs in this association and its children
			Grpwall *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpwall,omitempty"`

			// Maxjobs Maximum number of running jobs per user in this association
			Maxjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxjobs,omitempty"`

			// Maxjobsaccrue Maximum number of pending jobs able to accrue age priority at any given time in this association
			Maxjobsaccrue *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxjobsaccrue,omitempty"`

			// Maxsubmitjobs Maximum number of jobs which can be in a pending or running state at any time in this association
			Maxsubmitjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxsubmitjobs,omitempty"`

			// Maxtresminsperjob Maximum number of TRES minutes each job is able to use in this association
			Maxtresminsperjob *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresminsperjob,omitempty"`

			// Maxtresperjob Maximum number of TRES each job is able to use in this association
			Maxtresperjob *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresperjob,omitempty"`

			// Maxtrespernode Maximum number of TRES each node is able to use
			Maxtrespernode *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtrespernode,omitempty"`

			// Maxtresrunmins Maximum number of TRES minutes able to be allocated by running jobs in this association
			Maxtresrunmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresrunmins,omitempty"`

			// Maxwalldurationperjob Maximum wall clock time each job is able to use in this association
			Maxwalldurationperjob *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxwalldurationperjob,omitempty"`

			// Minpriothresh Minimum priority required to reserve resources when scheduling
			Minpriothresh *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minpriothresh,omitempty"`

			// Parent Name of parent account
			Parent *string `json:"parent,omitempty"`

			// Priority Association priority factor
			Priority *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority,omitempty"`

			// Qoslevel List of available QOS names
			Qoslevel *[]string `json:"qoslevel,omitempty"`
		} `json:"association,omitempty"`

		// Clusters CSV clusters list
		Clusters *[]string `json:"clusters,omitempty"`
	} `json:"association_condition,omitempty"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// SlurmdbV0041DeleteAssociationParams defines parameters for SlurmdbV0041DeleteAssociation.
type SlurmdbV0041DeleteAssociationParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041GetAssociationParams defines parameters for SlurmdbV0041GetAssociation.
type SlurmdbV0041GetAssociationParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041DeleteAssociationsParams defines parameters for SlurmdbV0041DeleteAssociations.
type SlurmdbV0041DeleteAssociationsParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041GetAssociationsParams defines parameters for SlurmdbV0041GetAssociations.
type SlurmdbV0041GetAssociationsParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041DeleteClusterParams defines parameters for SlurmdbV0041DeleteCluster.
type SlurmdbV0041DeleteClusterParams struct {
	// Classification Type of machine
	Classification *SlurmdbV0041DeleteClusterParamsClassification `form:"classification,omitempty" json:"classification,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Federation CSV federation list
	Federation *string `form:"federation,omitempty" json:"federation,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0041DeleteClusterParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// RpcVersion CSV RPC version list
	RpcVersion *string `form:"rpc_version,omitempty" json:"rpc_version,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// WithDeleted Include deleted clusters
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`
}

// SlurmdbV0041DeleteClusterParamsClassification defines parameters for SlurmdbV0041DeleteCluster.
type SlurmdbV0041DeleteClusterParamsClassification string

// SlurmdbV0041DeleteClusterParamsFlags defines parameters for SlurmdbV0041DeleteCluster.
type SlurmdbV0041DeleteClusterParamsFlags string

// SlurmdbV0041GetClusterParams defines parameters for SlurmdbV0041GetCluster.
type SlurmdbV0041GetClusterParams struct {
	// Classification Type of machine
	Classification *SlurmdbV0041GetClusterParamsClassification `form:"classification,omitempty" json:"classification,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Federation CSV federation list
	Federation *string `form:"federation,omitempty" json:"federation,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0041GetClusterParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// RpcVersion CSV RPC version list
	RpcVersion *string `form:"rpc_version,omitempty" json:"rpc_version,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// WithDeleted Include deleted clusters
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`
}

// SlurmdbV0041GetClusterParamsClassification defines parameters for SlurmdbV0041GetCluster.
type SlurmdbV0041GetClusterParamsClassification string

// SlurmdbV0041GetClusterParamsFlags defines parameters for SlurmdbV0041GetCluster.
type SlurmdbV0041GetClusterParamsFlags string

// SlurmdbV0041GetClustersParams defines parameters for SlurmdbV0041GetClusters.
type SlurmdbV0041GetClustersParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmdbV0041PostClustersParams defines parameters for SlurmdbV0041PostClusters.
type SlurmdbV0041PostClustersParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmdbV0041GetInstanceParams defines parameters for SlurmdbV0041GetInstance.
type SlurmdbV0041GetInstanceParams struct {
	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Extra CSV extra list
	Extra *string `form:"extra,omitempty" json:"extra,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// InstanceId CSV instance_id list
	InstanceId *string `form:"instance_id,omitempty" json:"instance_id,omitempty"`

	// InstanceType CSV instance_type list
	InstanceType *string `form:"instance_type,omitempty" json:"instance_type,omitempty"`

	// NodeList Ranged node string
	NodeList *string `form:"node_list,omitempty" json:"node_list,omitempty"`

	// TimeEnd Time end (UNIX timestamp)
	TimeEnd *string `form:"time_end,omitempty" json:"time_end,omitempty"`

	// TimeStart Time start (UNIX timestamp)
	TimeStart *string `form:"time_start,omitempty" json:"time_start,omitempty"`
}

// SlurmdbV0041GetInstancesParams defines parameters for SlurmdbV0041GetInstances.
type SlurmdbV0041GetInstancesParams struct {
	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Extra CSV extra list
	Extra *string `form:"extra,omitempty" json:"extra,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// InstanceId CSV instance_id list
	InstanceId *string `form:"instance_id,omitempty" json:"instance_id,omitempty"`

	// InstanceType CSV instance_type list
	InstanceType *string `form:"instance_type,omitempty" json:"instance_type,omitempty"`

	// NodeList Ranged node string
	NodeList *string `form:"node_list,omitempty" json:"node_list,omitempty"`

	// TimeEnd Time end (UNIX timestamp)
	TimeEnd *string `form:"time_end,omitempty" json:"time_end,omitempty"`

	// TimeStart Time start (UNIX timestamp)
	TimeStart *string `form:"time_start,omitempty" json:"time_start,omitempty"`
}

// SlurmdbV0041GetJobsParams defines parameters for SlurmdbV0041GetJobs.
type SlurmdbV0041GetJobsParams struct {
	// Account CSV account list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Association CSV association list
	Association *string `form:"association,omitempty" json:"association,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Constraints CSV constraint list
	Constraints *string `form:"constraints,omitempty" json:"constraints,omitempty"`

	// SchedulerUnset Schedule bits not set
	SchedulerUnset *string `form:"scheduler_unset,omitempty" json:"scheduler_unset,omitempty"`

	// ScheduledOnSubmit Job was started on submit
	ScheduledOnSubmit *string `form:"scheduled_on_submit,omitempty" json:"scheduled_on_submit,omitempty"`

	// ScheduledByMain Job was started from main scheduler
	ScheduledByMain *string `form:"scheduled_by_main,omitempty" json:"scheduled_by_main,omitempty"`

	// ScheduledByBackfill Job was started from backfill
	ScheduledByBackfill *string `form:"scheduled_by_backfill,omitempty" json:"scheduled_by_backfill,omitempty"`

	// JobStarted Job start RPC was received
	JobStarted *string `form:"job_started,omitempty" json:"job_started,omitempty"`

	// ExitCode Job exit code (numeric)
	ExitCode *string `form:"exit_code,omitempty" json:"exit_code,omitempty"`

	// ShowDuplicates Include duplicate job entries
	ShowDuplicates *string `form:"show_duplicates,omitempty" json:"show_duplicates,omitempty"`

	// SkipSteps Exclude job step details
	SkipSteps *string `form:"skip_steps,omitempty" json:"skip_steps,omitempty"`

	// DisableTruncateUsageTime Do not truncate the time to usage_start and usage_end
	DisableTruncateUsageTime *string `form:"disable_truncate_usage_time,omitempty" json:"disable_truncate_usage_time,omitempty"`

	// WholeHetjob Include details on all hetjob components
	WholeHetjob *string `form:"whole_hetjob,omitempty" json:"whole_hetjob,omitempty"`

	// DisableWholeHetjob Only show details on specified hetjob components
	DisableWholeHetjob *string `form:"disable_whole_hetjob,omitempty" json:"disable_whole_hetjob,omitempty"`

	// DisableWaitForResult Tell dbd not to wait for the result
	DisableWaitForResult *string `form:"disable_wait_for_result,omitempty" json:"disable_wait_for_result,omitempty"`

	// UsageTimeAsSubmitTime Use usage_time as the submit_time of the job
	UsageTimeAsSubmitTime *string `form:"usage_time_as_submit_time,omitempty" json:"usage_time_as_submit_time,omitempty"`

	// ShowBatchScript Include job script
	ShowBatchScript *string `form:"show_batch_script,omitempty" json:"show_batch_script,omitempty"`

	// ShowJobEnvironment Include job environment
	ShowJobEnvironment *string `form:"show_job_environment,omitempty" json:"show_job_environment,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Groups CSV group list
	Groups *string `form:"groups,omitempty" json:"groups,omitempty"`

	// JobName CSV job name list
	JobName *string `form:"job_name,omitempty" json:"job_name,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS name list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// Reason CSV reason list
	Reason *string `form:"reason,omitempty" json:"reason,omitempty"`

	// Reservation CSV reservation name list
	Reservation *string `form:"reservation,omitempty" json:"reservation,omitempty"`

	// ReservationId CSV reservation ID list
	ReservationId *string `form:"reservation_id,omitempty" json:"reservation_id,omitempty"`

	// State CSV state list
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Step CSV step id list
	Step *string `form:"step,omitempty" json:"step,omitempty"`

	// EndTime Usage end (UNIX timestamp)
	EndTime *string `form:"end_time,omitempty" json:"end_time,omitempty"`

	// StartTime Usage start (UNIX timestamp)
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty"`

	// Node Ranged node string where jobs ran
	Node *string `form:"node,omitempty" json:"node,omitempty"`

	// Users CSV user name list
	Users *string `form:"users,omitempty" json:"users,omitempty"`

	// Wckey CSV wckey list
	Wckey *string `form:"wckey,omitempty" json:"wckey,omitempty"`
}

// SlurmdbV0041GetQosParams defines parameters for SlurmdbV0041GetQos.
type SlurmdbV0041GetQosParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Id CSV QOS id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Name CSV QOS name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PreemptMode PreemptMode used when jobs in this QOS are preempted
	PreemptMode *SlurmdbV0041GetQosParamsPreemptMode `form:"preempt_mode,omitempty" json:"preempt_mode,omitempty"`

	// WithDeleted Include deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041GetQosParamsPreemptMode defines parameters for SlurmdbV0041GetQos.
type SlurmdbV0041GetQosParamsPreemptMode string

// SlurmdbV0041PostQosParams defines parameters for SlurmdbV0041PostQos.
type SlurmdbV0041PostQosParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Id CSV QOS id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Name CSV QOS name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PreemptMode PreemptMode used when jobs in this QOS are preempted
	PreemptMode *SlurmdbV0041PostQosParamsPreemptMode `form:"preempt_mode,omitempty" json:"preempt_mode,omitempty"`

	// WithDeleted Include deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041PostQosParamsPreemptMode defines parameters for SlurmdbV0041PostQos.
type SlurmdbV0041PostQosParamsPreemptMode string

// SlurmdbV0041GetSingleQosParams defines parameters for SlurmdbV0041GetSingleQos.
type SlurmdbV0041GetSingleQosParams struct {
	// WithDeleted Query includes deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041GetUserParams defines parameters for SlurmdbV0041GetUser.
type SlurmdbV0041GetUserParams struct {
	// WithDeleted Include deleted users
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithAssocs Include associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords Include coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithWckeys Include wckeys
	WithWckeys *string `form:"with_wckeys,omitempty" json:"with_wckeys,omitempty"`
}

// SlurmdbV0041GetUsersParams defines parameters for SlurmdbV0041GetUsers.
type SlurmdbV0041GetUsersParams struct {
	// AdminLevel Administrator level
	AdminLevel *SlurmdbV0041GetUsersParamsAdminLevel `form:"admin_level,omitempty" json:"admin_level,omitempty"`

	// DefaultAccount CSV default account list
	DefaultAccount *string `form:"default_account,omitempty" json:"default_account,omitempty"`

	// DefaultWckey CSV default wckey list
	DefaultWckey *string `form:"default_wckey,omitempty" json:"default_wckey,omitempty"`

	// WithAssocs With associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords With coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithDeleted With deleted
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithWckeys With wckeys
	WithWckeys *string `form:"with_wckeys,omitempty" json:"with_wckeys,omitempty"`

	// WithoutDefaults Exclude defaults
	WithoutDefaults *string `form:"without_defaults,omitempty" json:"without_defaults,omitempty"`
}

// SlurmdbV0041GetUsersParamsAdminLevel defines parameters for SlurmdbV0041GetUsers.
type SlurmdbV0041GetUsersParamsAdminLevel string

// SlurmdbV0041PostUsersAssociationJSONBody defines parameters for SlurmdbV0041PostUsersAssociation.
type SlurmdbV0041PostUsersAssociationJSONBody struct {
	// AssociationCondition Filters to select associations for users
	AssociationCondition struct {
		// Accounts CSV accounts list
		Accounts *[]string `json:"accounts,omitempty"`

		// Association Association limits and options
		Association *struct {
			// Comment Arbitrary comment
			Comment *string `json:"comment,omitempty"`

			// Defaultqos Default QOS
			Defaultqos *string `json:"defaultqos,omitempty"`

			// Fairshare Allocated shares used for fairshare calculation
			Fairshare *int32 `json:"fairshare,omitempty"`

			// Grpjobs Maximum number of running jobs in this association and its children
			Grpjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpjobs,omitempty"`

			// Grpjobsaccrue Maximum number of pending jobs able to accrue age priority in this association and its children
			Grpjobsaccrue *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpjobsaccrue,omitempty"`

			// Grpsubmitjobs Maximum number of jobs which can be in a pending or running state at any time in this association and its children
			Grpsubmitjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpsubmitjobs,omitempty"`

			// Grptres Maximum number of TRES able to be allocated by running jobs in this association and its children
			Grptres *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptres,omitempty"`

			// Grptresmins Total number of TRES minutes that can possibly be used by past, present and future jobs in this association and its children
			Grptresmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptresmins,omitempty"`

			// Grptresrunmins Maximum number of TRES minutes able to be allocated by running jobs in this association and its children
			Grptresrunmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptresrunmins,omitempty"`

			// Grpwall Maximum wall clock time in minutes able to be allocated by running jobs in this association and its children
			Grpwall *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpwall,omitempty"`

			// Maxjobs Maximum number of running jobs per user in this association
			Maxjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxjobs,omitempty"`

			// Maxjobsaccrue Maximum number of pending jobs able to accrue age priority at any given time in this association
			Maxjobsaccrue *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxjobsaccrue,omitempty"`

			// Maxsubmitjobs Maximum number of jobs which can be in a pending or running state at any time in this association
			Maxsubmitjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxsubmitjobs,omitempty"`

			// Maxtresminsperjob Maximum number of TRES minutes each job is able to use in this association
			Maxtresminsperjob *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresminsperjob,omitempty"`

			// Maxtresperjob Maximum number of TRES each job is able to use in this association
			Maxtresperjob *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresperjob,omitempty"`

			// Maxtrespernode Maximum number of TRES each node is able to use
			Maxtrespernode *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtrespernode,omitempty"`

			// Maxtresrunmins Maximum number of TRES minutes able to be allocated by running jobs in this association
			Maxtresrunmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresrunmins,omitempty"`

			// Maxwalldurationperjob Maximum wall clock time each job is able to use in this association
			Maxwalldurationperjob *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxwalldurationperjob,omitempty"`

			// Minpriothresh Minimum priority required to reserve resources when scheduling
			Minpriothresh *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minpriothresh,omitempty"`

			// Parent Name of parent account
			Parent *string `json:"parent,omitempty"`

			// Priority Association priority factor
			Priority *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority,omitempty"`

			// Qoslevel List of available QOS names
			Qoslevel *[]string `json:"qoslevel,omitempty"`
		} `json:"association,omitempty"`

		// Clusters CSV clusters list
		Clusters *[]string `json:"clusters,omitempty"`

		// Partitions CSV partitions list
		Partitions *[]string `json:"partitions,omitempty"`

		// Users CSV users list
		Users []string `json:"users"`

		// Wckeys CSV WCKeys list
		Wckeys *[]string `json:"wckeys,omitempty"`
	} `json:"association_condition"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// User Admin level of user, DefaultAccount, DefaultWCKey
	User struct {
		// Adminlevel AdminLevel granted to the user
		Adminlevel *[]SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel `json:"adminlevel,omitempty"`

		// Defaultaccount Default account
		Defaultaccount *string `json:"defaultaccount,omitempty"`

		// Defaultwckey Default WCKey
		Defaultwckey *string `json:"defaultwckey,omitempty"`
	} `json:"user"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// SlurmdbV0041PostUsersAssociationParams defines parameters for SlurmdbV0041PostUsersAssociation.
type SlurmdbV0041PostUsersAssociationParams struct {
	// UpdateTime Filter partitions since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0041PostUsersAssociationParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmdbV0041PostUsersAssociationParamsFlags defines parameters for SlurmdbV0041PostUsersAssociation.
type SlurmdbV0041PostUsersAssociationParamsFlags string

// SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel defines parameters for SlurmdbV0041PostUsersAssociation.
type SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel string

// SlurmdbV0041GetWckeysParams defines parameters for SlurmdbV0041GetWckeys.
type SlurmdbV0041GetWckeysParams struct {
	// Cluster CSV cluster name list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name CSV name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// OnlyDefaults Only query defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted wckeys
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041PostWckeysParams defines parameters for SlurmdbV0041PostWckeys.
type SlurmdbV0041PostWckeysParams struct {
	// Cluster CSV cluster name list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name CSV name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// OnlyDefaults Only query defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted wckeys
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmV0041PostJobAllocateJSONRequestBody defines body for SlurmV0041PostJobAllocate for application/json ContentType.
type SlurmV0041PostJobAllocateJSONRequestBody SlurmV0041PostJobAllocateJSONBody

// SlurmV0041PostJobSubmitJSONRequestBody defines body for SlurmV0041PostJobSubmit for application/json ContentType.
type SlurmV0041PostJobSubmitJSONRequestBody SlurmV0041PostJobSubmitJSONBody

// SlurmV0041PostJobJSONRequestBody defines body for SlurmV0041PostJob for application/json ContentType.
type SlurmV0041PostJobJSONRequestBody SlurmV0041PostJobJSONBody

// SlurmV0041DeleteJobsJSONRequestBody defines body for SlurmV0041DeleteJobs for application/json ContentType.
type SlurmV0041DeleteJobsJSONRequestBody SlurmV0041DeleteJobsJSONBody

// SlurmV0041PostNodeJSONRequestBody defines body for SlurmV0041PostNode for application/json ContentType.
type SlurmV0041PostNodeJSONRequestBody = V0041UpdateNodeMsg

// SlurmV0041PostNodesJSONRequestBody defines body for SlurmV0041PostNodes for application/json ContentType.
type SlurmV0041PostNodesJSONRequestBody = V0041UpdateNodeMsg

// SlurmdbV0041PostAccountsJSONRequestBody defines body for SlurmdbV0041PostAccounts for application/json ContentType.
type SlurmdbV0041PostAccountsJSONRequestBody = V0041OpenapiAccountsResp

// SlurmdbV0041PostAccountsAssociationJSONRequestBody defines body for SlurmdbV0041PostAccountsAssociation for application/json ContentType.
type SlurmdbV0041PostAccountsAssociationJSONRequestBody SlurmdbV0041PostAccountsAssociationJSONBody

// SlurmdbV0041PostAssociationsJSONRequestBody defines body for SlurmdbV0041PostAssociations for application/json ContentType.
type SlurmdbV0041PostAssociationsJSONRequestBody = V0041OpenapiAssocsResp

// SlurmdbV0041PostClustersJSONRequestBody defines body for SlurmdbV0041PostClusters for application/json ContentType.
type SlurmdbV0041PostClustersJSONRequestBody = V0041OpenapiClustersResp

// SlurmdbV0041PostConfigJSONRequestBody defines body for SlurmdbV0041PostConfig for application/json ContentType.
type SlurmdbV0041PostConfigJSONRequestBody = V0041OpenapiSlurmdbdConfigResp

// SlurmdbV0041PostQosJSONRequestBody defines body for SlurmdbV0041PostQos for application/json ContentType.
type SlurmdbV0041PostQosJSONRequestBody = V0041OpenapiSlurmdbdQosResp

// SlurmdbV0041PostTresJSONRequestBody defines body for SlurmdbV0041PostTres for application/json ContentType.
type SlurmdbV0041PostTresJSONRequestBody = V0041OpenapiTresResp

// SlurmdbV0041PostUsersJSONRequestBody defines body for SlurmdbV0041PostUsers for application/json ContentType.
type SlurmdbV0041PostUsersJSONRequestBody = V0041OpenapiUsersResp

// SlurmdbV0041PostUsersAssociationJSONRequestBody defines body for SlurmdbV0041PostUsersAssociation for application/json ContentType.
type SlurmdbV0041PostUsersAssociationJSONRequestBody SlurmdbV0041PostUsersAssociationJSONBody

// SlurmdbV0041PostWckeysJSONRequestBody defines body for SlurmdbV0041PostWckeys for application/json ContentType.
type SlurmdbV0041PostWckeysJSONRequestBody = V0041OpenapiWckeyResp

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SlurmV0041GetDiag request
	SlurmV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostJobAllocateWithBody request with any body
	SlurmV0041PostJobAllocateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostJobAllocate(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostJobSubmitWithBody request with any body
	SlurmV0041PostJobSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostJobSubmit(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteJob request
	SlurmV0041DeleteJob(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetJob request
	SlurmV0041GetJob(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostJobWithBody request with any body
	SlurmV0041PostJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostJob(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteJobsWithBody request with any body
	SlurmV0041DeleteJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041DeleteJobs(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetJobs request
	SlurmV0041GetJobs(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetJobsState request
	SlurmV0041GetJobsState(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetLicenses request
	SlurmV0041GetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteNode request
	SlurmV0041DeleteNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetNode request
	SlurmV0041GetNode(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostNodeWithBody request with any body
	SlurmV0041PostNodeWithBody(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostNode(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetNodes request
	SlurmV0041GetNodes(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostNodesWithBody request with any body
	SlurmV0041PostNodesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostNodes(ctx context.Context, body SlurmV0041PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetPartition request
	SlurmV0041GetPartition(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetPartitions request
	SlurmV0041GetPartitions(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetPing request
	SlurmV0041GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetReconfigure request
	SlurmV0041GetReconfigure(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteReservation request
	SlurmV0041DeleteReservation(ctx context.Context, reservationName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetReservation request
	SlurmV0041GetReservation(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetReservations request
	SlurmV0041GetReservations(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetShares request
	SlurmV0041GetShares(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteAccount request
	SlurmdbV0041DeleteAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAccount request
	SlurmdbV0041GetAccount(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAccounts request
	SlurmdbV0041GetAccounts(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostAccountsWithBody request with any body
	SlurmdbV0041PostAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostAccounts(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostAccountsAssociationWithBody request with any body
	SlurmdbV0041PostAccountsAssociationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostAccountsAssociation(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteAssociation request
	SlurmdbV0041DeleteAssociation(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAssociation request
	SlurmdbV0041GetAssociation(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteAssociations request
	SlurmdbV0041DeleteAssociations(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAssociations request
	SlurmdbV0041GetAssociations(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostAssociationsWithBody request with any body
	SlurmdbV0041PostAssociationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostAssociations(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteCluster request
	SlurmdbV0041DeleteCluster(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetCluster request
	SlurmdbV0041GetCluster(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetClusters request
	SlurmdbV0041GetClusters(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostClustersWithBody request with any body
	SlurmdbV0041PostClustersWithBody(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostClusters(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetConfig request
	SlurmdbV0041GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostConfigWithBody request with any body
	SlurmdbV0041PostConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostConfig(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetDiag request
	SlurmdbV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetInstance request
	SlurmdbV0041GetInstance(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetInstances request
	SlurmdbV0041GetInstances(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetJob request
	SlurmdbV0041GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetJobs request
	SlurmdbV0041GetJobs(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetQos request
	SlurmdbV0041GetQos(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostQosWithBody request with any body
	SlurmdbV0041PostQosWithBody(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostQos(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteSingleQos request
	SlurmdbV0041DeleteSingleQos(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetSingleQos request
	SlurmdbV0041GetSingleQos(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetTres request
	SlurmdbV0041GetTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostTresWithBody request with any body
	SlurmdbV0041PostTresWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostTres(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteUser request
	SlurmdbV0041DeleteUser(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetUser request
	SlurmdbV0041GetUser(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetUsers request
	SlurmdbV0041GetUsers(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostUsersWithBody request with any body
	SlurmdbV0041PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostUsers(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostUsersAssociationWithBody request with any body
	SlurmdbV0041PostUsersAssociationWithBody(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostUsersAssociation(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteWckey request
	SlurmdbV0041DeleteWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetWckey request
	SlurmdbV0041GetWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetWckeys request
	SlurmdbV0041GetWckeys(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostWckeysWithBody request with any body
	SlurmdbV0041PostWckeysWithBody(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostWckeys(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SlurmV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobAllocateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobAllocateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobAllocate(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobAllocateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobSubmitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobSubmit(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobSubmitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteJob(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetJob(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJob(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteJobs(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetJobs(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetJobsState(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetJobsStateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetLicensesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteNodeRequest(c.Server, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetNode(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetNodeRequest(c.Server, nodeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNodeWithBody(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodeRequestWithBody(c.Server, nodeName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNode(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodeRequest(c.Server, nodeName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetNodes(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetNodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNodesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNodes(ctx context.Context, body SlurmV0041PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetPartition(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetPartitionRequest(c.Server, partitionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetPartitions(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetPartitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetReconfigure(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetReconfigureRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteReservation(ctx context.Context, reservationName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteReservationRequest(c.Server, reservationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetReservation(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetReservationRequest(c.Server, reservationName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetReservations(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetReservationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetShares(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetSharesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteAccountRequest(c.Server, accountName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAccount(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAccountRequest(c.Server, accountName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAccounts(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccounts(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccountsAssociationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsAssociationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccountsAssociation(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsAssociationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteAssociation(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteAssociationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAssociation(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAssociationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteAssociations(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAssociations(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAssociationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAssociationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAssociations(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAssociationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteCluster(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteClusterRequest(c.Server, clusterName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetCluster(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetClusterRequest(c.Server, clusterName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetClusters(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostClustersWithBody(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostClustersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostClusters(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostClustersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostConfig(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetInstance(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetInstanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetInstances(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetInstancesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetJobs(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetQos(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetQosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostQosWithBody(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostQosRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostQos(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostQosRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteSingleQos(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteSingleQosRequest(c.Server, qos)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetSingleQos(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetSingleQosRequest(c.Server, qos, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetTresRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostTresWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostTresRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostTres(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostTresRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteUser(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteUserRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetUser(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetUserRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetUsers(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsers(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsersAssociationWithBody(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersAssociationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsersAssociation(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersAssociationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteWckeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetWckeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetWckeys(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetWckeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostWckeysWithBody(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostWckeysRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostWckeys(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostWckeysRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSlurmV0041GetDiagRequest generates requests for SlurmV0041GetDiag
func NewSlurmV0041GetDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/diag/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostJobAllocateRequest calls the generic SlurmV0041PostJobAllocate builder with application/json body
func NewSlurmV0041PostJobAllocateRequest(server string, body SlurmV0041PostJobAllocateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostJobAllocateRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041PostJobAllocateRequestWithBody generates requests for SlurmV0041PostJobAllocate with any type of body
func NewSlurmV0041PostJobAllocateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/allocate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041PostJobSubmitRequest calls the generic SlurmV0041PostJobSubmit builder with application/json body
func NewSlurmV0041PostJobSubmitRequest(server string, body SlurmV0041PostJobSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostJobSubmitRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041PostJobSubmitRequestWithBody generates requests for SlurmV0041PostJobSubmit with any type of body
func NewSlurmV0041PostJobSubmitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041DeleteJobRequest generates requests for SlurmV0041DeleteJob
func NewSlurmV0041DeleteJobRequest(server string, jobId string, params *SlurmV0041DeleteJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Signal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "signal", runtime.ParamLocationQuery, *params.Signal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetJobRequest generates requests for SlurmV0041GetJob
func NewSlurmV0041GetJobRequest(server string, jobId string, params *SlurmV0041GetJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostJobRequest calls the generic SlurmV0041PostJob builder with application/json body
func NewSlurmV0041PostJobRequest(server string, jobId string, body SlurmV0041PostJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostJobRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewSlurmV0041PostJobRequestWithBody generates requests for SlurmV0041PostJob with any type of body
func NewSlurmV0041PostJobRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041DeleteJobsRequest calls the generic SlurmV0041DeleteJobs builder with application/json body
func NewSlurmV0041DeleteJobsRequest(server string, body SlurmV0041DeleteJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041DeleteJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041DeleteJobsRequestWithBody generates requests for SlurmV0041DeleteJobs with any type of body
func NewSlurmV0041DeleteJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041GetJobsRequest generates requests for SlurmV0041GetJobs
func NewSlurmV0041GetJobsRequest(server string, params *SlurmV0041GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetJobsStateRequest generates requests for SlurmV0041GetJobsState
func NewSlurmV0041GetJobsStateRequest(server string, params *SlurmV0041GetJobsStateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/jobs/state/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetLicensesRequest generates requests for SlurmV0041GetLicenses
func NewSlurmV0041GetLicensesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/licenses/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041DeleteNodeRequest generates requests for SlurmV0041DeleteNode
func NewSlurmV0041DeleteNodeRequest(server string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetNodeRequest generates requests for SlurmV0041GetNode
func NewSlurmV0041GetNodeRequest(server string, nodeName string, params *SlurmV0041GetNodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostNodeRequest calls the generic SlurmV0041PostNode builder with application/json body
func NewSlurmV0041PostNodeRequest(server string, nodeName string, body SlurmV0041PostNodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostNodeRequestWithBody(server, nodeName, "application/json", bodyReader)
}

// NewSlurmV0041PostNodeRequestWithBody generates requests for SlurmV0041PostNode with any type of body
func NewSlurmV0041PostNodeRequestWithBody(server string, nodeName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041GetNodesRequest generates requests for SlurmV0041GetNodes
func NewSlurmV0041GetNodesRequest(server string, params *SlurmV0041GetNodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/nodes/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostNodesRequest calls the generic SlurmV0041PostNodes builder with application/json body
func NewSlurmV0041PostNodesRequest(server string, body SlurmV0041PostNodesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostNodesRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041PostNodesRequestWithBody generates requests for SlurmV0041PostNodes with any type of body
func NewSlurmV0041PostNodesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/nodes/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041GetPartitionRequest generates requests for SlurmV0041GetPartition
func NewSlurmV0041GetPartitionRequest(server string, partitionName string, params *SlurmV0041GetPartitionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "partition_name", runtime.ParamLocationPath, partitionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/partition/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetPartitionsRequest generates requests for SlurmV0041GetPartitions
func NewSlurmV0041GetPartitionsRequest(server string, params *SlurmV0041GetPartitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/partitions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetPingRequest generates requests for SlurmV0041GetPing
func NewSlurmV0041GetPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/ping/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetReconfigureRequest generates requests for SlurmV0041GetReconfigure
func NewSlurmV0041GetReconfigureRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reconfigure/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041DeleteReservationRequest generates requests for SlurmV0041DeleteReservation
func NewSlurmV0041DeleteReservationRequest(server string, reservationName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservation_name", runtime.ParamLocationPath, reservationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetReservationRequest generates requests for SlurmV0041GetReservation
func NewSlurmV0041GetReservationRequest(server string, reservationName string, params *SlurmV0041GetReservationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservation_name", runtime.ParamLocationPath, reservationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetReservationsRequest generates requests for SlurmV0041GetReservations
func NewSlurmV0041GetReservationsRequest(server string, params *SlurmV0041GetReservationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reservations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetSharesRequest generates requests for SlurmV0041GetShares
func NewSlurmV0041GetSharesRequest(server string, params *SlurmV0041GetSharesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/shares")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "accounts", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Users != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "users", runtime.ParamLocationQuery, *params.Users); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041DeleteAccountRequest generates requests for SlurmdbV0041DeleteAccount
func NewSlurmdbV0041DeleteAccountRequest(server string, accountName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_name", runtime.ParamLocationPath, accountName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAccountRequest generates requests for SlurmdbV0041GetAccount
func NewSlurmdbV0041GetAccountRequest(server string, accountName string, params *SlurmdbV0041GetAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_name", runtime.ParamLocationPath, accountName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAccountsRequest generates requests for SlurmdbV0041GetAccounts
func NewSlurmdbV0041GetAccountsRequest(server string, params *SlurmdbV0041GetAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/accounts/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DELETED != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "DELETED", runtime.ParamLocationQuery, *params.DELETED); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssociations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "WithAssociations", runtime.ParamLocationQuery, *params.WithAssociations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoordinators != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "WithCoordinators", runtime.ParamLocationQuery, *params.WithCoordinators); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoUsersAreCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "NoUsersAreCoords", runtime.ParamLocationQuery, *params.NoUsersAreCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsersAreCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "UsersAreCoords", runtime.ParamLocationQuery, *params.UsersAreCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostAccountsRequest calls the generic SlurmdbV0041PostAccounts builder with application/json body
func NewSlurmdbV0041PostAccountsRequest(server string, body SlurmdbV0041PostAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostAccountsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostAccountsRequestWithBody generates requests for SlurmdbV0041PostAccounts with any type of body
func NewSlurmdbV0041PostAccountsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/accounts/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041PostAccountsAssociationRequest calls the generic SlurmdbV0041PostAccountsAssociation builder with application/json body
func NewSlurmdbV0041PostAccountsAssociationRequest(server string, body SlurmdbV0041PostAccountsAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostAccountsAssociationRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostAccountsAssociationRequestWithBody generates requests for SlurmdbV0041PostAccountsAssociation with any type of body
func NewSlurmdbV0041PostAccountsAssociationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/accounts_association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteAssociationRequest generates requests for SlurmdbV0041DeleteAssociation
func NewSlurmdbV0041DeleteAssociationRequest(server string, params *SlurmdbV0041DeleteAssociationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAssociationRequest generates requests for SlurmdbV0041GetAssociation
func NewSlurmdbV0041GetAssociationRequest(server string, params *SlurmdbV0041GetAssociationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041DeleteAssociationsRequest generates requests for SlurmdbV0041DeleteAssociations
func NewSlurmdbV0041DeleteAssociationsRequest(server string, params *SlurmdbV0041DeleteAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAssociationsRequest generates requests for SlurmdbV0041GetAssociations
func NewSlurmdbV0041GetAssociationsRequest(server string, params *SlurmdbV0041GetAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostAssociationsRequest calls the generic SlurmdbV0041PostAssociations builder with application/json body
func NewSlurmdbV0041PostAssociationsRequest(server string, body SlurmdbV0041PostAssociationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostAssociationsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostAssociationsRequestWithBody generates requests for SlurmdbV0041PostAssociations with any type of body
func NewSlurmdbV0041PostAssociationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteClusterRequest generates requests for SlurmdbV0041DeleteCluster
func NewSlurmdbV0041DeleteClusterRequest(server string, clusterName string, params *SlurmdbV0041DeleteClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_name", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Classification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "classification", runtime.ParamLocationQuery, *params.Classification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Federation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "federation", runtime.ParamLocationQuery, *params.Federation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RpcVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rpc_version", runtime.ParamLocationQuery, *params.RpcVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetClusterRequest generates requests for SlurmdbV0041GetCluster
func NewSlurmdbV0041GetClusterRequest(server string, clusterName string, params *SlurmdbV0041GetClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_name", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Classification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "classification", runtime.ParamLocationQuery, *params.Classification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Federation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "federation", runtime.ParamLocationQuery, *params.Federation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RpcVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rpc_version", runtime.ParamLocationQuery, *params.RpcVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetClustersRequest generates requests for SlurmdbV0041GetClusters
func NewSlurmdbV0041GetClustersRequest(server string, params *SlurmdbV0041GetClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/clusters/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostClustersRequest calls the generic SlurmdbV0041PostClusters builder with application/json body
func NewSlurmdbV0041PostClustersRequest(server string, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostClustersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostClustersRequestWithBody generates requests for SlurmdbV0041PostClusters with any type of body
func NewSlurmdbV0041PostClustersRequestWithBody(server string, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/clusters/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041GetConfigRequest generates requests for SlurmdbV0041GetConfig
func NewSlurmdbV0041GetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostConfigRequest calls the generic SlurmdbV0041PostConfig builder with application/json body
func NewSlurmdbV0041PostConfigRequest(server string, body SlurmdbV0041PostConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostConfigRequestWithBody generates requests for SlurmdbV0041PostConfig with any type of body
func NewSlurmdbV0041PostConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041GetDiagRequest generates requests for SlurmdbV0041GetDiag
func NewSlurmdbV0041GetDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/diag/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetInstanceRequest generates requests for SlurmdbV0041GetInstance
func NewSlurmdbV0041GetInstanceRequest(server string, params *SlurmdbV0041GetInstanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/instance/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Extra != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "extra", runtime.ParamLocationQuery, *params.Extra); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_id", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_type", runtime.ParamLocationQuery, *params.InstanceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodeList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node_list", runtime.ParamLocationQuery, *params.NodeList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_end", runtime.ParamLocationQuery, *params.TimeEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_start", runtime.ParamLocationQuery, *params.TimeStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetInstancesRequest generates requests for SlurmdbV0041GetInstances
func NewSlurmdbV0041GetInstancesRequest(server string, params *SlurmdbV0041GetInstancesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/instances/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Extra != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "extra", runtime.ParamLocationQuery, *params.Extra); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_id", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_type", runtime.ParamLocationQuery, *params.InstanceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodeList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node_list", runtime.ParamLocationQuery, *params.NodeList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_end", runtime.ParamLocationQuery, *params.TimeEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_start", runtime.ParamLocationQuery, *params.TimeStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetJobRequest generates requests for SlurmdbV0041GetJob
func NewSlurmdbV0041GetJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetJobsRequest generates requests for SlurmdbV0041GetJobs
func NewSlurmdbV0041GetJobsRequest(server string, params *SlurmdbV0041GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Association != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "association", runtime.ParamLocationQuery, *params.Association); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Constraints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "constraints", runtime.ParamLocationQuery, *params.Constraints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchedulerUnset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduler_unset", runtime.ParamLocationQuery, *params.SchedulerUnset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledOnSubmit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_on_submit", runtime.ParamLocationQuery, *params.ScheduledOnSubmit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledByMain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_by_main", runtime.ParamLocationQuery, *params.ScheduledByMain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledByBackfill != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_by_backfill", runtime.ParamLocationQuery, *params.ScheduledByBackfill); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobStarted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_started", runtime.ParamLocationQuery, *params.JobStarted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExitCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exit_code", runtime.ParamLocationQuery, *params.ExitCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowDuplicates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_duplicates", runtime.ParamLocationQuery, *params.ShowDuplicates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipSteps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "skip_steps", runtime.ParamLocationQuery, *params.SkipSteps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableTruncateUsageTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_truncate_usage_time", runtime.ParamLocationQuery, *params.DisableTruncateUsageTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WholeHetjob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "whole_hetjob", runtime.ParamLocationQuery, *params.WholeHetjob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableWholeHetjob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_whole_hetjob", runtime.ParamLocationQuery, *params.DisableWholeHetjob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableWaitForResult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_wait_for_result", runtime.ParamLocationQuery, *params.DisableWaitForResult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageTimeAsSubmitTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_time_as_submit_time", runtime.ParamLocationQuery, *params.UsageTimeAsSubmitTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowBatchScript != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_batch_script", runtime.ParamLocationQuery, *params.ShowBatchScript); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowJobEnvironment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_job_environment", runtime.ParamLocationQuery, *params.ShowJobEnvironment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Groups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "groups", runtime.ParamLocationQuery, *params.Groups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_name", runtime.ParamLocationQuery, *params.JobName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reason", runtime.ParamLocationQuery, *params.Reason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reservation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reservation", runtime.ParamLocationQuery, *params.Reservation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReservationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reservation_id", runtime.ParamLocationQuery, *params.ReservationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Step != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "step", runtime.ParamLocationQuery, *params.Step); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Node != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node", runtime.ParamLocationQuery, *params.Node); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Users != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "users", runtime.ParamLocationQuery, *params.Users); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Wckey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "wckey", runtime.ParamLocationQuery, *params.Wckey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetQosRequest generates requests for SlurmdbV0041GetQos
func NewSlurmdbV0041GetQosRequest(server string, params *SlurmdbV0041GetQosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreemptMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "preempt_mode", runtime.ParamLocationQuery, *params.PreemptMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostQosRequest calls the generic SlurmdbV0041PostQos builder with application/json body
func NewSlurmdbV0041PostQosRequest(server string, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostQosRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostQosRequestWithBody generates requests for SlurmdbV0041PostQos with any type of body
func NewSlurmdbV0041PostQosRequestWithBody(server string, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreemptMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "preempt_mode", runtime.ParamLocationQuery, *params.PreemptMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteSingleQosRequest generates requests for SlurmdbV0041DeleteSingleQos
func NewSlurmdbV0041DeleteSingleQosRequest(server string, qos string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "qos", runtime.ParamLocationPath, qos)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetSingleQosRequest generates requests for SlurmdbV0041GetSingleQos
func NewSlurmdbV0041GetSingleQosRequest(server string, qos string, params *SlurmdbV0041GetSingleQosParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "qos", runtime.ParamLocationPath, qos)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetTresRequest generates requests for SlurmdbV0041GetTres
func NewSlurmdbV0041GetTresRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/tres/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostTresRequest calls the generic SlurmdbV0041PostTres builder with application/json body
func NewSlurmdbV0041PostTresRequest(server string, body SlurmdbV0041PostTresJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostTresRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostTresRequestWithBody generates requests for SlurmdbV0041PostTres with any type of body
func NewSlurmdbV0041PostTresRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/tres/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteUserRequest generates requests for SlurmdbV0041DeleteUser
func NewSlurmdbV0041DeleteUserRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetUserRequest generates requests for SlurmdbV0041GetUser
func NewSlurmdbV0041GetUserRequest(server string, name string, params *SlurmdbV0041GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWckeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_wckeys", runtime.ParamLocationQuery, *params.WithWckeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetUsersRequest generates requests for SlurmdbV0041GetUsers
func NewSlurmdbV0041GetUsersRequest(server string, params *SlurmdbV0041GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/users/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AdminLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "admin_level", runtime.ParamLocationQuery, *params.AdminLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_account", runtime.ParamLocationQuery, *params.DefaultAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultWckey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_wckey", runtime.ParamLocationQuery, *params.DefaultWckey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWckeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_wckeys", runtime.ParamLocationQuery, *params.WithWckeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_defaults", runtime.ParamLocationQuery, *params.WithoutDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostUsersRequest calls the generic SlurmdbV0041PostUsers builder with application/json body
func NewSlurmdbV0041PostUsersRequest(server string, body SlurmdbV0041PostUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostUsersRequestWithBody generates requests for SlurmdbV0041PostUsers with any type of body
func NewSlurmdbV0041PostUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/users/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041PostUsersAssociationRequest calls the generic SlurmdbV0041PostUsersAssociation builder with application/json body
func NewSlurmdbV0041PostUsersAssociationRequest(server string, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostUsersAssociationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostUsersAssociationRequestWithBody generates requests for SlurmdbV0041PostUsersAssociation with any type of body
func NewSlurmdbV0041PostUsersAssociationRequestWithBody(server string, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/users_association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteWckeyRequest generates requests for SlurmdbV0041DeleteWckey
func NewSlurmdbV0041DeleteWckeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetWckeyRequest generates requests for SlurmdbV0041GetWckey
func NewSlurmdbV0041GetWckeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetWckeysRequest generates requests for SlurmdbV0041GetWckeys
func NewSlurmdbV0041GetWckeysRequest(server string, params *SlurmdbV0041GetWckeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckeys/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostWckeysRequest calls the generic SlurmdbV0041PostWckeys builder with application/json body
func NewSlurmdbV0041PostWckeysRequest(server string, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostWckeysRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostWckeysRequestWithBody generates requests for SlurmdbV0041PostWckeys with any type of body
func NewSlurmdbV0041PostWckeysRequestWithBody(server string, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckeys/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SlurmV0041GetDiagWithResponse request
	SlurmV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetDiagResponse, error)

	// SlurmV0041PostJobAllocateWithBodyWithResponse request with any body
	SlurmV0041PostJobAllocateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error)

	SlurmV0041PostJobAllocateWithResponse(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error)

	// SlurmV0041PostJobSubmitWithBodyWithResponse request with any body
	SlurmV0041PostJobSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error)

	SlurmV0041PostJobSubmitWithResponse(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error)

	// SlurmV0041DeleteJobWithResponse request
	SlurmV0041DeleteJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobResponse, error)

	// SlurmV0041GetJobWithResponse request
	SlurmV0041GetJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobResponse, error)

	// SlurmV0041PostJobWithBodyWithResponse request with any body
	SlurmV0041PostJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error)

	SlurmV0041PostJobWithResponse(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error)

	// SlurmV0041DeleteJobsWithBodyWithResponse request with any body
	SlurmV0041DeleteJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error)

	SlurmV0041DeleteJobsWithResponse(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error)

	// SlurmV0041GetJobsWithResponse request
	SlurmV0041GetJobsWithResponse(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsResponse, error)

	// SlurmV0041GetJobsStateWithResponse request
	SlurmV0041GetJobsStateWithResponse(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsStateResponse, error)

	// SlurmV0041GetLicensesWithResponse request
	SlurmV0041GetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetLicensesResponse, error)

	// SlurmV0041DeleteNodeWithResponse request
	SlurmV0041DeleteNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteNodeResponse, error)

	// SlurmV0041GetNodeWithResponse request
	SlurmV0041GetNodeWithResponse(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodeResponse, error)

	// SlurmV0041PostNodeWithBodyWithResponse request with any body
	SlurmV0041PostNodeWithBodyWithResponse(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error)

	SlurmV0041PostNodeWithResponse(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error)

	// SlurmV0041GetNodesWithResponse request
	SlurmV0041GetNodesWithResponse(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodesResponse, error)

	// SlurmV0041PostNodesWithBodyWithResponse request with any body
	SlurmV0041PostNodesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodesResponse, error)

	SlurmV0041PostNodesWithResponse(ctx context.Context, body SlurmV0041PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodesResponse, error)

	// SlurmV0041GetPartitionWithResponse request
	SlurmV0041GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionResponse, error)

	// SlurmV0041GetPartitionsWithResponse request
	SlurmV0041GetPartitionsWithResponse(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionsResponse, error)

	// SlurmV0041GetPingWithResponse request
	SlurmV0041GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetPingResponse, error)

	// SlurmV0041GetReconfigureWithResponse request
	SlurmV0041GetReconfigureWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetReconfigureResponse, error)

	// SlurmV0041DeleteReservationWithResponse request
	SlurmV0041DeleteReservationWithResponse(ctx context.Context, reservationName string, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteReservationResponse, error)

	// SlurmV0041GetReservationWithResponse request
	SlurmV0041GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationResponse, error)

	// SlurmV0041GetReservationsWithResponse request
	SlurmV0041GetReservationsWithResponse(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationsResponse, error)

	// SlurmV0041GetSharesWithResponse request
	SlurmV0041GetSharesWithResponse(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetSharesResponse, error)

	// SlurmdbV0041DeleteAccountWithResponse request
	SlurmdbV0041DeleteAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAccountResponse, error)

	// SlurmdbV0041GetAccountWithResponse request
	SlurmdbV0041GetAccountWithResponse(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountResponse, error)

	// SlurmdbV0041GetAccountsWithResponse request
	SlurmdbV0041GetAccountsWithResponse(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountsResponse, error)

	// SlurmdbV0041PostAccountsWithBodyWithResponse request with any body
	SlurmdbV0041PostAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error)

	SlurmdbV0041PostAccountsWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error)

	// SlurmdbV0041PostAccountsAssociationWithBodyWithResponse request with any body
	SlurmdbV0041PostAccountsAssociationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error)

	SlurmdbV0041PostAccountsAssociationWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error)

	// SlurmdbV0041DeleteAssociationWithResponse request
	SlurmdbV0041DeleteAssociationWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationResponse, error)

	// SlurmdbV0041GetAssociationWithResponse request
	SlurmdbV0041GetAssociationWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationResponse, error)

	// SlurmdbV0041DeleteAssociationsWithResponse request
	SlurmdbV0041DeleteAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationsResponse, error)

	// SlurmdbV0041GetAssociationsWithResponse request
	SlurmdbV0041GetAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationsResponse, error)

	// SlurmdbV0041PostAssociationsWithBodyWithResponse request with any body
	SlurmdbV0041PostAssociationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error)

	SlurmdbV0041PostAssociationsWithResponse(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error)

	// SlurmdbV0041DeleteClusterWithResponse request
	SlurmdbV0041DeleteClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteClusterResponse, error)

	// SlurmdbV0041GetClusterWithResponse request
	SlurmdbV0041GetClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClusterResponse, error)

	// SlurmdbV0041GetClustersWithResponse request
	SlurmdbV0041GetClustersWithResponse(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClustersResponse, error)

	// SlurmdbV0041PostClustersWithBodyWithResponse request with any body
	SlurmdbV0041PostClustersWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error)

	SlurmdbV0041PostClustersWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error)

	// SlurmdbV0041GetConfigWithResponse request
	SlurmdbV0041GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetConfigResponse, error)

	// SlurmdbV0041PostConfigWithBodyWithResponse request with any body
	SlurmdbV0041PostConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error)

	SlurmdbV0041PostConfigWithResponse(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error)

	// SlurmdbV0041GetDiagWithResponse request
	SlurmdbV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetDiagResponse, error)

	// SlurmdbV0041GetInstanceWithResponse request
	SlurmdbV0041GetInstanceWithResponse(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstanceResponse, error)

	// SlurmdbV0041GetInstancesWithResponse request
	SlurmdbV0041GetInstancesWithResponse(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstancesResponse, error)

	// SlurmdbV0041GetJobWithResponse request
	SlurmdbV0041GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobResponse, error)

	// SlurmdbV0041GetJobsWithResponse request
	SlurmdbV0041GetJobsWithResponse(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobsResponse, error)

	// SlurmdbV0041GetQosWithResponse request
	SlurmdbV0041GetQosWithResponse(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetQosResponse, error)

	// SlurmdbV0041PostQosWithBodyWithResponse request with any body
	SlurmdbV0041PostQosWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error)

	SlurmdbV0041PostQosWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error)

	// SlurmdbV0041DeleteSingleQosWithResponse request
	SlurmdbV0041DeleteSingleQosWithResponse(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteSingleQosResponse, error)

	// SlurmdbV0041GetSingleQosWithResponse request
	SlurmdbV0041GetSingleQosWithResponse(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetSingleQosResponse, error)

	// SlurmdbV0041GetTresWithResponse request
	SlurmdbV0041GetTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetTresResponse, error)

	// SlurmdbV0041PostTresWithBodyWithResponse request with any body
	SlurmdbV0041PostTresWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error)

	SlurmdbV0041PostTresWithResponse(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error)

	// SlurmdbV0041DeleteUserWithResponse request
	SlurmdbV0041DeleteUserWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteUserResponse, error)

	// SlurmdbV0041GetUserWithResponse request
	SlurmdbV0041GetUserWithResponse(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUserResponse, error)

	// SlurmdbV0041GetUsersWithResponse request
	SlurmdbV0041GetUsersWithResponse(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUsersResponse, error)

	// SlurmdbV0041PostUsersWithBodyWithResponse request with any body
	SlurmdbV0041PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error)

	SlurmdbV0041PostUsersWithResponse(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error)

	// SlurmdbV0041PostUsersAssociationWithBodyWithResponse request with any body
	SlurmdbV0041PostUsersAssociationWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error)

	SlurmdbV0041PostUsersAssociationWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error)

	// SlurmdbV0041DeleteWckeyWithResponse request
	SlurmdbV0041DeleteWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteWckeyResponse, error)

	// SlurmdbV0041GetWckeyWithResponse request
	SlurmdbV0041GetWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeyResponse, error)

	// SlurmdbV0041GetWckeysWithResponse request
	SlurmdbV0041GetWckeysWithResponse(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeysResponse, error)

	// SlurmdbV0041PostWckeysWithBodyWithResponse request with any body
	SlurmdbV0041PostWckeysWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error)

	SlurmdbV0041PostWckeysWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error)
}

type SlurmV0041GetDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Statistics statistics
		Statistics struct {
			// AgentCount Number of agent threads
			AgentCount *int32 `json:"agent_count,omitempty"`

			// AgentQueueSize Number of enqueued outgoing RPC requests in an internal retry list
			AgentQueueSize *int32 `json:"agent_queue_size,omitempty"`

			// AgentThreadCount Total number of active threads created by all agent threads
			AgentThreadCount *int32 `json:"agent_thread_count,omitempty"`

			// BfActive Backfill scheduler currently running
			BfActive *bool `json:"bf_active,omitempty"`

			// BfBackfilledHetJobs Number of heterogeneous job components started through backfilling since last Slurm start
			BfBackfilledHetJobs *int32 `json:"bf_backfilled_het_jobs,omitempty"`

			// BfBackfilledJobs Number of jobs started through backfilling since last slurm start
			BfBackfilledJobs *int32 `json:"bf_backfilled_jobs,omitempty"`

			// BfCycleCounter Number of backfill scheduling cycles since last reset
			BfCycleCounter *int32 `json:"bf_cycle_counter,omitempty"`

			// BfCycleLast Execution time in microseconds of last backfill scheduling cycle
			BfCycleLast *int32 `json:"bf_cycle_last,omitempty"`

			// BfCycleMax Execution time in microseconds of longest backfill scheduling cycle
			BfCycleMax *int32 `json:"bf_cycle_max,omitempty"`

			// BfCycleMean Mean time in microseconds of backfilling scheduling cycles since last reset
			BfCycleMean *int64 `json:"bf_cycle_mean,omitempty"`

			// BfCycleSum Total time in microseconds of backfilling scheduling cycles since last reset
			BfCycleSum *int64 `json:"bf_cycle_sum,omitempty"`

			// BfDepthMean Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
			BfDepthMean *int64 `json:"bf_depth_mean,omitempty"`

			// BfDepthMeanTry The subset of Depth Mean that the backfill scheduler attempted to schedule
			BfDepthMeanTry *int64 `json:"bf_depth_mean_try,omitempty"`

			// BfDepthSum Total number of jobs processed during all backfilling scheduling cycles since last reset
			BfDepthSum *int32 `json:"bf_depth_sum,omitempty"`

			// BfDepthTrySum Subset of bf_depth_sum that the backfill scheduler attempted to schedule
			BfDepthTrySum *int32 `json:"bf_depth_try_sum,omitempty"`

			// BfExit Reasons for which the backfill scheduling cycle exited since last reset
			BfExit *struct {
				// BfMaxJobStart Reached number of jobs allowed to start
				BfMaxJobStart *int32 `json:"bf_max_job_start,omitempty"`

				// BfMaxJobTest Reached number of jobs allowed to be tested
				BfMaxJobTest *int32 `json:"bf_max_job_test,omitempty"`

				// BfMaxTime Reached maximum allowed scheduler time
				BfMaxTime *int32 `json:"bf_max_time,omitempty"`

				// BfNodeSpaceSize Reached table size limit
				BfNodeSpaceSize *int32 `json:"bf_node_space_size,omitempty"`

				// EndJobQueue Reached end of queue
				EndJobQueue *int32 `json:"end_job_queue,omitempty"`

				// StateChanged System state changed
				StateChanged *int32 `json:"state_changed,omitempty"`
			} `json:"bf_exit,omitempty"`

			// BfLastBackfilledJobs Number of jobs started through backfilling since last reset
			BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`

			// BfLastDepth Number of processed jobs during last backfilling scheduling cycle
			BfLastDepth *int32 `json:"bf_last_depth,omitempty"`

			// BfLastDepthTry Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
			BfLastDepthTry *int32 `json:"bf_last_depth_try,omitempty"`

			// BfQueueLen Number of jobs pending to be processed by backfilling algorithm
			BfQueueLen *int32 `json:"bf_queue_len,omitempty"`

			// BfQueueLenMean Mean number of jobs pending to be processed by backfilling algorithm
			BfQueueLenMean *int64 `json:"bf_queue_len_mean,omitempty"`

			// BfQueueLenSum Total number of jobs pending to be processed by backfilling algorithm since last reset
			BfQueueLenSum *int32 `json:"bf_queue_len_sum,omitempty"`

			// BfTableSize Number of different time slots tested by the backfill scheduler in its last iteration
			BfTableSize *int32 `json:"bf_table_size,omitempty"`

			// BfTableSizeMean Mean number of different time slots tested by the backfill scheduler
			BfTableSizeMean *int64 `json:"bf_table_size_mean,omitempty"`

			// BfTableSizeSum Total number of different time slots tested by the backfill scheduler
			BfTableSizeSum *int32 `json:"bf_table_size_sum,omitempty"`

			// BfWhenLastCycle When the last backfill scheduling cycle happened (UNIX timestamp)
			BfWhenLastCycle *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"bf_when_last_cycle,omitempty"`

			// DbdAgentQueueSize Number of messages for SlurmDBD that are queued
			DbdAgentQueueSize *int32 `json:"dbd_agent_queue_size,omitempty"`

			// GettimeofdayLatency Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
			GettimeofdayLatency *int32 `json:"gettimeofday_latency,omitempty"`

			// JobStatesTs When the job state counts were gathered (UNIX timestamp)
			JobStatesTs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"job_states_ts,omitempty"`

			// JobsCanceled Number of jobs canceled since the last reset
			JobsCanceled *int32 `json:"jobs_canceled,omitempty"`

			// JobsCompleted Number of jobs completed since last reset
			JobsCompleted *int32 `json:"jobs_completed,omitempty"`

			// JobsFailed Number of jobs failed due to slurmd or other internal issues since last reset
			JobsFailed *int32 `json:"jobs_failed,omitempty"`

			// JobsPending Number of jobs pending at the time of listed in job_state_ts
			JobsPending *int32 `json:"jobs_pending,omitempty"`

			// JobsRunning Number of jobs running at the time of listed in job_state_ts
			JobsRunning *int32 `json:"jobs_running,omitempty"`

			// JobsStarted Number of jobs started since last reset
			JobsStarted *int32 `json:"jobs_started,omitempty"`

			// JobsSubmitted Number of jobs submitted since last reset
			JobsSubmitted *int32 `json:"jobs_submitted,omitempty"`

			// PartsPacked Zero if only RPC statistic included
			PartsPacked *int32 `json:"parts_packed,omitempty"`

			// PendingRpcs Pending RPC statistics
			PendingRpcs *[]struct {
				// Count Number of pending RPCs queued
				Count int32 `json:"count"`

				// MessageType Message type as string
				MessageType string `json:"message_type"`

				// TypeId Message type as integer
				TypeId int32 `json:"type_id"`
			} `json:"pending_rpcs,omitempty"`

			// PendingRpcsByHostlist Pending RPCs hostlists
			PendingRpcsByHostlist *[]struct {
				// Count Number of RPCs received
				Count []string `json:"count"`

				// MessageType Message type as string
				MessageType string `json:"message_type"`

				// TypeId Message type as integer
				TypeId int32 `json:"type_id"`
			} `json:"pending_rpcs_by_hostlist,omitempty"`

			// ReqTime When the request was made (UNIX timestamp)
			ReqTime *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"req_time,omitempty"`

			// ReqTimeStart When the data in the report started (UNIX timestamp)
			ReqTimeStart *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"req_time_start,omitempty"`

			// RpcsByMessageType Most frequently issued remote procedure calls (RPCs)
			RpcsByMessageType *[]struct {
				// AverageTime Average time spent processing RPC in seconds
				AverageTime struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"average_time"`

				// Count Number of RPCs received
				Count int32 `json:"count"`

				// CycleLast Number of RPCs processed within the last RPC queue cycle
				CycleLast int32 `json:"cycle_last"`

				// CycleMax Maximum number of RPCs processed within a RPC queue cycle since start
				CycleMax int32 `json:"cycle_max"`

				// Dropped Number of RPCs dropped
				Dropped int64 `json:"dropped"`

				// MessageType Message type as string
				MessageType string `json:"message_type"`

				// Queued Number of RPCs queued
				Queued int32 `json:"queued"`

				// TotalTime Total time spent processing RPC in seconds
				TotalTime int64 `json:"total_time"`

				// TypeId Message type as integer
				TypeId int32 `json:"type_id"`
			} `json:"rpcs_by_message_type,omitempty"`

			// RpcsByUser RPCs issued by user ID
			RpcsByUser *[]struct {
				// AverageTime Average time spent processing RPC in seconds
				AverageTime struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"average_time"`

				// Count Number of RPCs received
				Count int32 `json:"count"`

				// TotalTime Total time spent processing RPC in seconds
				TotalTime int64 `json:"total_time"`

				// User User name
				User string `json:"user"`

				// UserId User ID (numeric)
				UserId int32 `json:"user_id"`
			} `json:"rpcs_by_user,omitempty"`

			// ScheduleCycleDepth Total number of jobs processed in scheduling cycles
			ScheduleCycleDepth *int32 `json:"schedule_cycle_depth,omitempty"`

			// ScheduleCycleLast Time in microseconds for last scheduling cycle
			ScheduleCycleLast *int32 `json:"schedule_cycle_last,omitempty"`

			// ScheduleCycleMax Max time of any scheduling cycle in microseconds since last reset
			ScheduleCycleMax *int32 `json:"schedule_cycle_max,omitempty"`

			// ScheduleCycleMean Mean time in microseconds for all scheduling cycles since last reset
			ScheduleCycleMean *int64 `json:"schedule_cycle_mean,omitempty"`

			// ScheduleCycleMeanDepth Mean of the number of jobs processed in a scheduling cycle
			ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`

			// ScheduleCyclePerMinute Number of scheduling executions per minute
			ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`

			// ScheduleCycleSum Total run time in microseconds for all scheduling cycles since last reset
			ScheduleCycleSum *int32 `json:"schedule_cycle_sum,omitempty"`

			// ScheduleCycleTotal Number of scheduling cycles since last reset
			ScheduleCycleTotal *int32 `json:"schedule_cycle_total,omitempty"`

			// ScheduleExit Reasons for which the scheduling cycle exited since last reset
			ScheduleExit *struct {
				// DefaultQueueDepth Reached number of jobs allowed to be tested
				DefaultQueueDepth *int32 `json:"default_queue_depth,omitempty"`

				// EndJobQueue Reached end of queue
				EndJobQueue *int32 `json:"end_job_queue,omitempty"`

				// Licenses Blocked on licenses
				Licenses *int32 `json:"licenses,omitempty"`

				// MaxJobStart Reached number of jobs allowed to start
				MaxJobStart *int32 `json:"max_job_start,omitempty"`

				// MaxRpcCnt Reached RPC limit
				MaxRpcCnt *int32 `json:"max_rpc_cnt,omitempty"`

				// MaxSchedTime Reached maximum allowed scheduler time
				MaxSchedTime *int32 `json:"max_sched_time,omitempty"`
			} `json:"schedule_exit,omitempty"`

			// ScheduleQueueLength Number of jobs pending in queue
			ScheduleQueueLength *int32 `json:"schedule_queue_length,omitempty"`

			// ServerThreadCount Number of current active slurmctld threads
			ServerThreadCount *int32 `json:"server_thread_count,omitempty"`
		} `json:"statistics"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Statistics statistics
		Statistics struct {
			// AgentCount Number of agent threads
			AgentCount *int32 `json:"agent_count,omitempty"`

			// AgentQueueSize Number of enqueued outgoing RPC requests in an internal retry list
			AgentQueueSize *int32 `json:"agent_queue_size,omitempty"`

			// AgentThreadCount Total number of active threads created by all agent threads
			AgentThreadCount *int32 `json:"agent_thread_count,omitempty"`

			// BfActive Backfill scheduler currently running
			BfActive *bool `json:"bf_active,omitempty"`

			// BfBackfilledHetJobs Number of heterogeneous job components started through backfilling since last Slurm start
			BfBackfilledHetJobs *int32 `json:"bf_backfilled_het_jobs,omitempty"`

			// BfBackfilledJobs Number of jobs started through backfilling since last slurm start
			BfBackfilledJobs *int32 `json:"bf_backfilled_jobs,omitempty"`

			// BfCycleCounter Number of backfill scheduling cycles since last reset
			BfCycleCounter *int32 `json:"bf_cycle_counter,omitempty"`

			// BfCycleLast Execution time in microseconds of last backfill scheduling cycle
			BfCycleLast *int32 `json:"bf_cycle_last,omitempty"`

			// BfCycleMax Execution time in microseconds of longest backfill scheduling cycle
			BfCycleMax *int32 `json:"bf_cycle_max,omitempty"`

			// BfCycleMean Mean time in microseconds of backfilling scheduling cycles since last reset
			BfCycleMean *int64 `json:"bf_cycle_mean,omitempty"`

			// BfCycleSum Total time in microseconds of backfilling scheduling cycles since last reset
			BfCycleSum *int64 `json:"bf_cycle_sum,omitempty"`

			// BfDepthMean Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
			BfDepthMean *int64 `json:"bf_depth_mean,omitempty"`

			// BfDepthMeanTry The subset of Depth Mean that the backfill scheduler attempted to schedule
			BfDepthMeanTry *int64 `json:"bf_depth_mean_try,omitempty"`

			// BfDepthSum Total number of jobs processed during all backfilling scheduling cycles since last reset
			BfDepthSum *int32 `json:"bf_depth_sum,omitempty"`

			// BfDepthTrySum Subset of bf_depth_sum that the backfill scheduler attempted to schedule
			BfDepthTrySum *int32 `json:"bf_depth_try_sum,omitempty"`

			// BfExit Reasons for which the backfill scheduling cycle exited since last reset
			BfExit *struct {
				// BfMaxJobStart Reached number of jobs allowed to start
				BfMaxJobStart *int32 `json:"bf_max_job_start,omitempty"`

				// BfMaxJobTest Reached number of jobs allowed to be tested
				BfMaxJobTest *int32 `json:"bf_max_job_test,omitempty"`

				// BfMaxTime Reached maximum allowed scheduler time
				BfMaxTime *int32 `json:"bf_max_time,omitempty"`

				// BfNodeSpaceSize Reached table size limit
				BfNodeSpaceSize *int32 `json:"bf_node_space_size,omitempty"`

				// EndJobQueue Reached end of queue
				EndJobQueue *int32 `json:"end_job_queue,omitempty"`

				// StateChanged System state changed
				StateChanged *int32 `json:"state_changed,omitempty"`
			} `json:"bf_exit,omitempty"`

			// BfLastBackfilledJobs Number of jobs started through backfilling since last reset
			BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`

			// BfLastDepth Number of processed jobs during last backfilling scheduling cycle
			BfLastDepth *int32 `json:"bf_last_depth,omitempty"`

			// BfLastDepthTry Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
			BfLastDepthTry *int32 `json:"bf_last_depth_try,omitempty"`

			// BfQueueLen Number of jobs pending to be processed by backfilling algorithm
			BfQueueLen *int32 `json:"bf_queue_len,omitempty"`

			// BfQueueLenMean Mean number of jobs pending to be processed by backfilling algorithm
			BfQueueLenMean *int64 `json:"bf_queue_len_mean,omitempty"`

			// BfQueueLenSum Total number of jobs pending to be processed by backfilling algorithm since last reset
			BfQueueLenSum *int32 `json:"bf_queue_len_sum,omitempty"`

			// BfTableSize Number of different time slots tested by the backfill scheduler in its last iteration
			BfTableSize *int32 `json:"bf_table_size,omitempty"`

			// BfTableSizeMean Mean number of different time slots tested by the backfill scheduler
			BfTableSizeMean *int64 `json:"bf_table_size_mean,omitempty"`

			// BfTableSizeSum Total number of different time slots tested by the backfill scheduler
			BfTableSizeSum *int32 `json:"bf_table_size_sum,omitempty"`

			// BfWhenLastCycle When the last backfill scheduling cycle happened (UNIX timestamp)
			BfWhenLastCycle *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"bf_when_last_cycle,omitempty"`

			// DbdAgentQueueSize Number of messages for SlurmDBD that are queued
			DbdAgentQueueSize *int32 `json:"dbd_agent_queue_size,omitempty"`

			// GettimeofdayLatency Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
			GettimeofdayLatency *int32 `json:"gettimeofday_latency,omitempty"`

			// JobStatesTs When the job state counts were gathered (UNIX timestamp)
			JobStatesTs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"job_states_ts,omitempty"`

			// JobsCanceled Number of jobs canceled since the last reset
			JobsCanceled *int32 `json:"jobs_canceled,omitempty"`

			// JobsCompleted Number of jobs completed since last reset
			JobsCompleted *int32 `json:"jobs_completed,omitempty"`

			// JobsFailed Number of jobs failed due to slurmd or other internal issues since last reset
			JobsFailed *int32 `json:"jobs_failed,omitempty"`

			// JobsPending Number of jobs pending at the time of listed in job_state_ts
			JobsPending *int32 `json:"jobs_pending,omitempty"`

			// JobsRunning Number of jobs running at the time of listed in job_state_ts
			JobsRunning *int32 `json:"jobs_running,omitempty"`

			// JobsStarted Number of jobs started since last reset
			JobsStarted *int32 `json:"jobs_started,omitempty"`

			// JobsSubmitted Number of jobs submitted since last reset
			JobsSubmitted *int32 `json:"jobs_submitted,omitempty"`

			// PartsPacked Zero if only RPC statistic included
			PartsPacked *int32 `json:"parts_packed,omitempty"`

			// PendingRpcs Pending RPC statistics
			PendingRpcs *[]struct {
				// Count Number of pending RPCs queued
				Count int32 `json:"count"`

				// MessageType Message type as string
				MessageType string `json:"message_type"`

				// TypeId Message type as integer
				TypeId int32 `json:"type_id"`
			} `json:"pending_rpcs,omitempty"`

			// PendingRpcsByHostlist Pending RPCs hostlists
			PendingRpcsByHostlist *[]struct {
				// Count Number of RPCs received
				Count []string `json:"count"`

				// MessageType Message type as string
				MessageType string `json:"message_type"`

				// TypeId Message type as integer
				TypeId int32 `json:"type_id"`
			} `json:"pending_rpcs_by_hostlist,omitempty"`

			// ReqTime When the request was made (UNIX timestamp)
			ReqTime *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"req_time,omitempty"`

			// ReqTimeStart When the data in the report started (UNIX timestamp)
			ReqTimeStart *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"req_time_start,omitempty"`

			// RpcsByMessageType Most frequently issued remote procedure calls (RPCs)
			RpcsByMessageType *[]struct {
				// AverageTime Average time spent processing RPC in seconds
				AverageTime struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"average_time"`

				// Count Number of RPCs received
				Count int32 `json:"count"`

				// CycleLast Number of RPCs processed within the last RPC queue cycle
				CycleLast int32 `json:"cycle_last"`

				// CycleMax Maximum number of RPCs processed within a RPC queue cycle since start
				CycleMax int32 `json:"cycle_max"`

				// Dropped Number of RPCs dropped
				Dropped int64 `json:"dropped"`

				// MessageType Message type as string
				MessageType string `json:"message_type"`

				// Queued Number of RPCs queued
				Queued int32 `json:"queued"`

				// TotalTime Total time spent processing RPC in seconds
				TotalTime int64 `json:"total_time"`

				// TypeId Message type as integer
				TypeId int32 `json:"type_id"`
			} `json:"rpcs_by_message_type,omitempty"`

			// RpcsByUser RPCs issued by user ID
			RpcsByUser *[]struct {
				// AverageTime Average time spent processing RPC in seconds
				AverageTime struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"average_time"`

				// Count Number of RPCs received
				Count int32 `json:"count"`

				// TotalTime Total time spent processing RPC in seconds
				TotalTime int64 `json:"total_time"`

				// User User name
				User string `json:"user"`

				// UserId User ID (numeric)
				UserId int32 `json:"user_id"`
			} `json:"rpcs_by_user,omitempty"`

			// ScheduleCycleDepth Total number of jobs processed in scheduling cycles
			ScheduleCycleDepth *int32 `json:"schedule_cycle_depth,omitempty"`

			// ScheduleCycleLast Time in microseconds for last scheduling cycle
			ScheduleCycleLast *int32 `json:"schedule_cycle_last,omitempty"`

			// ScheduleCycleMax Max time of any scheduling cycle in microseconds since last reset
			ScheduleCycleMax *int32 `json:"schedule_cycle_max,omitempty"`

			// ScheduleCycleMean Mean time in microseconds for all scheduling cycles since last reset
			ScheduleCycleMean *int64 `json:"schedule_cycle_mean,omitempty"`

			// ScheduleCycleMeanDepth Mean of the number of jobs processed in a scheduling cycle
			ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`

			// ScheduleCyclePerMinute Number of scheduling executions per minute
			ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`

			// ScheduleCycleSum Total run time in microseconds for all scheduling cycles since last reset
			ScheduleCycleSum *int32 `json:"schedule_cycle_sum,omitempty"`

			// ScheduleCycleTotal Number of scheduling cycles since last reset
			ScheduleCycleTotal *int32 `json:"schedule_cycle_total,omitempty"`

			// ScheduleExit Reasons for which the scheduling cycle exited since last reset
			ScheduleExit *struct {
				// DefaultQueueDepth Reached number of jobs allowed to be tested
				DefaultQueueDepth *int32 `json:"default_queue_depth,omitempty"`

				// EndJobQueue Reached end of queue
				EndJobQueue *int32 `json:"end_job_queue,omitempty"`

				// Licenses Blocked on licenses
				Licenses *int32 `json:"licenses,omitempty"`

				// MaxJobStart Reached number of jobs allowed to start
				MaxJobStart *int32 `json:"max_job_start,omitempty"`

				// MaxRpcCnt Reached RPC limit
				MaxRpcCnt *int32 `json:"max_rpc_cnt,omitempty"`

				// MaxSchedTime Reached maximum allowed scheduler time
				MaxSchedTime *int32 `json:"max_sched_time,omitempty"`
			} `json:"schedule_exit,omitempty"`

			// ScheduleQueueLength Number of jobs pending in queue
			ScheduleQueueLength *int32 `json:"schedule_queue_length,omitempty"`

			// ServerThreadCount Number of current active slurmctld threads
			ServerThreadCount *int32 `json:"server_thread_count,omitempty"`
		} `json:"statistics"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostJobAllocateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId Submitted Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// JobSubmitUserMsg Job submission user message
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId Submitted Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// JobSubmitUserMsg Job submission user message
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostJobAllocateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostJobAllocateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostJobSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId Submitted Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// JobSubmitUserMsg Job submission user message
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Result Job submission
		// Deprecated:
		Result *struct {
			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorCode Error code
			ErrorCode *int32 `json:"error_code,omitempty"`

			// JobId New job ID
			JobId *int32 `json:"job_id,omitempty"`

			// JobSubmitUserMsg Message to user from job_submit plugin
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// StepId New job step ID
			StepId *string `json:"step_id,omitempty"`
		} `json:"result,omitempty"`

		// StepId Submitted Step ID
		StepId *string `json:"step_id,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId Submitted Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// JobSubmitUserMsg Job submission user message
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Result Job submission
		// Deprecated:
		Result *struct {
			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorCode Error code
			ErrorCode *int32 `json:"error_code,omitempty"`

			// JobId New job ID
			JobId *int32 `json:"job_id,omitempty"`

			// JobSubmitUserMsg Message to user from job_submit plugin
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// StepId New job step ID
			StepId *string `json:"step_id,omitempty"`
		} `json:"result,omitempty"`

		// StepId Submitted Step ID
		StepId *string `json:"step_id,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostJobSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostJobSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobInfoResp
	JSONDefault  *V0041OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId First updated Job ID - Use results instead
		// Deprecated:
		JobId *string `json:"job_id,omitempty"`

		// JobSubmitUserMsg First updated Job submission user message - Use results instead
		// Deprecated:
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Results Job update results
		Results *[]struct {
			// Error Verbose update status or error
			Error *string `json:"error,omitempty"`

			// ErrorCode Verbose update status or error
			ErrorCode *int32 `json:"error_code,omitempty"`

			// JobId Job ID for updated job
			JobId *int32 `json:"job_id,omitempty"`

			// StepId Step ID for updated job
			StepId *string `json:"step_id,omitempty"`

			// Why Update response message
			Why *string `json:"why,omitempty"`
		} `json:"results,omitempty"`

		// StepId First updated Step ID - Use results instead
		// Deprecated:
		StepId *string `json:"step_id,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId First updated Job ID - Use results instead
		// Deprecated:
		JobId *string `json:"job_id,omitempty"`

		// JobSubmitUserMsg First updated Job submission user message - Use results instead
		// Deprecated:
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Results Job update results
		Results *[]struct {
			// Error Verbose update status or error
			Error *string `json:"error,omitempty"`

			// ErrorCode Verbose update status or error
			ErrorCode *int32 `json:"error_code,omitempty"`

			// JobId Job ID for updated job
			JobId *int32 `json:"job_id,omitempty"`

			// StepId Step ID for updated job
			StepId *string `json:"step_id,omitempty"`

			// Why Update response message
			Why *string `json:"why,omitempty"`
		} `json:"results,omitempty"`

		// StepId First updated Step ID - Use results instead
		// Deprecated:
		StepId *string `json:"step_id,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Status resultant status of signal request
		Status []struct {
			Error *struct {
				// Code Numeric error encountered signaling job
				Code *int32 `json:"code,omitempty"`

				// Message Error message why signaling job failed
				Message *string `json:"message,omitempty"`

				// String String error encountered signaling job
				String *string `json:"string,omitempty"`
			} `json:"error,omitempty"`
			Federation *struct {
				// Sibling Name of federation sibling (may be empty for non-federation)
				Sibling *string `json:"sibling,omitempty"`
			} `json:"federation,omitempty"`

			// JobId Job ID that signaling failed
			JobId struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"job_id"`

			// StepId Job or Step ID that signaling failed
			StepId string `json:"step_id"`
		} `json:"status"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Status resultant status of signal request
		Status []struct {
			Error *struct {
				// Code Numeric error encountered signaling job
				Code *int32 `json:"code,omitempty"`

				// Message Error message why signaling job failed
				Message *string `json:"message,omitempty"`

				// String String error encountered signaling job
				String *string `json:"string,omitempty"`
			} `json:"error,omitempty"`
			Federation *struct {
				// Sibling Name of federation sibling (may be empty for non-federation)
				Sibling *string `json:"sibling,omitempty"`
			} `json:"federation,omitempty"`

			// JobId Job ID that signaling failed
			JobId struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"job_id"`

			// StepId Job or Step ID that signaling failed
			StepId string `json:"step_id"`
		} `json:"status"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobInfoResp
	JSONDefault  *V0041OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetJobsStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobInfoResp
	JSONDefault  *V0041OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetJobsStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetJobsStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetLicensesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// LastUpdate Time of last licenses change (UNIX timestamp)
		LastUpdate struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"last_update"`

		// Licenses List of licenses
		Licenses []struct {
			// Free Number of licenses currently available
			Free *int32 `json:"Free,omitempty"`

			// LastConsumed Last known number of licenses that were consumed in the license manager (Remote Only)
			LastConsumed *int32 `json:"LastConsumed,omitempty"`

			// LastDeficit Number of "missing licenses" from the cluster's perspective
			LastDeficit *int32 `json:"LastDeficit,omitempty"`

			// LastUpdate When the license information was last updated (UNIX Timestamp)
			LastUpdate *int64 `json:"LastUpdate,omitempty"`

			// LicenseName Name of the license
			LicenseName *string `json:"LicenseName,omitempty"`

			// Remote Indicates whether licenses are served by the database
			Remote *bool `json:"Remote,omitempty"`

			// Reserved Number of licenses reserved
			Reserved *int32 `json:"Reserved,omitempty"`

			// Total Total number of licenses present
			Total *int32 `json:"Total,omitempty"`

			// Used Number of licenses in use
			Used *int32 `json:"Used,omitempty"`
		} `json:"licenses"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// LastUpdate Time of last licenses change (UNIX timestamp)
		LastUpdate struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"last_update"`

		// Licenses List of licenses
		Licenses []struct {
			// Free Number of licenses currently available
			Free *int32 `json:"Free,omitempty"`

			// LastConsumed Last known number of licenses that were consumed in the license manager (Remote Only)
			LastConsumed *int32 `json:"LastConsumed,omitempty"`

			// LastDeficit Number of "missing licenses" from the cluster's perspective
			LastDeficit *int32 `json:"LastDeficit,omitempty"`

			// LastUpdate When the license information was last updated (UNIX Timestamp)
			LastUpdate *int64 `json:"LastUpdate,omitempty"`

			// LicenseName Name of the license
			LicenseName *string `json:"LicenseName,omitempty"`

			// Remote Indicates whether licenses are served by the database
			Remote *bool `json:"Remote,omitempty"`

			// Reserved Number of licenses reserved
			Reserved *int32 `json:"Reserved,omitempty"`

			// Total Total number of licenses present
			Total *int32 `json:"Total,omitempty"`

			// Used Number of licenses in use
			Used *int32 `json:"Used,omitempty"`
		} `json:"licenses"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetLicensesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetLicensesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiNodesResp
	JSONDefault  *V0041OpenapiNodesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiNodesResp
	JSONDefault  *V0041OpenapiNodesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetPartitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiPartitionResp
	JSONDefault  *V0041OpenapiPartitionResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetPartitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetPartitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiPartitionResp
	JSONDefault  *V0041OpenapiPartitionResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Pings pings
		Pings []struct {
			// Hostname Target for ping
			Hostname *string `json:"hostname,omitempty"`

			// Latency Number of microseconds it took to successfully ping or timeout
			Latency *int64 `json:"latency,omitempty"`

			// Mode The operating mode of the responding slurmctld
			Mode *string `json:"mode,omitempty"`

			// Pinged Ping result
			Pinged *string `json:"pinged,omitempty"`
		} `json:"pings"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Pings pings
		Pings []struct {
			// Hostname Target for ping
			Hostname *string `json:"hostname,omitempty"`

			// Latency Number of microseconds it took to successfully ping or timeout
			Latency *int64 `json:"latency,omitempty"`

			// Mode The operating mode of the responding slurmctld
			Mode *string `json:"mode,omitempty"`

			// Pinged Ping result
			Pinged *string `json:"pinged,omitempty"`
		} `json:"pings"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetReconfigureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetReconfigureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetReconfigureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiReservationResp
	JSONDefault  *V0041OpenapiReservationResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiReservationResp
	JSONDefault  *V0041OpenapiReservationResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetSharesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSharesResp
	JSONDefault  *V0041OpenapiSharesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetSharesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetSharesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// RemovedAccounts removed_accounts
		RemovedAccounts []string `json:"removed_accounts"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// RemovedAccounts removed_accounts
		RemovedAccounts []string `json:"removed_accounts"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAccountsResp
	JSONDefault  *V0041OpenapiAccountsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAccountsResp
	JSONDefault  *V0041OpenapiAccountsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostAccountsAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AddedAccounts added_accounts
		AddedAccounts string `json:"added_accounts"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// AddedAccounts added_accounts
		AddedAccounts string `json:"added_accounts"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostAccountsAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostAccountsAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsRemovedResp
	JSONDefault  *V0041OpenapiAssocsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsResp
	JSONDefault  *V0041OpenapiAssocsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsRemovedResp
	JSONDefault  *V0041OpenapiAssocsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsResp
	JSONDefault  *V0041OpenapiAssocsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DeletedClusters deleted_clusters
		DeletedClusters []string `json:"deleted_clusters"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// DeletedClusters deleted_clusters
		DeletedClusters []string `json:"deleted_clusters"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiClustersResp
	JSONDefault  *V0041OpenapiClustersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiClustersResp
	JSONDefault  *V0041OpenapiClustersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdConfigResp
	JSONDefault  *V0041OpenapiSlurmdbdConfigResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Statistics statistics
		Statistics struct {
			// RPCs List of RPCs sent to the slurmdbd
			RPCs *[]struct {
				// Count Number of RPCs processed
				Count *int32 `json:"count,omitempty"`

				// Rpc RPC type
				Rpc  *string `json:"rpc,omitempty"`
				Time *struct {
					// Average Average RPC processing time in microseconds
					Average *int64 `json:"average,omitempty"`

					// Total Total RPC processing time in microseconds
					Total *int64 `json:"total,omitempty"`
				} `json:"time,omitempty"`
			} `json:"RPCs,omitempty"`

			// Rollups Rollup statistics
			Rollups *struct {
				Daily *struct {
					// Count Number of daily rollups since last_run
					Count    *int32 `json:"count,omitempty"`
					Duration *struct {
						// Last Total time spent doing daily daily rollup (seconds)
						Last *int64 `json:"last,omitempty"`

						// Max Longest daily rollup time (seconds)
						Max *int64 `json:"max,omitempty"`

						// Time Total time spent doing daily rollups (seconds)
						Time *int64 `json:"time,omitempty"`
					} `json:"duration,omitempty"`

					// LastRun Last time daily rollup ran (UNIX timestamp)
					LastRun *int64 `json:"last_run,omitempty"`
				} `json:"daily,omitempty"`
				Hourly *struct {
					// Count Number of hourly rollups since last_run
					Count    *int32 `json:"count,omitempty"`
					Duration *struct {
						// Last Total time spent doing last daily rollup (seconds)
						Last *int64 `json:"last,omitempty"`

						// Max Longest hourly rollup time (seconds)
						Max *int64 `json:"max,omitempty"`

						// Time Total time spent doing hourly rollups (seconds)
						Time *int64 `json:"time,omitempty"`
					} `json:"duration,omitempty"`

					// LastRun Last time hourly rollup ran (UNIX timestamp)
					LastRun *int64 `json:"last_run,omitempty"`
				} `json:"hourly,omitempty"`
				Monthly *struct {
					// Count Number of monthly rollups since last_run
					Count    *int32 `json:"count,omitempty"`
					Duration *struct {
						// Last Total time spent doing monthly daily rollup (seconds)
						Last *int64 `json:"last,omitempty"`

						// Max Longest monthly rollup time (seconds)
						Max *int64 `json:"max,omitempty"`

						// Time Total time spent doing monthly rollups (seconds)
						Time *int64 `json:"time,omitempty"`
					} `json:"duration,omitempty"`

					// LastRun Last time monthly rollup ran (UNIX timestamp)
					LastRun *int64 `json:"last_run,omitempty"`
				} `json:"monthly,omitempty"`
			} `json:"rollups,omitempty"`

			// TimeStart When data collection started (UNIX timestamp)
			TimeStart *int64 `json:"time_start,omitempty"`

			// Users List of users that issued RPCs
			Users *[]struct {
				// Count Number of RPCs processed
				Count *int32 `json:"count,omitempty"`
				Time  *struct {
					// Average Average RPC processing time in microseconds
					Average *int64 `json:"average,omitempty"`

					// Total Total RPC processing time in microseconds
					Total *int64 `json:"total,omitempty"`
				} `json:"time,omitempty"`

				// User User ID
				User *string `json:"user,omitempty"`
			} `json:"users,omitempty"`
		} `json:"statistics"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Statistics statistics
		Statistics struct {
			// RPCs List of RPCs sent to the slurmdbd
			RPCs *[]struct {
				// Count Number of RPCs processed
				Count *int32 `json:"count,omitempty"`

				// Rpc RPC type
				Rpc  *string `json:"rpc,omitempty"`
				Time *struct {
					// Average Average RPC processing time in microseconds
					Average *int64 `json:"average,omitempty"`

					// Total Total RPC processing time in microseconds
					Total *int64 `json:"total,omitempty"`
				} `json:"time,omitempty"`
			} `json:"RPCs,omitempty"`

			// Rollups Rollup statistics
			Rollups *struct {
				Daily *struct {
					// Count Number of daily rollups since last_run
					Count    *int32 `json:"count,omitempty"`
					Duration *struct {
						// Last Total time spent doing daily daily rollup (seconds)
						Last *int64 `json:"last,omitempty"`

						// Max Longest daily rollup time (seconds)
						Max *int64 `json:"max,omitempty"`

						// Time Total time spent doing daily rollups (seconds)
						Time *int64 `json:"time,omitempty"`
					} `json:"duration,omitempty"`

					// LastRun Last time daily rollup ran (UNIX timestamp)
					LastRun *int64 `json:"last_run,omitempty"`
				} `json:"daily,omitempty"`
				Hourly *struct {
					// Count Number of hourly rollups since last_run
					Count    *int32 `json:"count,omitempty"`
					Duration *struct {
						// Last Total time spent doing last daily rollup (seconds)
						Last *int64 `json:"last,omitempty"`

						// Max Longest hourly rollup time (seconds)
						Max *int64 `json:"max,omitempty"`

						// Time Total time spent doing hourly rollups (seconds)
						Time *int64 `json:"time,omitempty"`
					} `json:"duration,omitempty"`

					// LastRun Last time hourly rollup ran (UNIX timestamp)
					LastRun *int64 `json:"last_run,omitempty"`
				} `json:"hourly,omitempty"`
				Monthly *struct {
					// Count Number of monthly rollups since last_run
					Count    *int32 `json:"count,omitempty"`
					Duration *struct {
						// Last Total time spent doing monthly daily rollup (seconds)
						Last *int64 `json:"last,omitempty"`

						// Max Longest monthly rollup time (seconds)
						Max *int64 `json:"max,omitempty"`

						// Time Total time spent doing monthly rollups (seconds)
						Time *int64 `json:"time,omitempty"`
					} `json:"duration,omitempty"`

					// LastRun Last time monthly rollup ran (UNIX timestamp)
					LastRun *int64 `json:"last_run,omitempty"`
				} `json:"monthly,omitempty"`
			} `json:"rollups,omitempty"`

			// TimeStart When data collection started (UNIX timestamp)
			TimeStart *int64 `json:"time_start,omitempty"`

			// Users List of users that issued RPCs
			Users *[]struct {
				// Count Number of RPCs processed
				Count *int32 `json:"count,omitempty"`
				Time  *struct {
					// Average Average RPC processing time in microseconds
					Average *int64 `json:"average,omitempty"`

					// Total Total RPC processing time in microseconds
					Total *int64 `json:"total,omitempty"`
				} `json:"time,omitempty"`

				// User User ID
				User *string `json:"user,omitempty"`
			} `json:"users,omitempty"`
		} `json:"statistics"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiInstancesResp
	JSONDefault  *V0041OpenapiInstancesResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiInstancesResp
	JSONDefault  *V0041OpenapiInstancesResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdJobsResp
	JSONDefault  *V0041OpenapiSlurmdbdJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdJobsResp
	JSONDefault  *V0041OpenapiSlurmdbdJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdQosResp
	JSONDefault  *V0041OpenapiSlurmdbdQosResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteSingleQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// RemovedQos removed QOS
		RemovedQos []string `json:"removed_qos"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// RemovedQos removed QOS
		RemovedQos []string `json:"removed_qos"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteSingleQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteSingleQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetSingleQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdQosResp
	JSONDefault  *V0041OpenapiSlurmdbdQosResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetSingleQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetSingleQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetTresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiTresResp
	JSONDefault  *V0041OpenapiTresResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetTresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetTresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostTresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostTresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostTresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiUsersResp
	JSONDefault  *V0041OpenapiUsersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiUsersResp
	JSONDefault  *V0041OpenapiUsersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostUsersAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AddedUsers added_users
		AddedUsers string `json:"added_users"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// AddedUsers added_users
		AddedUsers string `json:"added_users"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostUsersAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostUsersAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteWckeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DeletedWckeys deleted wckeys
		DeletedWckeys []string `json:"deleted_wckeys"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// DeletedWckeys deleted wckeys
		DeletedWckeys []string `json:"deleted_wckeys"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteWckeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteWckeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetWckeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiWckeyResp
	JSONDefault  *V0041OpenapiWckeyResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetWckeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetWckeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetWckeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiWckeyResp
	JSONDefault  *V0041OpenapiWckeyResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetWckeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetWckeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostWckeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostWckeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostWckeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SlurmV0041GetDiagWithResponse request returning *SlurmV0041GetDiagResponse
func (c *ClientWithResponses) SlurmV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetDiagResponse, error) {
	rsp, err := c.SlurmV0041GetDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetDiagResponse(rsp)
}

// SlurmV0041PostJobAllocateWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostJobAllocateResponse
func (c *ClientWithResponses) SlurmV0041PostJobAllocateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error) {
	rsp, err := c.SlurmV0041PostJobAllocateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobAllocateResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostJobAllocateWithResponse(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error) {
	rsp, err := c.SlurmV0041PostJobAllocate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobAllocateResponse(rsp)
}

// SlurmV0041PostJobSubmitWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostJobSubmitResponse
func (c *ClientWithResponses) SlurmV0041PostJobSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error) {
	rsp, err := c.SlurmV0041PostJobSubmitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobSubmitResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostJobSubmitWithResponse(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error) {
	rsp, err := c.SlurmV0041PostJobSubmit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobSubmitResponse(rsp)
}

// SlurmV0041DeleteJobWithResponse request returning *SlurmV0041DeleteJobResponse
func (c *ClientWithResponses) SlurmV0041DeleteJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobResponse, error) {
	rsp, err := c.SlurmV0041DeleteJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteJobResponse(rsp)
}

// SlurmV0041GetJobWithResponse request returning *SlurmV0041GetJobResponse
func (c *ClientWithResponses) SlurmV0041GetJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobResponse, error) {
	rsp, err := c.SlurmV0041GetJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetJobResponse(rsp)
}

// SlurmV0041PostJobWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostJobResponse
func (c *ClientWithResponses) SlurmV0041PostJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error) {
	rsp, err := c.SlurmV0041PostJobWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostJobWithResponse(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error) {
	rsp, err := c.SlurmV0041PostJob(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobResponse(rsp)
}

// SlurmV0041DeleteJobsWithBodyWithResponse request with arbitrary body returning *SlurmV0041DeleteJobsResponse
func (c *ClientWithResponses) SlurmV0041DeleteJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error) {
	rsp, err := c.SlurmV0041DeleteJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteJobsResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041DeleteJobsWithResponse(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error) {
	rsp, err := c.SlurmV0041DeleteJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteJobsResponse(rsp)
}

// SlurmV0041GetJobsWithResponse request returning *SlurmV0041GetJobsResponse
func (c *ClientWithResponses) SlurmV0041GetJobsWithResponse(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsResponse, error) {
	rsp, err := c.SlurmV0041GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetJobsResponse(rsp)
}

// SlurmV0041GetJobsStateWithResponse request returning *SlurmV0041GetJobsStateResponse
func (c *ClientWithResponses) SlurmV0041GetJobsStateWithResponse(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsStateResponse, error) {
	rsp, err := c.SlurmV0041GetJobsState(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetJobsStateResponse(rsp)
}

// SlurmV0041GetLicensesWithResponse request returning *SlurmV0041GetLicensesResponse
func (c *ClientWithResponses) SlurmV0041GetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetLicensesResponse, error) {
	rsp, err := c.SlurmV0041GetLicenses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetLicensesResponse(rsp)
}

// SlurmV0041DeleteNodeWithResponse request returning *SlurmV0041DeleteNodeResponse
func (c *ClientWithResponses) SlurmV0041DeleteNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteNodeResponse, error) {
	rsp, err := c.SlurmV0041DeleteNode(ctx, nodeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteNodeResponse(rsp)
}

// SlurmV0041GetNodeWithResponse request returning *SlurmV0041GetNodeResponse
func (c *ClientWithResponses) SlurmV0041GetNodeWithResponse(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodeResponse, error) {
	rsp, err := c.SlurmV0041GetNode(ctx, nodeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetNodeResponse(rsp)
}

// SlurmV0041PostNodeWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostNodeResponse
func (c *ClientWithResponses) SlurmV0041PostNodeWithBodyWithResponse(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error) {
	rsp, err := c.SlurmV0041PostNodeWithBody(ctx, nodeName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodeResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostNodeWithResponse(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error) {
	rsp, err := c.SlurmV0041PostNode(ctx, nodeName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodeResponse(rsp)
}

// SlurmV0041GetNodesWithResponse request returning *SlurmV0041GetNodesResponse
func (c *ClientWithResponses) SlurmV0041GetNodesWithResponse(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodesResponse, error) {
	rsp, err := c.SlurmV0041GetNodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetNodesResponse(rsp)
}

// SlurmV0041PostNodesWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostNodesResponse
func (c *ClientWithResponses) SlurmV0041PostNodesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodesResponse, error) {
	rsp, err := c.SlurmV0041PostNodesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodesResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostNodesWithResponse(ctx context.Context, body SlurmV0041PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodesResponse, error) {
	rsp, err := c.SlurmV0041PostNodes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodesResponse(rsp)
}

// SlurmV0041GetPartitionWithResponse request returning *SlurmV0041GetPartitionResponse
func (c *ClientWithResponses) SlurmV0041GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionResponse, error) {
	rsp, err := c.SlurmV0041GetPartition(ctx, partitionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetPartitionResponse(rsp)
}

// SlurmV0041GetPartitionsWithResponse request returning *SlurmV0041GetPartitionsResponse
func (c *ClientWithResponses) SlurmV0041GetPartitionsWithResponse(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionsResponse, error) {
	rsp, err := c.SlurmV0041GetPartitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetPartitionsResponse(rsp)
}

// SlurmV0041GetPingWithResponse request returning *SlurmV0041GetPingResponse
func (c *ClientWithResponses) SlurmV0041GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetPingResponse, error) {
	rsp, err := c.SlurmV0041GetPing(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetPingResponse(rsp)
}

// SlurmV0041GetReconfigureWithResponse request returning *SlurmV0041GetReconfigureResponse
func (c *ClientWithResponses) SlurmV0041GetReconfigureWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetReconfigureResponse, error) {
	rsp, err := c.SlurmV0041GetReconfigure(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetReconfigureResponse(rsp)
}

// SlurmV0041DeleteReservationWithResponse request returning *SlurmV0041DeleteReservationResponse
func (c *ClientWithResponses) SlurmV0041DeleteReservationWithResponse(ctx context.Context, reservationName string, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteReservationResponse, error) {
	rsp, err := c.SlurmV0041DeleteReservation(ctx, reservationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteReservationResponse(rsp)
}

// SlurmV0041GetReservationWithResponse request returning *SlurmV0041GetReservationResponse
func (c *ClientWithResponses) SlurmV0041GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationResponse, error) {
	rsp, err := c.SlurmV0041GetReservation(ctx, reservationName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetReservationResponse(rsp)
}

// SlurmV0041GetReservationsWithResponse request returning *SlurmV0041GetReservationsResponse
func (c *ClientWithResponses) SlurmV0041GetReservationsWithResponse(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationsResponse, error) {
	rsp, err := c.SlurmV0041GetReservations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetReservationsResponse(rsp)
}

// SlurmV0041GetSharesWithResponse request returning *SlurmV0041GetSharesResponse
func (c *ClientWithResponses) SlurmV0041GetSharesWithResponse(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetSharesResponse, error) {
	rsp, err := c.SlurmV0041GetShares(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetSharesResponse(rsp)
}

// SlurmdbV0041DeleteAccountWithResponse request returning *SlurmdbV0041DeleteAccountResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAccountResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteAccount(ctx, accountName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteAccountResponse(rsp)
}

// SlurmdbV0041GetAccountWithResponse request returning *SlurmdbV0041GetAccountResponse
func (c *ClientWithResponses) SlurmdbV0041GetAccountWithResponse(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountResponse, error) {
	rsp, err := c.SlurmdbV0041GetAccount(ctx, accountName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAccountResponse(rsp)
}

// SlurmdbV0041GetAccountsWithResponse request returning *SlurmdbV0041GetAccountsResponse
func (c *ClientWithResponses) SlurmdbV0041GetAccountsWithResponse(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountsResponse, error) {
	rsp, err := c.SlurmdbV0041GetAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAccountsResponse(rsp)
}

// SlurmdbV0041PostAccountsWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostAccountsResponse
func (c *ClientWithResponses) SlurmdbV0041PostAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccountsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostAccountsWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccounts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsResponse(rsp)
}

// SlurmdbV0041PostAccountsAssociationWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostAccountsAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041PostAccountsAssociationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccountsAssociationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsAssociationResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostAccountsAssociationWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccountsAssociation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsAssociationResponse(rsp)
}

// SlurmdbV0041DeleteAssociationWithResponse request returning *SlurmdbV0041DeleteAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteAssociationWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteAssociation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteAssociationResponse(rsp)
}

// SlurmdbV0041GetAssociationWithResponse request returning *SlurmdbV0041GetAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041GetAssociationWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041GetAssociation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAssociationResponse(rsp)
}

// SlurmdbV0041DeleteAssociationsWithResponse request returning *SlurmdbV0041DeleteAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteAssociationsResponse(rsp)
}

// SlurmdbV0041GetAssociationsWithResponse request returning *SlurmdbV0041GetAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0041GetAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041GetAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAssociationsResponse(rsp)
}

// SlurmdbV0041PostAssociationsWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0041PostAssociationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAssociationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAssociationsResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostAssociationsWithResponse(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAssociations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAssociationsResponse(rsp)
}

// SlurmdbV0041DeleteClusterWithResponse request returning *SlurmdbV0041DeleteClusterResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteClusterResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteCluster(ctx, clusterName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteClusterResponse(rsp)
}

// SlurmdbV0041GetClusterWithResponse request returning *SlurmdbV0041GetClusterResponse
func (c *ClientWithResponses) SlurmdbV0041GetClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClusterResponse, error) {
	rsp, err := c.SlurmdbV0041GetCluster(ctx, clusterName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetClusterResponse(rsp)
}

// SlurmdbV0041GetClustersWithResponse request returning *SlurmdbV0041GetClustersResponse
func (c *ClientWithResponses) SlurmdbV0041GetClustersWithResponse(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClustersResponse, error) {
	rsp, err := c.SlurmdbV0041GetClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetClustersResponse(rsp)
}

// SlurmdbV0041PostClustersWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostClustersResponse
func (c *ClientWithResponses) SlurmdbV0041PostClustersWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error) {
	rsp, err := c.SlurmdbV0041PostClustersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostClustersResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostClustersWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error) {
	rsp, err := c.SlurmdbV0041PostClusters(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostClustersResponse(rsp)
}

// SlurmdbV0041GetConfigWithResponse request returning *SlurmdbV0041GetConfigResponse
func (c *ClientWithResponses) SlurmdbV0041GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetConfigResponse, error) {
	rsp, err := c.SlurmdbV0041GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetConfigResponse(rsp)
}

// SlurmdbV0041PostConfigWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostConfigResponse
func (c *ClientWithResponses) SlurmdbV0041PostConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error) {
	rsp, err := c.SlurmdbV0041PostConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostConfigResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostConfigWithResponse(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error) {
	rsp, err := c.SlurmdbV0041PostConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostConfigResponse(rsp)
}

// SlurmdbV0041GetDiagWithResponse request returning *SlurmdbV0041GetDiagResponse
func (c *ClientWithResponses) SlurmdbV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetDiagResponse, error) {
	rsp, err := c.SlurmdbV0041GetDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetDiagResponse(rsp)
}

// SlurmdbV0041GetInstanceWithResponse request returning *SlurmdbV0041GetInstanceResponse
func (c *ClientWithResponses) SlurmdbV0041GetInstanceWithResponse(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstanceResponse, error) {
	rsp, err := c.SlurmdbV0041GetInstance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetInstanceResponse(rsp)
}

// SlurmdbV0041GetInstancesWithResponse request returning *SlurmdbV0041GetInstancesResponse
func (c *ClientWithResponses) SlurmdbV0041GetInstancesWithResponse(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstancesResponse, error) {
	rsp, err := c.SlurmdbV0041GetInstances(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetInstancesResponse(rsp)
}

// SlurmdbV0041GetJobWithResponse request returning *SlurmdbV0041GetJobResponse
func (c *ClientWithResponses) SlurmdbV0041GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobResponse, error) {
	rsp, err := c.SlurmdbV0041GetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetJobResponse(rsp)
}

// SlurmdbV0041GetJobsWithResponse request returning *SlurmdbV0041GetJobsResponse
func (c *ClientWithResponses) SlurmdbV0041GetJobsWithResponse(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobsResponse, error) {
	rsp, err := c.SlurmdbV0041GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetJobsResponse(rsp)
}

// SlurmdbV0041GetQosWithResponse request returning *SlurmdbV0041GetQosResponse
func (c *ClientWithResponses) SlurmdbV0041GetQosWithResponse(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetQosResponse, error) {
	rsp, err := c.SlurmdbV0041GetQos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetQosResponse(rsp)
}

// SlurmdbV0041PostQosWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostQosResponse
func (c *ClientWithResponses) SlurmdbV0041PostQosWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error) {
	rsp, err := c.SlurmdbV0041PostQosWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostQosResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostQosWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error) {
	rsp, err := c.SlurmdbV0041PostQos(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostQosResponse(rsp)
}

// SlurmdbV0041DeleteSingleQosWithResponse request returning *SlurmdbV0041DeleteSingleQosResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteSingleQosWithResponse(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteSingleQosResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteSingleQos(ctx, qos, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteSingleQosResponse(rsp)
}

// SlurmdbV0041GetSingleQosWithResponse request returning *SlurmdbV0041GetSingleQosResponse
func (c *ClientWithResponses) SlurmdbV0041GetSingleQosWithResponse(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetSingleQosResponse, error) {
	rsp, err := c.SlurmdbV0041GetSingleQos(ctx, qos, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetSingleQosResponse(rsp)
}

// SlurmdbV0041GetTresWithResponse request returning *SlurmdbV0041GetTresResponse
func (c *ClientWithResponses) SlurmdbV0041GetTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetTresResponse, error) {
	rsp, err := c.SlurmdbV0041GetTres(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetTresResponse(rsp)
}

// SlurmdbV0041PostTresWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostTresResponse
func (c *ClientWithResponses) SlurmdbV0041PostTresWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error) {
	rsp, err := c.SlurmdbV0041PostTresWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostTresResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostTresWithResponse(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error) {
	rsp, err := c.SlurmdbV0041PostTres(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostTresResponse(rsp)
}

// SlurmdbV0041DeleteUserWithResponse request returning *SlurmdbV0041DeleteUserResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteUserWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteUserResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteUser(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteUserResponse(rsp)
}

// SlurmdbV0041GetUserWithResponse request returning *SlurmdbV0041GetUserResponse
func (c *ClientWithResponses) SlurmdbV0041GetUserWithResponse(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUserResponse, error) {
	rsp, err := c.SlurmdbV0041GetUser(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetUserResponse(rsp)
}

// SlurmdbV0041GetUsersWithResponse request returning *SlurmdbV0041GetUsersResponse
func (c *ClientWithResponses) SlurmdbV0041GetUsersWithResponse(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUsersResponse, error) {
	rsp, err := c.SlurmdbV0041GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetUsersResponse(rsp)
}

// SlurmdbV0041PostUsersWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostUsersResponse
func (c *ClientWithResponses) SlurmdbV0041PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostUsersWithResponse(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersResponse(rsp)
}

// SlurmdbV0041PostUsersAssociationWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostUsersAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041PostUsersAssociationWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsersAssociationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersAssociationResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostUsersAssociationWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsersAssociation(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersAssociationResponse(rsp)
}

// SlurmdbV0041DeleteWckeyWithResponse request returning *SlurmdbV0041DeleteWckeyResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteWckeyResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteWckey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteWckeyResponse(rsp)
}

// SlurmdbV0041GetWckeyWithResponse request returning *SlurmdbV0041GetWckeyResponse
func (c *ClientWithResponses) SlurmdbV0041GetWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeyResponse, error) {
	rsp, err := c.SlurmdbV0041GetWckey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetWckeyResponse(rsp)
}

// SlurmdbV0041GetWckeysWithResponse request returning *SlurmdbV0041GetWckeysResponse
func (c *ClientWithResponses) SlurmdbV0041GetWckeysWithResponse(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeysResponse, error) {
	rsp, err := c.SlurmdbV0041GetWckeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetWckeysResponse(rsp)
}

// SlurmdbV0041PostWckeysWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostWckeysResponse
func (c *ClientWithResponses) SlurmdbV0041PostWckeysWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error) {
	rsp, err := c.SlurmdbV0041PostWckeysWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostWckeysResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostWckeysWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error) {
	rsp, err := c.SlurmdbV0041PostWckeys(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostWckeysResponse(rsp)
}

// ParseSlurmV0041GetDiagResponse parses an HTTP response from a SlurmV0041GetDiagWithResponse call
func ParseSlurmV0041GetDiagResponse(rsp *http.Response) (*SlurmV0041GetDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Statistics statistics
			Statistics struct {
				// AgentCount Number of agent threads
				AgentCount *int32 `json:"agent_count,omitempty"`

				// AgentQueueSize Number of enqueued outgoing RPC requests in an internal retry list
				AgentQueueSize *int32 `json:"agent_queue_size,omitempty"`

				// AgentThreadCount Total number of active threads created by all agent threads
				AgentThreadCount *int32 `json:"agent_thread_count,omitempty"`

				// BfActive Backfill scheduler currently running
				BfActive *bool `json:"bf_active,omitempty"`

				// BfBackfilledHetJobs Number of heterogeneous job components started through backfilling since last Slurm start
				BfBackfilledHetJobs *int32 `json:"bf_backfilled_het_jobs,omitempty"`

				// BfBackfilledJobs Number of jobs started through backfilling since last slurm start
				BfBackfilledJobs *int32 `json:"bf_backfilled_jobs,omitempty"`

				// BfCycleCounter Number of backfill scheduling cycles since last reset
				BfCycleCounter *int32 `json:"bf_cycle_counter,omitempty"`

				// BfCycleLast Execution time in microseconds of last backfill scheduling cycle
				BfCycleLast *int32 `json:"bf_cycle_last,omitempty"`

				// BfCycleMax Execution time in microseconds of longest backfill scheduling cycle
				BfCycleMax *int32 `json:"bf_cycle_max,omitempty"`

				// BfCycleMean Mean time in microseconds of backfilling scheduling cycles since last reset
				BfCycleMean *int64 `json:"bf_cycle_mean,omitempty"`

				// BfCycleSum Total time in microseconds of backfilling scheduling cycles since last reset
				BfCycleSum *int64 `json:"bf_cycle_sum,omitempty"`

				// BfDepthMean Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
				BfDepthMean *int64 `json:"bf_depth_mean,omitempty"`

				// BfDepthMeanTry The subset of Depth Mean that the backfill scheduler attempted to schedule
				BfDepthMeanTry *int64 `json:"bf_depth_mean_try,omitempty"`

				// BfDepthSum Total number of jobs processed during all backfilling scheduling cycles since last reset
				BfDepthSum *int32 `json:"bf_depth_sum,omitempty"`

				// BfDepthTrySum Subset of bf_depth_sum that the backfill scheduler attempted to schedule
				BfDepthTrySum *int32 `json:"bf_depth_try_sum,omitempty"`

				// BfExit Reasons for which the backfill scheduling cycle exited since last reset
				BfExit *struct {
					// BfMaxJobStart Reached number of jobs allowed to start
					BfMaxJobStart *int32 `json:"bf_max_job_start,omitempty"`

					// BfMaxJobTest Reached number of jobs allowed to be tested
					BfMaxJobTest *int32 `json:"bf_max_job_test,omitempty"`

					// BfMaxTime Reached maximum allowed scheduler time
					BfMaxTime *int32 `json:"bf_max_time,omitempty"`

					// BfNodeSpaceSize Reached table size limit
					BfNodeSpaceSize *int32 `json:"bf_node_space_size,omitempty"`

					// EndJobQueue Reached end of queue
					EndJobQueue *int32 `json:"end_job_queue,omitempty"`

					// StateChanged System state changed
					StateChanged *int32 `json:"state_changed,omitempty"`
				} `json:"bf_exit,omitempty"`

				// BfLastBackfilledJobs Number of jobs started through backfilling since last reset
				BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`

				// BfLastDepth Number of processed jobs during last backfilling scheduling cycle
				BfLastDepth *int32 `json:"bf_last_depth,omitempty"`

				// BfLastDepthTry Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
				BfLastDepthTry *int32 `json:"bf_last_depth_try,omitempty"`

				// BfQueueLen Number of jobs pending to be processed by backfilling algorithm
				BfQueueLen *int32 `json:"bf_queue_len,omitempty"`

				// BfQueueLenMean Mean number of jobs pending to be processed by backfilling algorithm
				BfQueueLenMean *int64 `json:"bf_queue_len_mean,omitempty"`

				// BfQueueLenSum Total number of jobs pending to be processed by backfilling algorithm since last reset
				BfQueueLenSum *int32 `json:"bf_queue_len_sum,omitempty"`

				// BfTableSize Number of different time slots tested by the backfill scheduler in its last iteration
				BfTableSize *int32 `json:"bf_table_size,omitempty"`

				// BfTableSizeMean Mean number of different time slots tested by the backfill scheduler
				BfTableSizeMean *int64 `json:"bf_table_size_mean,omitempty"`

				// BfTableSizeSum Total number of different time slots tested by the backfill scheduler
				BfTableSizeSum *int32 `json:"bf_table_size_sum,omitempty"`

				// BfWhenLastCycle When the last backfill scheduling cycle happened (UNIX timestamp)
				BfWhenLastCycle *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"bf_when_last_cycle,omitempty"`

				// DbdAgentQueueSize Number of messages for SlurmDBD that are queued
				DbdAgentQueueSize *int32 `json:"dbd_agent_queue_size,omitempty"`

				// GettimeofdayLatency Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
				GettimeofdayLatency *int32 `json:"gettimeofday_latency,omitempty"`

				// JobStatesTs When the job state counts were gathered (UNIX timestamp)
				JobStatesTs *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"job_states_ts,omitempty"`

				// JobsCanceled Number of jobs canceled since the last reset
				JobsCanceled *int32 `json:"jobs_canceled,omitempty"`

				// JobsCompleted Number of jobs completed since last reset
				JobsCompleted *int32 `json:"jobs_completed,omitempty"`

				// JobsFailed Number of jobs failed due to slurmd or other internal issues since last reset
				JobsFailed *int32 `json:"jobs_failed,omitempty"`

				// JobsPending Number of jobs pending at the time of listed in job_state_ts
				JobsPending *int32 `json:"jobs_pending,omitempty"`

				// JobsRunning Number of jobs running at the time of listed in job_state_ts
				JobsRunning *int32 `json:"jobs_running,omitempty"`

				// JobsStarted Number of jobs started since last reset
				JobsStarted *int32 `json:"jobs_started,omitempty"`

				// JobsSubmitted Number of jobs submitted since last reset
				JobsSubmitted *int32 `json:"jobs_submitted,omitempty"`

				// PartsPacked Zero if only RPC statistic included
				PartsPacked *int32 `json:"parts_packed,omitempty"`

				// PendingRpcs Pending RPC statistics
				PendingRpcs *[]struct {
					// Count Number of pending RPCs queued
					Count int32 `json:"count"`

					// MessageType Message type as string
					MessageType string `json:"message_type"`

					// TypeId Message type as integer
					TypeId int32 `json:"type_id"`
				} `json:"pending_rpcs,omitempty"`

				// PendingRpcsByHostlist Pending RPCs hostlists
				PendingRpcsByHostlist *[]struct {
					// Count Number of RPCs received
					Count []string `json:"count"`

					// MessageType Message type as string
					MessageType string `json:"message_type"`

					// TypeId Message type as integer
					TypeId int32 `json:"type_id"`
				} `json:"pending_rpcs_by_hostlist,omitempty"`

				// ReqTime When the request was made (UNIX timestamp)
				ReqTime *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"req_time,omitempty"`

				// ReqTimeStart When the data in the report started (UNIX timestamp)
				ReqTimeStart *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"req_time_start,omitempty"`

				// RpcsByMessageType Most frequently issued remote procedure calls (RPCs)
				RpcsByMessageType *[]struct {
					// AverageTime Average time spent processing RPC in seconds
					AverageTime struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"average_time"`

					// Count Number of RPCs received
					Count int32 `json:"count"`

					// CycleLast Number of RPCs processed within the last RPC queue cycle
					CycleLast int32 `json:"cycle_last"`

					// CycleMax Maximum number of RPCs processed within a RPC queue cycle since start
					CycleMax int32 `json:"cycle_max"`

					// Dropped Number of RPCs dropped
					Dropped int64 `json:"dropped"`

					// MessageType Message type as string
					MessageType string `json:"message_type"`

					// Queued Number of RPCs queued
					Queued int32 `json:"queued"`

					// TotalTime Total time spent processing RPC in seconds
					TotalTime int64 `json:"total_time"`

					// TypeId Message type as integer
					TypeId int32 `json:"type_id"`
				} `json:"rpcs_by_message_type,omitempty"`

				// RpcsByUser RPCs issued by user ID
				RpcsByUser *[]struct {
					// AverageTime Average time spent processing RPC in seconds
					AverageTime struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"average_time"`

					// Count Number of RPCs received
					Count int32 `json:"count"`

					// TotalTime Total time spent processing RPC in seconds
					TotalTime int64 `json:"total_time"`

					// User User name
					User string `json:"user"`

					// UserId User ID (numeric)
					UserId int32 `json:"user_id"`
				} `json:"rpcs_by_user,omitempty"`

				// ScheduleCycleDepth Total number of jobs processed in scheduling cycles
				ScheduleCycleDepth *int32 `json:"schedule_cycle_depth,omitempty"`

				// ScheduleCycleLast Time in microseconds for last scheduling cycle
				ScheduleCycleLast *int32 `json:"schedule_cycle_last,omitempty"`

				// ScheduleCycleMax Max time of any scheduling cycle in microseconds since last reset
				ScheduleCycleMax *int32 `json:"schedule_cycle_max,omitempty"`

				// ScheduleCycleMean Mean time in microseconds for all scheduling cycles since last reset
				ScheduleCycleMean *int64 `json:"schedule_cycle_mean,omitempty"`

				// ScheduleCycleMeanDepth Mean of the number of jobs processed in a scheduling cycle
				ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`

				// ScheduleCyclePerMinute Number of scheduling executions per minute
				ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`

				// ScheduleCycleSum Total run time in microseconds for all scheduling cycles since last reset
				ScheduleCycleSum *int32 `json:"schedule_cycle_sum,omitempty"`

				// ScheduleCycleTotal Number of scheduling cycles since last reset
				ScheduleCycleTotal *int32 `json:"schedule_cycle_total,omitempty"`

				// ScheduleExit Reasons for which the scheduling cycle exited since last reset
				ScheduleExit *struct {
					// DefaultQueueDepth Reached number of jobs allowed to be tested
					DefaultQueueDepth *int32 `json:"default_queue_depth,omitempty"`

					// EndJobQueue Reached end of queue
					EndJobQueue *int32 `json:"end_job_queue,omitempty"`

					// Licenses Blocked on licenses
					Licenses *int32 `json:"licenses,omitempty"`

					// MaxJobStart Reached number of jobs allowed to start
					MaxJobStart *int32 `json:"max_job_start,omitempty"`

					// MaxRpcCnt Reached RPC limit
					MaxRpcCnt *int32 `json:"max_rpc_cnt,omitempty"`

					// MaxSchedTime Reached maximum allowed scheduler time
					MaxSchedTime *int32 `json:"max_sched_time,omitempty"`
				} `json:"schedule_exit,omitempty"`

				// ScheduleQueueLength Number of jobs pending in queue
				ScheduleQueueLength *int32 `json:"schedule_queue_length,omitempty"`

				// ServerThreadCount Number of current active slurmctld threads
				ServerThreadCount *int32 `json:"server_thread_count,omitempty"`
			} `json:"statistics"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Statistics statistics
			Statistics struct {
				// AgentCount Number of agent threads
				AgentCount *int32 `json:"agent_count,omitempty"`

				// AgentQueueSize Number of enqueued outgoing RPC requests in an internal retry list
				AgentQueueSize *int32 `json:"agent_queue_size,omitempty"`

				// AgentThreadCount Total number of active threads created by all agent threads
				AgentThreadCount *int32 `json:"agent_thread_count,omitempty"`

				// BfActive Backfill scheduler currently running
				BfActive *bool `json:"bf_active,omitempty"`

				// BfBackfilledHetJobs Number of heterogeneous job components started through backfilling since last Slurm start
				BfBackfilledHetJobs *int32 `json:"bf_backfilled_het_jobs,omitempty"`

				// BfBackfilledJobs Number of jobs started through backfilling since last slurm start
				BfBackfilledJobs *int32 `json:"bf_backfilled_jobs,omitempty"`

				// BfCycleCounter Number of backfill scheduling cycles since last reset
				BfCycleCounter *int32 `json:"bf_cycle_counter,omitempty"`

				// BfCycleLast Execution time in microseconds of last backfill scheduling cycle
				BfCycleLast *int32 `json:"bf_cycle_last,omitempty"`

				// BfCycleMax Execution time in microseconds of longest backfill scheduling cycle
				BfCycleMax *int32 `json:"bf_cycle_max,omitempty"`

				// BfCycleMean Mean time in microseconds of backfilling scheduling cycles since last reset
				BfCycleMean *int64 `json:"bf_cycle_mean,omitempty"`

				// BfCycleSum Total time in microseconds of backfilling scheduling cycles since last reset
				BfCycleSum *int64 `json:"bf_cycle_sum,omitempty"`

				// BfDepthMean Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
				BfDepthMean *int64 `json:"bf_depth_mean,omitempty"`

				// BfDepthMeanTry The subset of Depth Mean that the backfill scheduler attempted to schedule
				BfDepthMeanTry *int64 `json:"bf_depth_mean_try,omitempty"`

				// BfDepthSum Total number of jobs processed during all backfilling scheduling cycles since last reset
				BfDepthSum *int32 `json:"bf_depth_sum,omitempty"`

				// BfDepthTrySum Subset of bf_depth_sum that the backfill scheduler attempted to schedule
				BfDepthTrySum *int32 `json:"bf_depth_try_sum,omitempty"`

				// BfExit Reasons for which the backfill scheduling cycle exited since last reset
				BfExit *struct {
					// BfMaxJobStart Reached number of jobs allowed to start
					BfMaxJobStart *int32 `json:"bf_max_job_start,omitempty"`

					// BfMaxJobTest Reached number of jobs allowed to be tested
					BfMaxJobTest *int32 `json:"bf_max_job_test,omitempty"`

					// BfMaxTime Reached maximum allowed scheduler time
					BfMaxTime *int32 `json:"bf_max_time,omitempty"`

					// BfNodeSpaceSize Reached table size limit
					BfNodeSpaceSize *int32 `json:"bf_node_space_size,omitempty"`

					// EndJobQueue Reached end of queue
					EndJobQueue *int32 `json:"end_job_queue,omitempty"`

					// StateChanged System state changed
					StateChanged *int32 `json:"state_changed,omitempty"`
				} `json:"bf_exit,omitempty"`

				// BfLastBackfilledJobs Number of jobs started through backfilling since last reset
				BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`

				// BfLastDepth Number of processed jobs during last backfilling scheduling cycle
				BfLastDepth *int32 `json:"bf_last_depth,omitempty"`

				// BfLastDepthTry Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
				BfLastDepthTry *int32 `json:"bf_last_depth_try,omitempty"`

				// BfQueueLen Number of jobs pending to be processed by backfilling algorithm
				BfQueueLen *int32 `json:"bf_queue_len,omitempty"`

				// BfQueueLenMean Mean number of jobs pending to be processed by backfilling algorithm
				BfQueueLenMean *int64 `json:"bf_queue_len_mean,omitempty"`

				// BfQueueLenSum Total number of jobs pending to be processed by backfilling algorithm since last reset
				BfQueueLenSum *int32 `json:"bf_queue_len_sum,omitempty"`

				// BfTableSize Number of different time slots tested by the backfill scheduler in its last iteration
				BfTableSize *int32 `json:"bf_table_size,omitempty"`

				// BfTableSizeMean Mean number of different time slots tested by the backfill scheduler
				BfTableSizeMean *int64 `json:"bf_table_size_mean,omitempty"`

				// BfTableSizeSum Total number of different time slots tested by the backfill scheduler
				BfTableSizeSum *int32 `json:"bf_table_size_sum,omitempty"`

				// BfWhenLastCycle When the last backfill scheduling cycle happened (UNIX timestamp)
				BfWhenLastCycle *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"bf_when_last_cycle,omitempty"`

				// DbdAgentQueueSize Number of messages for SlurmDBD that are queued
				DbdAgentQueueSize *int32 `json:"dbd_agent_queue_size,omitempty"`

				// GettimeofdayLatency Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
				GettimeofdayLatency *int32 `json:"gettimeofday_latency,omitempty"`

				// JobStatesTs When the job state counts were gathered (UNIX timestamp)
				JobStatesTs *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"job_states_ts,omitempty"`

				// JobsCanceled Number of jobs canceled since the last reset
				JobsCanceled *int32 `json:"jobs_canceled,omitempty"`

				// JobsCompleted Number of jobs completed since last reset
				JobsCompleted *int32 `json:"jobs_completed,omitempty"`

				// JobsFailed Number of jobs failed due to slurmd or other internal issues since last reset
				JobsFailed *int32 `json:"jobs_failed,omitempty"`

				// JobsPending Number of jobs pending at the time of listed in job_state_ts
				JobsPending *int32 `json:"jobs_pending,omitempty"`

				// JobsRunning Number of jobs running at the time of listed in job_state_ts
				JobsRunning *int32 `json:"jobs_running,omitempty"`

				// JobsStarted Number of jobs started since last reset
				JobsStarted *int32 `json:"jobs_started,omitempty"`

				// JobsSubmitted Number of jobs submitted since last reset
				JobsSubmitted *int32 `json:"jobs_submitted,omitempty"`

				// PartsPacked Zero if only RPC statistic included
				PartsPacked *int32 `json:"parts_packed,omitempty"`

				// PendingRpcs Pending RPC statistics
				PendingRpcs *[]struct {
					// Count Number of pending RPCs queued
					Count int32 `json:"count"`

					// MessageType Message type as string
					MessageType string `json:"message_type"`

					// TypeId Message type as integer
					TypeId int32 `json:"type_id"`
				} `json:"pending_rpcs,omitempty"`

				// PendingRpcsByHostlist Pending RPCs hostlists
				PendingRpcsByHostlist *[]struct {
					// Count Number of RPCs received
					Count []string `json:"count"`

					// MessageType Message type as string
					MessageType string `json:"message_type"`

					// TypeId Message type as integer
					TypeId int32 `json:"type_id"`
				} `json:"pending_rpcs_by_hostlist,omitempty"`

				// ReqTime When the request was made (UNIX timestamp)
				ReqTime *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"req_time,omitempty"`

				// ReqTimeStart When the data in the report started (UNIX timestamp)
				ReqTimeStart *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"req_time_start,omitempty"`

				// RpcsByMessageType Most frequently issued remote procedure calls (RPCs)
				RpcsByMessageType *[]struct {
					// AverageTime Average time spent processing RPC in seconds
					AverageTime struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"average_time"`

					// Count Number of RPCs received
					Count int32 `json:"count"`

					// CycleLast Number of RPCs processed within the last RPC queue cycle
					CycleLast int32 `json:"cycle_last"`

					// CycleMax Maximum number of RPCs processed within a RPC queue cycle since start
					CycleMax int32 `json:"cycle_max"`

					// Dropped Number of RPCs dropped
					Dropped int64 `json:"dropped"`

					// MessageType Message type as string
					MessageType string `json:"message_type"`

					// Queued Number of RPCs queued
					Queued int32 `json:"queued"`

					// TotalTime Total time spent processing RPC in seconds
					TotalTime int64 `json:"total_time"`

					// TypeId Message type as integer
					TypeId int32 `json:"type_id"`
				} `json:"rpcs_by_message_type,omitempty"`

				// RpcsByUser RPCs issued by user ID
				RpcsByUser *[]struct {
					// AverageTime Average time spent processing RPC in seconds
					AverageTime struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"average_time"`

					// Count Number of RPCs received
					Count int32 `json:"count"`

					// TotalTime Total time spent processing RPC in seconds
					TotalTime int64 `json:"total_time"`

					// User User name
					User string `json:"user"`

					// UserId User ID (numeric)
					UserId int32 `json:"user_id"`
				} `json:"rpcs_by_user,omitempty"`

				// ScheduleCycleDepth Total number of jobs processed in scheduling cycles
				ScheduleCycleDepth *int32 `json:"schedule_cycle_depth,omitempty"`

				// ScheduleCycleLast Time in microseconds for last scheduling cycle
				ScheduleCycleLast *int32 `json:"schedule_cycle_last,omitempty"`

				// ScheduleCycleMax Max time of any scheduling cycle in microseconds since last reset
				ScheduleCycleMax *int32 `json:"schedule_cycle_max,omitempty"`

				// ScheduleCycleMean Mean time in microseconds for all scheduling cycles since last reset
				ScheduleCycleMean *int64 `json:"schedule_cycle_mean,omitempty"`

				// ScheduleCycleMeanDepth Mean of the number of jobs processed in a scheduling cycle
				ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`

				// ScheduleCyclePerMinute Number of scheduling executions per minute
				ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`

				// ScheduleCycleSum Total run time in microseconds for all scheduling cycles since last reset
				ScheduleCycleSum *int32 `json:"schedule_cycle_sum,omitempty"`

				// ScheduleCycleTotal Number of scheduling cycles since last reset
				ScheduleCycleTotal *int32 `json:"schedule_cycle_total,omitempty"`

				// ScheduleExit Reasons for which the scheduling cycle exited since last reset
				ScheduleExit *struct {
					// DefaultQueueDepth Reached number of jobs allowed to be tested
					DefaultQueueDepth *int32 `json:"default_queue_depth,omitempty"`

					// EndJobQueue Reached end of queue
					EndJobQueue *int32 `json:"end_job_queue,omitempty"`

					// Licenses Blocked on licenses
					Licenses *int32 `json:"licenses,omitempty"`

					// MaxJobStart Reached number of jobs allowed to start
					MaxJobStart *int32 `json:"max_job_start,omitempty"`

					// MaxRpcCnt Reached RPC limit
					MaxRpcCnt *int32 `json:"max_rpc_cnt,omitempty"`

					// MaxSchedTime Reached maximum allowed scheduler time
					MaxSchedTime *int32 `json:"max_sched_time,omitempty"`
				} `json:"schedule_exit,omitempty"`

				// ScheduleQueueLength Number of jobs pending in queue
				ScheduleQueueLength *int32 `json:"schedule_queue_length,omitempty"`

				// ServerThreadCount Number of current active slurmctld threads
				ServerThreadCount *int32 `json:"server_thread_count,omitempty"`
			} `json:"statistics"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostJobAllocateResponse parses an HTTP response from a SlurmV0041PostJobAllocateWithResponse call
func ParseSlurmV0041PostJobAllocateResponse(rsp *http.Response) (*SlurmV0041PostJobAllocateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostJobAllocateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId Submitted Job ID
			JobId *int32 `json:"job_id,omitempty"`

			// JobSubmitUserMsg Job submission user message
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId Submitted Job ID
			JobId *int32 `json:"job_id,omitempty"`

			// JobSubmitUserMsg Job submission user message
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostJobSubmitResponse parses an HTTP response from a SlurmV0041PostJobSubmitWithResponse call
func ParseSlurmV0041PostJobSubmitResponse(rsp *http.Response) (*SlurmV0041PostJobSubmitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostJobSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId Submitted Job ID
			JobId *int32 `json:"job_id,omitempty"`

			// JobSubmitUserMsg Job submission user message
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Result Job submission
			// Deprecated:
			Result *struct {
				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorCode Error code
				ErrorCode *int32 `json:"error_code,omitempty"`

				// JobId New job ID
				JobId *int32 `json:"job_id,omitempty"`

				// JobSubmitUserMsg Message to user from job_submit plugin
				JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

				// StepId New job step ID
				StepId *string `json:"step_id,omitempty"`
			} `json:"result,omitempty"`

			// StepId Submitted Step ID
			StepId *string `json:"step_id,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId Submitted Job ID
			JobId *int32 `json:"job_id,omitempty"`

			// JobSubmitUserMsg Job submission user message
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Result Job submission
			// Deprecated:
			Result *struct {
				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorCode Error code
				ErrorCode *int32 `json:"error_code,omitempty"`

				// JobId New job ID
				JobId *int32 `json:"job_id,omitempty"`

				// JobSubmitUserMsg Message to user from job_submit plugin
				JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

				// StepId New job step ID
				StepId *string `json:"step_id,omitempty"`
			} `json:"result,omitempty"`

			// StepId Submitted Step ID
			StepId *string `json:"step_id,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteJobResponse parses an HTTP response from a SlurmV0041DeleteJobWithResponse call
func ParseSlurmV0041DeleteJobResponse(rsp *http.Response) (*SlurmV0041DeleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetJobResponse parses an HTTP response from a SlurmV0041GetJobWithResponse call
func ParseSlurmV0041GetJobResponse(rsp *http.Response) (*SlurmV0041GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostJobResponse parses an HTTP response from a SlurmV0041PostJobWithResponse call
func ParseSlurmV0041PostJobResponse(rsp *http.Response) (*SlurmV0041PostJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId First updated Job ID - Use results instead
			// Deprecated:
			JobId *string `json:"job_id,omitempty"`

			// JobSubmitUserMsg First updated Job submission user message - Use results instead
			// Deprecated:
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Results Job update results
			Results *[]struct {
				// Error Verbose update status or error
				Error *string `json:"error,omitempty"`

				// ErrorCode Verbose update status or error
				ErrorCode *int32 `json:"error_code,omitempty"`

				// JobId Job ID for updated job
				JobId *int32 `json:"job_id,omitempty"`

				// StepId Step ID for updated job
				StepId *string `json:"step_id,omitempty"`

				// Why Update response message
				Why *string `json:"why,omitempty"`
			} `json:"results,omitempty"`

			// StepId First updated Step ID - Use results instead
			// Deprecated:
			StepId *string `json:"step_id,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId First updated Job ID - Use results instead
			// Deprecated:
			JobId *string `json:"job_id,omitempty"`

			// JobSubmitUserMsg First updated Job submission user message - Use results instead
			// Deprecated:
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Results Job update results
			Results *[]struct {
				// Error Verbose update status or error
				Error *string `json:"error,omitempty"`

				// ErrorCode Verbose update status or error
				ErrorCode *int32 `json:"error_code,omitempty"`

				// JobId Job ID for updated job
				JobId *int32 `json:"job_id,omitempty"`

				// StepId Step ID for updated job
				StepId *string `json:"step_id,omitempty"`

				// Why Update response message
				Why *string `json:"why,omitempty"`
			} `json:"results,omitempty"`

			// StepId First updated Step ID - Use results instead
			// Deprecated:
			StepId *string `json:"step_id,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteJobsResponse parses an HTTP response from a SlurmV0041DeleteJobsWithResponse call
func ParseSlurmV0041DeleteJobsResponse(rsp *http.Response) (*SlurmV0041DeleteJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Status resultant status of signal request
			Status []struct {
				Error *struct {
					// Code Numeric error encountered signaling job
					Code *int32 `json:"code,omitempty"`

					// Message Error message why signaling job failed
					Message *string `json:"message,omitempty"`

					// String String error encountered signaling job
					String *string `json:"string,omitempty"`
				} `json:"error,omitempty"`
				Federation *struct {
					// Sibling Name of federation sibling (may be empty for non-federation)
					Sibling *string `json:"sibling,omitempty"`
				} `json:"federation,omitempty"`

				// JobId Job ID that signaling failed
				JobId struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"job_id"`

				// StepId Job or Step ID that signaling failed
				StepId string `json:"step_id"`
			} `json:"status"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Status resultant status of signal request
			Status []struct {
				Error *struct {
					// Code Numeric error encountered signaling job
					Code *int32 `json:"code,omitempty"`

					// Message Error message why signaling job failed
					Message *string `json:"message,omitempty"`

					// String String error encountered signaling job
					String *string `json:"string,omitempty"`
				} `json:"error,omitempty"`
				Federation *struct {
					// Sibling Name of federation sibling (may be empty for non-federation)
					Sibling *string `json:"sibling,omitempty"`
				} `json:"federation,omitempty"`

				// JobId Job ID that signaling failed
				JobId struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"job_id"`

				// StepId Job or Step ID that signaling failed
				StepId string `json:"step_id"`
			} `json:"status"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetJobsResponse parses an HTTP response from a SlurmV0041GetJobsWithResponse call
func ParseSlurmV0041GetJobsResponse(rsp *http.Response) (*SlurmV0041GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetJobsStateResponse parses an HTTP response from a SlurmV0041GetJobsStateWithResponse call
func ParseSlurmV0041GetJobsStateResponse(rsp *http.Response) (*SlurmV0041GetJobsStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetJobsStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetLicensesResponse parses an HTTP response from a SlurmV0041GetLicensesWithResponse call
func ParseSlurmV0041GetLicensesResponse(rsp *http.Response) (*SlurmV0041GetLicensesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetLicensesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// LastUpdate Time of last licenses change (UNIX timestamp)
			LastUpdate struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"last_update"`

			// Licenses List of licenses
			Licenses []struct {
				// Free Number of licenses currently available
				Free *int32 `json:"Free,omitempty"`

				// LastConsumed Last known number of licenses that were consumed in the license manager (Remote Only)
				LastConsumed *int32 `json:"LastConsumed,omitempty"`

				// LastDeficit Number of "missing licenses" from the cluster's perspective
				LastDeficit *int32 `json:"LastDeficit,omitempty"`

				// LastUpdate When the license information was last updated (UNIX Timestamp)
				LastUpdate *int64 `json:"LastUpdate,omitempty"`

				// LicenseName Name of the license
				LicenseName *string `json:"LicenseName,omitempty"`

				// Remote Indicates whether licenses are served by the database
				Remote *bool `json:"Remote,omitempty"`

				// Reserved Number of licenses reserved
				Reserved *int32 `json:"Reserved,omitempty"`

				// Total Total number of licenses present
				Total *int32 `json:"Total,omitempty"`

				// Used Number of licenses in use
				Used *int32 `json:"Used,omitempty"`
			} `json:"licenses"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// LastUpdate Time of last licenses change (UNIX timestamp)
			LastUpdate struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"last_update"`

			// Licenses List of licenses
			Licenses []struct {
				// Free Number of licenses currently available
				Free *int32 `json:"Free,omitempty"`

				// LastConsumed Last known number of licenses that were consumed in the license manager (Remote Only)
				LastConsumed *int32 `json:"LastConsumed,omitempty"`

				// LastDeficit Number of "missing licenses" from the cluster's perspective
				LastDeficit *int32 `json:"LastDeficit,omitempty"`

				// LastUpdate When the license information was last updated (UNIX Timestamp)
				LastUpdate *int64 `json:"LastUpdate,omitempty"`

				// LicenseName Name of the license
				LicenseName *string `json:"LicenseName,omitempty"`

				// Remote Indicates whether licenses are served by the database
				Remote *bool `json:"Remote,omitempty"`

				// Reserved Number of licenses reserved
				Reserved *int32 `json:"Reserved,omitempty"`

				// Total Total number of licenses present
				Total *int32 `json:"Total,omitempty"`

				// Used Number of licenses in use
				Used *int32 `json:"Used,omitempty"`
			} `json:"licenses"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteNodeResponse parses an HTTP response from a SlurmV0041DeleteNodeWithResponse call
func ParseSlurmV0041DeleteNodeResponse(rsp *http.Response) (*SlurmV0041DeleteNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetNodeResponse parses an HTTP response from a SlurmV0041GetNodeWithResponse call
func ParseSlurmV0041GetNodeResponse(rsp *http.Response) (*SlurmV0041GetNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostNodeResponse parses an HTTP response from a SlurmV0041PostNodeWithResponse call
func ParseSlurmV0041PostNodeResponse(rsp *http.Response) (*SlurmV0041PostNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetNodesResponse parses an HTTP response from a SlurmV0041GetNodesWithResponse call
func ParseSlurmV0041GetNodesResponse(rsp *http.Response) (*SlurmV0041GetNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostNodesResponse parses an HTTP response from a SlurmV0041PostNodesWithResponse call
func ParseSlurmV0041PostNodesResponse(rsp *http.Response) (*SlurmV0041PostNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetPartitionResponse parses an HTTP response from a SlurmV0041GetPartitionWithResponse call
func ParseSlurmV0041GetPartitionResponse(rsp *http.Response) (*SlurmV0041GetPartitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetPartitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetPartitionsResponse parses an HTTP response from a SlurmV0041GetPartitionsWithResponse call
func ParseSlurmV0041GetPartitionsResponse(rsp *http.Response) (*SlurmV0041GetPartitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetPingResponse parses an HTTP response from a SlurmV0041GetPingWithResponse call
func ParseSlurmV0041GetPingResponse(rsp *http.Response) (*SlurmV0041GetPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Pings pings
			Pings []struct {
				// Hostname Target for ping
				Hostname *string `json:"hostname,omitempty"`

				// Latency Number of microseconds it took to successfully ping or timeout
				Latency *int64 `json:"latency,omitempty"`

				// Mode The operating mode of the responding slurmctld
				Mode *string `json:"mode,omitempty"`

				// Pinged Ping result
				Pinged *string `json:"pinged,omitempty"`
			} `json:"pings"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Pings pings
			Pings []struct {
				// Hostname Target for ping
				Hostname *string `json:"hostname,omitempty"`

				// Latency Number of microseconds it took to successfully ping or timeout
				Latency *int64 `json:"latency,omitempty"`

				// Mode The operating mode of the responding slurmctld
				Mode *string `json:"mode,omitempty"`

				// Pinged Ping result
				Pinged *string `json:"pinged,omitempty"`
			} `json:"pings"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetReconfigureResponse parses an HTTP response from a SlurmV0041GetReconfigureWithResponse call
func ParseSlurmV0041GetReconfigureResponse(rsp *http.Response) (*SlurmV0041GetReconfigureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetReconfigureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteReservationResponse parses an HTTP response from a SlurmV0041DeleteReservationWithResponse call
func ParseSlurmV0041DeleteReservationResponse(rsp *http.Response) (*SlurmV0041DeleteReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetReservationResponse parses an HTTP response from a SlurmV0041GetReservationWithResponse call
func ParseSlurmV0041GetReservationResponse(rsp *http.Response) (*SlurmV0041GetReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetReservationsResponse parses an HTTP response from a SlurmV0041GetReservationsWithResponse call
func ParseSlurmV0041GetReservationsResponse(rsp *http.Response) (*SlurmV0041GetReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetSharesResponse parses an HTTP response from a SlurmV0041GetSharesWithResponse call
func ParseSlurmV0041GetSharesResponse(rsp *http.Response) (*SlurmV0041GetSharesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetSharesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSharesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSharesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteAccountResponse parses an HTTP response from a SlurmdbV0041DeleteAccountWithResponse call
func ParseSlurmdbV0041DeleteAccountResponse(rsp *http.Response) (*SlurmdbV0041DeleteAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// RemovedAccounts removed_accounts
			RemovedAccounts []string `json:"removed_accounts"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// RemovedAccounts removed_accounts
			RemovedAccounts []string `json:"removed_accounts"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAccountResponse parses an HTTP response from a SlurmdbV0041GetAccountWithResponse call
func ParseSlurmdbV0041GetAccountResponse(rsp *http.Response) (*SlurmdbV0041GetAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAccountsResponse parses an HTTP response from a SlurmdbV0041GetAccountsWithResponse call
func ParseSlurmdbV0041GetAccountsResponse(rsp *http.Response) (*SlurmdbV0041GetAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostAccountsResponse parses an HTTP response from a SlurmdbV0041PostAccountsWithResponse call
func ParseSlurmdbV0041PostAccountsResponse(rsp *http.Response) (*SlurmdbV0041PostAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostAccountsAssociationResponse parses an HTTP response from a SlurmdbV0041PostAccountsAssociationWithResponse call
func ParseSlurmdbV0041PostAccountsAssociationResponse(rsp *http.Response) (*SlurmdbV0041PostAccountsAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostAccountsAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AddedAccounts added_accounts
			AddedAccounts string `json:"added_accounts"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// AddedAccounts added_accounts
			AddedAccounts string `json:"added_accounts"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteAssociationResponse parses an HTTP response from a SlurmdbV0041DeleteAssociationWithResponse call
func ParseSlurmdbV0041DeleteAssociationResponse(rsp *http.Response) (*SlurmdbV0041DeleteAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAssociationResponse parses an HTTP response from a SlurmdbV0041GetAssociationWithResponse call
func ParseSlurmdbV0041GetAssociationResponse(rsp *http.Response) (*SlurmdbV0041GetAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteAssociationsResponse parses an HTTP response from a SlurmdbV0041DeleteAssociationsWithResponse call
func ParseSlurmdbV0041DeleteAssociationsResponse(rsp *http.Response) (*SlurmdbV0041DeleteAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAssociationsResponse parses an HTTP response from a SlurmdbV0041GetAssociationsWithResponse call
func ParseSlurmdbV0041GetAssociationsResponse(rsp *http.Response) (*SlurmdbV0041GetAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostAssociationsResponse parses an HTTP response from a SlurmdbV0041PostAssociationsWithResponse call
func ParseSlurmdbV0041PostAssociationsResponse(rsp *http.Response) (*SlurmdbV0041PostAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteClusterResponse parses an HTTP response from a SlurmdbV0041DeleteClusterWithResponse call
func ParseSlurmdbV0041DeleteClusterResponse(rsp *http.Response) (*SlurmdbV0041DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DeletedClusters deleted_clusters
			DeletedClusters []string `json:"deleted_clusters"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// DeletedClusters deleted_clusters
			DeletedClusters []string `json:"deleted_clusters"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetClusterResponse parses an HTTP response from a SlurmdbV0041GetClusterWithResponse call
func ParseSlurmdbV0041GetClusterResponse(rsp *http.Response) (*SlurmdbV0041GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetClustersResponse parses an HTTP response from a SlurmdbV0041GetClustersWithResponse call
func ParseSlurmdbV0041GetClustersResponse(rsp *http.Response) (*SlurmdbV0041GetClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostClustersResponse parses an HTTP response from a SlurmdbV0041PostClustersWithResponse call
func ParseSlurmdbV0041PostClustersResponse(rsp *http.Response) (*SlurmdbV0041PostClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetConfigResponse parses an HTTP response from a SlurmdbV0041GetConfigWithResponse call
func ParseSlurmdbV0041GetConfigResponse(rsp *http.Response) (*SlurmdbV0041GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdConfigResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdConfigResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostConfigResponse parses an HTTP response from a SlurmdbV0041PostConfigWithResponse call
func ParseSlurmdbV0041PostConfigResponse(rsp *http.Response) (*SlurmdbV0041PostConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetDiagResponse parses an HTTP response from a SlurmdbV0041GetDiagWithResponse call
func ParseSlurmdbV0041GetDiagResponse(rsp *http.Response) (*SlurmdbV0041GetDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Statistics statistics
			Statistics struct {
				// RPCs List of RPCs sent to the slurmdbd
				RPCs *[]struct {
					// Count Number of RPCs processed
					Count *int32 `json:"count,omitempty"`

					// Rpc RPC type
					Rpc  *string `json:"rpc,omitempty"`
					Time *struct {
						// Average Average RPC processing time in microseconds
						Average *int64 `json:"average,omitempty"`

						// Total Total RPC processing time in microseconds
						Total *int64 `json:"total,omitempty"`
					} `json:"time,omitempty"`
				} `json:"RPCs,omitempty"`

				// Rollups Rollup statistics
				Rollups *struct {
					Daily *struct {
						// Count Number of daily rollups since last_run
						Count    *int32 `json:"count,omitempty"`
						Duration *struct {
							// Last Total time spent doing daily daily rollup (seconds)
							Last *int64 `json:"last,omitempty"`

							// Max Longest daily rollup time (seconds)
							Max *int64 `json:"max,omitempty"`

							// Time Total time spent doing daily rollups (seconds)
							Time *int64 `json:"time,omitempty"`
						} `json:"duration,omitempty"`

						// LastRun Last time daily rollup ran (UNIX timestamp)
						LastRun *int64 `json:"last_run,omitempty"`
					} `json:"daily,omitempty"`
					Hourly *struct {
						// Count Number of hourly rollups since last_run
						Count    *int32 `json:"count,omitempty"`
						Duration *struct {
							// Last Total time spent doing last daily rollup (seconds)
							Last *int64 `json:"last,omitempty"`

							// Max Longest hourly rollup time (seconds)
							Max *int64 `json:"max,omitempty"`

							// Time Total time spent doing hourly rollups (seconds)
							Time *int64 `json:"time,omitempty"`
						} `json:"duration,omitempty"`

						// LastRun Last time hourly rollup ran (UNIX timestamp)
						LastRun *int64 `json:"last_run,omitempty"`
					} `json:"hourly,omitempty"`
					Monthly *struct {
						// Count Number of monthly rollups since last_run
						Count    *int32 `json:"count,omitempty"`
						Duration *struct {
							// Last Total time spent doing monthly daily rollup (seconds)
							Last *int64 `json:"last,omitempty"`

							// Max Longest monthly rollup time (seconds)
							Max *int64 `json:"max,omitempty"`

							// Time Total time spent doing monthly rollups (seconds)
							Time *int64 `json:"time,omitempty"`
						} `json:"duration,omitempty"`

						// LastRun Last time monthly rollup ran (UNIX timestamp)
						LastRun *int64 `json:"last_run,omitempty"`
					} `json:"monthly,omitempty"`
				} `json:"rollups,omitempty"`

				// TimeStart When data collection started (UNIX timestamp)
				TimeStart *int64 `json:"time_start,omitempty"`

				// Users List of users that issued RPCs
				Users *[]struct {
					// Count Number of RPCs processed
					Count *int32 `json:"count,omitempty"`
					Time  *struct {
						// Average Average RPC processing time in microseconds
						Average *int64 `json:"average,omitempty"`

						// Total Total RPC processing time in microseconds
						Total *int64 `json:"total,omitempty"`
					} `json:"time,omitempty"`

					// User User ID
					User *string `json:"user,omitempty"`
				} `json:"users,omitempty"`
			} `json:"statistics"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Statistics statistics
			Statistics struct {
				// RPCs List of RPCs sent to the slurmdbd
				RPCs *[]struct {
					// Count Number of RPCs processed
					Count *int32 `json:"count,omitempty"`

					// Rpc RPC type
					Rpc  *string `json:"rpc,omitempty"`
					Time *struct {
						// Average Average RPC processing time in microseconds
						Average *int64 `json:"average,omitempty"`

						// Total Total RPC processing time in microseconds
						Total *int64 `json:"total,omitempty"`
					} `json:"time,omitempty"`
				} `json:"RPCs,omitempty"`

				// Rollups Rollup statistics
				Rollups *struct {
					Daily *struct {
						// Count Number of daily rollups since last_run
						Count    *int32 `json:"count,omitempty"`
						Duration *struct {
							// Last Total time spent doing daily daily rollup (seconds)
							Last *int64 `json:"last,omitempty"`

							// Max Longest daily rollup time (seconds)
							Max *int64 `json:"max,omitempty"`

							// Time Total time spent doing daily rollups (seconds)
							Time *int64 `json:"time,omitempty"`
						} `json:"duration,omitempty"`

						// LastRun Last time daily rollup ran (UNIX timestamp)
						LastRun *int64 `json:"last_run,omitempty"`
					} `json:"daily,omitempty"`
					Hourly *struct {
						// Count Number of hourly rollups since last_run
						Count    *int32 `json:"count,omitempty"`
						Duration *struct {
							// Last Total time spent doing last daily rollup (seconds)
							Last *int64 `json:"last,omitempty"`

							// Max Longest hourly rollup time (seconds)
							Max *int64 `json:"max,omitempty"`

							// Time Total time spent doing hourly rollups (seconds)
							Time *int64 `json:"time,omitempty"`
						} `json:"duration,omitempty"`

						// LastRun Last time hourly rollup ran (UNIX timestamp)
						LastRun *int64 `json:"last_run,omitempty"`
					} `json:"hourly,omitempty"`
					Monthly *struct {
						// Count Number of monthly rollups since last_run
						Count    *int32 `json:"count,omitempty"`
						Duration *struct {
							// Last Total time spent doing monthly daily rollup (seconds)
							Last *int64 `json:"last,omitempty"`

							// Max Longest monthly rollup time (seconds)
							Max *int64 `json:"max,omitempty"`

							// Time Total time spent doing monthly rollups (seconds)
							Time *int64 `json:"time,omitempty"`
						} `json:"duration,omitempty"`

						// LastRun Last time monthly rollup ran (UNIX timestamp)
						LastRun *int64 `json:"last_run,omitempty"`
					} `json:"monthly,omitempty"`
				} `json:"rollups,omitempty"`

				// TimeStart When data collection started (UNIX timestamp)
				TimeStart *int64 `json:"time_start,omitempty"`

				// Users List of users that issued RPCs
				Users *[]struct {
					// Count Number of RPCs processed
					Count *int32 `json:"count,omitempty"`
					Time  *struct {
						// Average Average RPC processing time in microseconds
						Average *int64 `json:"average,omitempty"`

						// Total Total RPC processing time in microseconds
						Total *int64 `json:"total,omitempty"`
					} `json:"time,omitempty"`

					// User User ID
					User *string `json:"user,omitempty"`
				} `json:"users,omitempty"`
			} `json:"statistics"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetInstanceResponse parses an HTTP response from a SlurmdbV0041GetInstanceWithResponse call
func ParseSlurmdbV0041GetInstanceResponse(rsp *http.Response) (*SlurmdbV0041GetInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetInstancesResponse parses an HTTP response from a SlurmdbV0041GetInstancesWithResponse call
func ParseSlurmdbV0041GetInstancesResponse(rsp *http.Response) (*SlurmdbV0041GetInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetJobResponse parses an HTTP response from a SlurmdbV0041GetJobWithResponse call
func ParseSlurmdbV0041GetJobResponse(rsp *http.Response) (*SlurmdbV0041GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetJobsResponse parses an HTTP response from a SlurmdbV0041GetJobsWithResponse call
func ParseSlurmdbV0041GetJobsResponse(rsp *http.Response) (*SlurmdbV0041GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetQosResponse parses an HTTP response from a SlurmdbV0041GetQosWithResponse call
func ParseSlurmdbV0041GetQosResponse(rsp *http.Response) (*SlurmdbV0041GetQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostQosResponse parses an HTTP response from a SlurmdbV0041PostQosWithResponse call
func ParseSlurmdbV0041PostQosResponse(rsp *http.Response) (*SlurmdbV0041PostQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteSingleQosResponse parses an HTTP response from a SlurmdbV0041DeleteSingleQosWithResponse call
func ParseSlurmdbV0041DeleteSingleQosResponse(rsp *http.Response) (*SlurmdbV0041DeleteSingleQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteSingleQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// RemovedQos removed QOS
			RemovedQos []string `json:"removed_qos"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// RemovedQos removed QOS
			RemovedQos []string `json:"removed_qos"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetSingleQosResponse parses an HTTP response from a SlurmdbV0041GetSingleQosWithResponse call
func ParseSlurmdbV0041GetSingleQosResponse(rsp *http.Response) (*SlurmdbV0041GetSingleQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetSingleQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetTresResponse parses an HTTP response from a SlurmdbV0041GetTresWithResponse call
func ParseSlurmdbV0041GetTresResponse(rsp *http.Response) (*SlurmdbV0041GetTresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetTresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiTresResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiTresResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostTresResponse parses an HTTP response from a SlurmdbV0041PostTresWithResponse call
func ParseSlurmdbV0041PostTresResponse(rsp *http.Response) (*SlurmdbV0041PostTresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostTresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteUserResponse parses an HTTP response from a SlurmdbV0041DeleteUserWithResponse call
func ParseSlurmdbV0041DeleteUserResponse(rsp *http.Response) (*SlurmdbV0041DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetUserResponse parses an HTTP response from a SlurmdbV0041GetUserWithResponse call
func ParseSlurmdbV0041GetUserResponse(rsp *http.Response) (*SlurmdbV0041GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetUsersResponse parses an HTTP response from a SlurmdbV0041GetUsersWithResponse call
func ParseSlurmdbV0041GetUsersResponse(rsp *http.Response) (*SlurmdbV0041GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostUsersResponse parses an HTTP response from a SlurmdbV0041PostUsersWithResponse call
func ParseSlurmdbV0041PostUsersResponse(rsp *http.Response) (*SlurmdbV0041PostUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostUsersAssociationResponse parses an HTTP response from a SlurmdbV0041PostUsersAssociationWithResponse call
func ParseSlurmdbV0041PostUsersAssociationResponse(rsp *http.Response) (*SlurmdbV0041PostUsersAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostUsersAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AddedUsers added_users
			AddedUsers string `json:"added_users"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// AddedUsers added_users
			AddedUsers string `json:"added_users"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteWckeyResponse parses an HTTP response from a SlurmdbV0041DeleteWckeyWithResponse call
func ParseSlurmdbV0041DeleteWckeyResponse(rsp *http.Response) (*SlurmdbV0041DeleteWckeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteWckeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DeletedWckeys deleted wckeys
			DeletedWckeys []string `json:"deleted_wckeys"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// DeletedWckeys deleted wckeys
			DeletedWckeys []string `json:"deleted_wckeys"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetWckeyResponse parses an HTTP response from a SlurmdbV0041GetWckeyWithResponse call
func ParseSlurmdbV0041GetWckeyResponse(rsp *http.Response) (*SlurmdbV0041GetWckeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetWckeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetWckeysResponse parses an HTTP response from a SlurmdbV0041GetWckeysWithResponse call
func ParseSlurmdbV0041GetWckeysResponse(rsp *http.Response) (*SlurmdbV0041GetWckeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetWckeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostWckeysResponse parses an HTTP response from a SlurmdbV0041PostWckeysWithResponse call
func ParseSlurmdbV0041PostWckeysResponse(rsp *http.Response) (*SlurmdbV0041PostWckeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostWckeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+z9f5PbNvIvCr8VlE6dWvupcexkd597zm59q65G4owVayRFP+zkbFIsiIQkeEiCAcCZ",
	"0Z76vvdbaIAUJQEUNXYSTRb/2BoCBEA00N1odH/6/3YiluYsI5kUnX/8346INiTF8PPh3TfvvvnbtyHL",
	"SYZzGuIoYkUmRciJyFWFnLOccEkJVC+L1e+YiIjTXFKWdf6xK7nqUElSYXlXCBZRrOpb3u/WShHNHljy",
	"QLM1khsqkGkbvWJZskU5y4sESxIjukKc/FoQIUn8uqFj/bqlT1Nw1ZHbnHT+0RGS02zd+e+rTpQUQhJ+",
	"/E7PFFjeofFx9VGREk4jVPt4NOh3rjorxlMsO//o0Ez+9btdczSTZE24ai/HXFLdzmGzk6rIMo5C2Aa+",
	"EISjDKfk+JX/vuqoeaScxJ1//Eu//0tViy0/k0iqhs0DzDnewiQxxmOaYcm4haJDKiRiK6SaE0husESY",
	"E4RR7TVV/jVIHFOuxng0hkEW0whLItDjhsgN4UhuyN4AHrFA+u1kq6hE1xmJkWR7w9pN2ZKxhOBMfT3M",
	"5RdMM1RqM817HRytYb6kkmO+RbobpIuXevOQ4y/YrZNVgtcWut2ox9WCJTF6pHJz0FZFBpIVqfqYfjAM",
	"5oFa2J+o3NQ3s3nUq6+Vq86IqYkSXU6gQD06ePCLZcSHM2MngdnWDipcdRhf44z+G9sndFwrVevgcUOj",
	"vc9HS5KwbC1OErjerhnrQedtqE84t26vHwrCt8iUujdG09oZsmyNFCPSzaD9AR/NG1Q6bmW2YVye20yY",
	"FenSxqZmScFTlBm2qRukMckkXVFguy0Yp2AFjywLYwbPFc/R7artvyGcmD8VK1hRLiSKiSSRJLGVxCcp",
	"lhKJXR+mytADTgqiiLZPqyihRIup/edrzorcJolUdQSl6BVdofuMPWavbVPumhDThC4+RTe7WDFNqMLG",
	"QdgmLmJpijOL1OwNB8gUQqM4zxMa4WVC9mTASf6QJ8WaZk6NgGbrUEjG8Zq46LWriUxjlpmJscRhjrlw",
	"L+halYaG7PxMt6DfAqZmmRPHVDQ2paqcbspGOKGaOZ5Wp9KkuzXFTr7MSUKwcI7aFBs5Z2vggXBhGN3+",
	"wFL8mfFT7UIlVLZhaT6lEWcnW1GVmlvJWoxFVXK3ckyTNk+uOo+YZzRbO6VJVf6l8sQ0dIqlnGbUZUMV",
	"qy4ffB1mfSCxq0OMTTAfHZWUkqMOSil7ILHjwOSlt5feXnp76e2lt5feXyq9S0nTbEiz1jpn23kloVlJ",
	"sE7wWQqD1bLaSFQXMb/c0Lljkc7X1ExyEjEeCxSxTGKa6UfaRMeJkUCFUKzYObr5NJgd9zHnOLpXzKtq",
	"xyJa7V+lGkTGbPgO0RVKqFADWpNMqR84SbavD1SO///frCqHzXI76CuxGCOaAftfKt7WSn+xiwEY7Jex",
	"f2hCs/3eZHGF7oK7K0Rk9PqkJQpKbUsUJwmLFBWPySVIxLJYWE3aSwKW2ygvkKmGdi21mHHbnrPRoLtn",
	"NVf7+xPj9wnDMYo2mONIEl6a6u7JtrVlXUjMLQvq04ZkYOnTqx3YB1R9/lcdmcxP3Cs4xatSqIh1b1cG",
	"4LKKTcchK1wkFu30V2ahcF/XRj+MZ+34ZaMlmek5rbGwZgPyiC3yGEs1C8ETjuRXsxbbVtgio78WpPXC",
	"oSKsTeUBwxDIlO3d9qwYB/3aeoeQ0IxY9dceS/OESIJyLDeoyGEKN5RwzKPNVt9PEMQZkwcTe6yx4Kdj",
	"sn9mS7v84IVVEtzhp+/ZUnRVBXLEn2m2ohmVNpbFC6I4sz4vog0WaElIhgSR6hvKF/+Jfu4IIn/uIHVm",
	"+Lmjq//cQY80SdCSILrOGK9L7/o9jOMsOlhVrVKBYCRqzsxQypbVSOCCA451/0RMbgh/pKLss6yvBB/R",
	"95ttGAyRZ03GP9ENTkS9lApUZKqZ40+27UAcSfpAnITzJLs8kuV6BtpuwVue+y14yfR0aKmGbp5il0cx",
	"USxTKo32e0S1GZR62l0m7R5xkoRRwqJ7q9D7hJOkX3DQiiaEf8+WnoiXRkTreYlJnFgp6rfjy6KkS70p",
	"peR+QdN2vuW52s6e7JdPduuW5kQ0XIsdLhD7OeaW5/NpMJsW2R1tMoF6U+FvZSo8uielWSEt9v6SVJ5O",
	"l0An24asUW6fKFaW/ZktrfK4pHGlXXlKXxyl3dqUp97lU+/s7eiJeSnCMWMxaSLTSJV7Or0clmmUGk+z",
	"y6OZQ8WxqDecMk7lNpQbTsSGJZYZvaPZhFM2r2r4Q+dLsDVgTjIZOv1fRmpNsxXS9ZpiotrE3Dnv6MsF",
	"1uzIUNZCKxxJxv0KuzzjstUrooxnxA+YJuCx9MNYs8u9c679pXrVk44KYoM5ESHHj5aVVPrZIF1LC4AV",
	"42iFKYdnKMJJVCSlR0CLCf7dIka9O7x3h/fu8N4d3rvDe3d4H8z2Gwezneufbpa0y0O9LD7+wqqkNfbH",
	"filnzKLgTQ+cG5V+C+JSz7/H+PgNNDa7YMskZ0lis0ZumJA251V4470qtB2TGHe/NFGFLabuXDdkm8/x",
	"NLgdzObBdDC67Vx17hbD+WAyDMLZcDG9U/S7CfrBtDsfjEedq07w4zyYjrrDLwCmMOtq5BAZGYtt92kj",
	"FhP32YHnUVgTFQdbaNIr+W5lKAIAlGqBtzp9JSSS4U79iEnOiYkakLwgtvngti+xx3p4g9rlGUH9sc0f",
	"2/yxzR/b/LHNH9v8se13PbZVh6k2RzaaCYmziAgPP/InEdwVRY9HsCtyK83PDS8lT5LjFuiC1W2DOqyg",
	"FU0kged0haAJFLFMSI5pJgXAPZJM8fTYepY23xPaNPFewgqlh+sq+jztbsEuaQ7agEqOc1doF3vq7OU6",
	"rkmq39ingHoaEptCUUUXVwOCWzOi9IvFaPAjUq8KidO85QEGujoVyrzfGdR+VnctfX29GurVUK+GejXU",
	"q6EvXA3dKRtt9NDPbBnSbMW8GvonUUNLgAi7N8tnHYX3TBgiK7b0Z3BctsET8YKEpa7lUHI+s2UJ1ILK",
	"CHqE12Tna2VRebzXVbN6+ftjWMQpzcL2QDcoxTFByy2CF6k6dmh/uuNVpJ2mlJJj98wesggn+kyT4vsS",
	"O71CtirftzMD2DSaBVoUuO/ZErCLYNcgqHuldi1cXozedv1KvEA0FaBoip9CicW9sHry07RIy+bZCgma",
	"FonEGWGFSLaIFxnIZmgJQStXmuQZQwlNqfR0v1S6K2pZt/Ici3uzlyE7hKqIaLbb2J6mF01Tw7KPdSpt",
	"2yJPOScCLssVhTWxhb4zp8KAwlkFwM7xI2wAGdupgGBBOwZFazF9SyyjTbgiWBbWK/YbU4JKXR66greQ",
	"rvcXAXLO9h2m8QSv3STSTe1pa7UVp1uwe4WUTviqtOKP9ZFZh0QT8LUO7R4F16YYmeAcv/vU8olZsUxq",
	"FDYj+SN237LgQobLYrWyTcW1KkW6FImcRHRFowrl9Hgx1BoLhcQ2yu43qeqokxCmiXiOC5gbjlGXN+zE",
	"8qxUbcTS5lO94kB5tJoBgycSFep4U9b46hCRBtnVNhndpWBJUYIRSobGvQGq6qNlkcUJaWzTyhb3W7Fb",
	"+FU5XResEO51q8SvmWUNUKtfQNqfyrY1I8ZJqNabRRaoVYgT+m+Ya05Q6T7Ygjmr+iLM1eJk0T2xOrmp",
	"MeZqaUKNanV43nWBgG55Ea4g+1gWbcM1eyDcaq/sTRaoqoeqep6iF07RVB/i3Ke7PcJ6el48PWnmoKcu",
	"8PR8AfQUbvLtjC29yUJ40XnhhARFSJ2imyDk9yiJlltEcLSBs7cn6yWT1XrkmZGURixhGYoJ2DhJDO75",
	"itDqgP5f/8P4eyCq87LSbI027BGlONvqpSA2rEhiNWVVQgGwYMCyMCdEEkNr6FVUcE4ymWwRZI2tfJPW",
	"nIi367ywegNE3HaNOKcp2T+BQktC1ZZ46bqeMiMIHxm/p9k61JlkGbdAAHzSVVBVRS3NQpDKFuToIiY4",
	"Tmhmu7TAkggJl1o6vW55FZbirdvTx2+qC7v2ikmCt+HSGgO3Y5RVno2VJByoTBK6psuEGFLDCoAjbzVB",
	"nKhWdTpjgSUVq21pfdhf635ZXB6vjUlOshg01WPLCaSy/syWJq92WgiJUkIkigiXmGYo4lQSTjFakpX6",
	"ZrBgq1UT4UwvGDuv4fSBxCF5ojKMrDel7+l6o7iOqoJUFYDESBJzB0/yY2c+TmTBM0d7E84iIpQOoCrp",
	"Fl8Z1wnPri4RNJ2uM42QdUAai4VvBnWRIBkQITe09vS9YPo6HC+tlGzpIimxtJ3rZvAcrekDyZTqX2MB",
	"tmjdwehjdwhW4kkw6uuY3dmi1wtms85VJ5hOx1P1ZHA76g4hkVBvPA3C/uJuEvRbBO3aRl6KWIf/ESiN",
	"j3UnpCWJcEp2olkyxIvMq2EvQA0jWewgc5DFQLsrxAlOkDqNPOXgW+cJ+xII+xQlRUzi0BFf32NpipEg",
	"Oea4fmLVurTWr/AWZUyqSVGHTHsATZQUosIuP4yQP+JmUmfxWalv65iIgqtOGgFPZTlrBTPQoKcFdf1s",
	"d7z0mpnXzLxm5jWzF6+Z/QHxiitMEyNG3N5N0A8IjQhD50otVG8W3Ooi4XYgccml8g3dixpz7SbE0n5M",
	"dBqkkHFaIbjsWRPgeemf8hdhAqtAsS2Emq1dI69P9CHoMqHZWoSuRB5deI5MPZgdJ7aNrd0Hquhz3O5H",
	"eN6yXTtO0PeKUi6soA+D4TA0Cz3sB2qhB6PeT52rzmgcugvfd2fhbN6dB2F/MA168/FUPZ0Hs/lgdBte",
	"d3sfbgbDYeeqczsNZuH1ALZPGIxuxtMebBVVNRyNP4Xj0VC9OgtG/fD78XUYjD4OpuPRXTCaq8eTadCF",
	"ArULp8FNMA3vBqPB3eIuHI37QdgbL6CiehWG+34xhbHMPgwm4Vz1PptPVefdHtQ123hwPVQPe8PFbB5M",
	"w8Wkrz7GDOZ9MA+m49tgFIwXM9N58GO3Nw/n3dkH3Wc4DX5YBDOd21UX9iYLS1k5KZ/ej4eBHnRtfubj",
	"STiZDsbTwfwn01O315suzJeFvWHQnUI7ezPZH8y615rpqC//1J2F08VopD9OPTGNzAd3QTgNZoGao950",
	"PNr7mrvgbjz9aW+0ixk0H9x0F8N5OWdHzyfd6XxgAKT2S3Ru3f1nn3ofAjWt5QpS7d11b0fBfNBTZC0b",
	"C7szxUxhHOUUhd35PLib6MHNeu+D/gIIt/d4HkzubqdhMNJz0kbFXHMiQu1B5/ZxU1OOaBaTJxDu4DJV",
	"SwkNDk/ZgfBo0TMrcqvj2C3E+ZaO2ERH3AI3ZI+ZqGm7LaS47sUuWnU/meHsjT0dfc2GSGdIyHsiCWdr",
	"AsECwKoG/Su0F33q9a/L0792JA2tfZtIH46ztb7Vw0mCNke0jlias8x8p3PdsNXK2onxJRfai6WaOlg5",
	"+qYHTP1VJ+XKPRqHX2EXuMKsOQnesyRGryQvyGvEeBUY/QpsB6+dvvjNAWntZkC1scPqO8YXLIu0nr3c",
	"Oi0Nds+e3fXmTlb0JouW5KnsOQfhp7tgvQb0dNDTrTCEx7NVVdO7uhRl9i9sh2LIJE4OHZqwUCd4vYlb",
	"yy+wR7Vrv6RRy7ZtCxRkvAOiUpe1GnRKUuMjYSWd+4v0i+jVHb1+XVsz1glz2B+bJmyvefd0tQRIcZ3Y",
	"K0BPOw5AdE+k7UyuHcZ3qxsik7ITiYQcJ0uuyGV80N2vO6htXm9NbZeVAdoxhY1WhcWoOxyOe12txdZ/",
	"D0bhYha0syHsoxvo0Zvef2kFzPQVJsMxDE2nX87HaNCvm7WkONDbMlwB/jDGar2sD/7a7bXdomszD64U",
	"KxZWXgZgtFgjCbWGjLGYvBIHO71B6TZQtXbAF9h2ItqQuAATga5MWYZSIjcstq3B7sfuYKgOS52rzngU",
	"hNPxp85VR50Tpx9bHqAeNyyxYxeAEwcUl347hNf83tpafZu+eaY/V2s+okj3wHdrM2CgsY6+vzdZqHPj",
	"uPdBH4zHUzUT1+PuVO0+fSw2UwMn/kkwDU2lSbf3AU7xs8rgZ465/cFsHl4Px70PnavOcKjOxsPBKOhO",
	"W82n3HCCY+2GqPZN01I0xlBwsIO34CTamywgtMdrwBeY26nO3+pL26h7FX/Tf9lqACsxvuSW5VJW0/uy",
	"/KumNNqYoNKDBf03CYXkTQtO7+NXNENYnwNf7wfilm5YZxlCoHN7tGNP+5/qQEfbBt4Z5Hdmr9liBvYl",
	"bYm/mwwDLUx73VEvGGpj2U13oH/MB3fBeDEHO2c/CNVzbWGsrErX4/G8fN4Pun21lxVPWMzD8U1Y8Yhh",
	"dzHqvQ+rhsGYtqj/DN+Ph2CmmgS9QXcYBj8O5prbDv6PHnlvPLoZ3C6m5V8wdvNR8/FkYlrT1aqxjj+B",
	"4RKYEZR/HH/Y6/fG/DX7GPaDYTUMuK8oW+/eBqGahzYsKsFChiBpQqK2o+MwMsSl9+5ntgTkHlPbLJaa",
	"rPJ+BpfvZ5DQiGTCHgoMJUqTqYc6NCgyKaaJQ6TfYZog8gDXfdtcNWrb99fB7QCyFozK3bxb72ZX/9e3",
	"7979z/L3/979/F+7n3+Hn7vFf9XpTqfdn0DWz0D9PrryaLM/4OsaMlhIhjiJCH0giKi6KGOyOTI8xU+h",
	"I3joCKnFnIVBFWqwWHhl4A/fUYqqDqedY7Jq0evp+jLoqogXikcqo034iKl0uN6VZNYxLgypqlo2wqsQ",
	"SVSGRrQ0PUUiTPCS2NKiF4mkb3pYkjXjWzQjUQHYcVAdsayRYcOhWmuZeeGOYTQWJqoOnWu83EoDB7Bn",
	"//Rr9vKke43AjuTerSlsNR97El8Sib92fGMRbawL47cPdzRB8WEVutm8eg/UpNrFvV+ulyZFDWVLUdgK",
	"pbAUm6/UvPzFNPGXMi/YPdmqUdAsYpyTSL5uKVPNSGSahzEV9y3WmUxzpKoikeNo58HmF9yL8z/93nja",
	"WUHciXxk3AYAoAuAxYlTEdAZtQEhT8mvBYHUb5/Zcgf0G21wtibtL5BDx33GMUPUBwyPOnHBC9SdQPGc",
	"WyT2QLgolqqJJWlMeFgjQJtEnns3/A0DyNmjLdlmzW3VFV7Sync65yQUhXAFtcFNOC8yfeiCjaXGm2Ah",
	"kShETrJ4/9Tl98GFKbI5JyTNZVPUosbMAxtbjEx9tUJ1DIm3N78cKuMT8akmLJWlROziUpXErVHdk/tF",
	"kNuKoWoQf5WAK6OQeaUaLQu5CxPJmGwMFSl1KKeuVYGG7KlcfrFcniaUc7aiiT2oUxXs+WviKJLhGqsv",
	"Dc2Lu8RMRzdLo/E81GESozFc9AajYHoLN7yL2RxcP0bB/NN4+qFz1Zl3Zx9aXQn9yqzpYXCidHq2QjPC",
	"H2hEbBoUeM4rraRM2/DDeLbbAvbsSg60He0Tqgrre0gjqByAptRWHFQtLJPdJ5LwlGZEoEfj7lOHaFrq",
	"cy8pHCu53KvnBi5Xh+kDANz6BIAzQ4PUYCuj8NF/E3Om8lLiBUgJTmCdhlGzj56WElC1JQvjRDy4kiSa",
	"ABlOBOEPGjxNY5tZffSMS5pzWQ/34u+r6qpJE39/ymAgSEKz4ikEWj1ZJmIWDFUFVFawtbHBnFid8R+r",
	"TQxYShsdgVl6iMMaYhU+kw7rAbddGzPNWKYmaf/E+Vw0ALFhj2GLQ+LOu3GofXbm2j3gbvAjOMIMx73u",
	"cBf717nq3AT9YNo1cWw3i/liGrQbkfYrBXvgkmEeNyKc6cpgAoTKdWWlVcasXWeOGF1rXyYSwJt1LhbX",
	"QOIsxjwOHcnbJgaVXsiYcI5A8bHt6LIZmuWFbGyGZqdbYYU81QwrZFM7vPGETgDxX/HSJVnjDHJGUbGD",
	"ngF2uKb+8PYSxDL4Z4aNiQzH8AMnZboK7eYA73GChSNrZL3ccmxTz6Ehc3eIJkZPZhzdAJxB5Tp63Hax",
	"TKlsDX31iAXSr3hgpBeyKLUxt4nCdeLWDcAk1pGIokg9sV8GsbdCkvSc7IorzlIE6Y0jmVjP0Y7keDs1",
	"S1fwq+HiVCogTDu1HKoimj2we7XrM+2bol/zlL1gyp4KjrIT1gdGXTpdT51t7XT1TjWXTldXzrBTlK2i",
	"uD1tL5a2dn/SQ8oa2DjwEyFCaPLeen/wi6QtxJW2SCKoK56TRvDrRTh7s+YlryCaklCnAnd67lZuWDRD",
	"Kc0KSfxx6lJJeTL9nCfmyyAmJyIEX1F7tD8EYxzjXR1bR1Q7S5q5EslLpuM6VJVdYij6YL+yh9ZWnPzq",
	"GNAuAWmLdpRkUaNu7VKwH92ib2L34R2bJsF9anl+f64c5vJ0Ct7ndlkp2u5O7enunt+lSYRn75CTXxtW",
	"aM2BpXGZFsKRnhlCsQf95wJrQrt2hwFoGWA1W0FpPkb3xJFQLWFKtdpgjiNJOP23dj5Q1VvhX1uBG5Y4",
	"ul/RJDnhGVNWqzwUuE/18VKQGhSZizy2QqrsERm8PLz308uJ4JQWUPhZUvAUqTLDao+xGxNqLkX2nwM4",
	"sIWfQ3UEpegVXaH7jD3aodG1W5CzCQPEVS9zsGhnEwBJ3DQIayJPJZFsmklvOECmEBrdIRK/PguzyPiP",
	"HiM8RnAQptk6FJJxvCYueu1q7pxRjxPWYYnDHHPrBOl2alUaGnLkVoAW9FsGFf9oThxT0diUqnK6Kes1",
	"nmrGAvSosftd3ZpiZ5yegZR1vV4izpoXLA08EC6MV8P+wFL8mfFT7UIlVLZhDWKOODvZiqrU3ErWYiyq",
	"krsVK2bZySdXnUfMM5qtrU7OhG9RVe4E42x0HhmybI0URy4bOsVSXHxpphkSW1UNMY4eN4ST6sEjFmhF",
	"uZAoJhJ8kZ6jbB1AvX1mS/Xt+wrYvqS24bI9vPvm3Td/+zZkOclwTrVLaciJyI8nELzHnAQwpV86/dDM",
	"qcl3+LHNNozLc5sJXYJfL2uTz8c0SGOSSbqi4F3ayqXy1CrR7VZrRP/5dVbIOXoa+HB6Rc0ral5R84qa",
	"V9S8ovZsRa1NUIpbS9BZr8KGpF4Vho+uWmXzOmvT4jjmRDigDrpxzK+0gVoypITgMqFigzDwiyIzOIoo",
	"x3Jjm31t+rajKVrzCuxwifZBjIxO10LP0F3SOCEt+1VVz8gUodvfZR1owP6nGbq7PueTHCIV82hDlfJT",
	"cLvdOy/URt+rZiEG+Nk1ug5cY0F0rTIfgAlCwmhZFoE6wFmStFX8loy18/wGxUvV9m7AL0LxWhZcyGWx",
	"WhEeGnSe0MlNuokkPMOSIFMVeMZhIJ5YRqCCmyqS49WKRrbFbKSb41agV5N96BVAnKlJp1mZfpDEiGQP",
	"lLMsVTNslent/Zvtb5/w04EKCOC9Bc3WCUH5ZitohJOaJ0Z1T9Rio0V5EZoLQFv88AoXiTT5CWCyy8tC",
	"4zDEnpU4R3WaMGzTKicLBHcqWCBOcsZr90eQsK5d604OrsZ4hWgWJQV8hp5PtZmN+0q7Lshqpa84w1N5",
	"haqaWlS90smgIf1DzUdHlbXEOiMZ4eutLUm4eo4KgdcEVNkj7ocfiFKjw0csbflduroYAfiPSdcAZWq+",
	"kH6pHe/GgoT6fRKHrvHONwTpMlTWRUsiHxWj2efu6jQPg9I+h5pYRJ+7tTuDhDqcrKnawHrFgP4bw9g/",
	"syIhLRniF417f1h7H7A/OFWkB4hiTNLDr4K3TCe1043AaZ6Q8z9J6xIuuqsPopmQOJNYJ2c7WgEISxic",
	"pLtMhC0HWq4bL4gvzMsEbFuRUskie76rSs0y9FU8ZReHxYnklDzYta4WizLn5IGyQpxmFBNTU8+3FoL7",
	"rzwzORZ5Au0iCQXJRGWZdSCt/cGZn53nue4DpglAjj/rILfihKhzyZmHEvWaU0T7rX5hOvc6Lxx+wqWf",
	"rjDYGbVTpoFtSgQAaSBs/MCPVtTauixv1dak0V6CQ+urYax2gI0B9XUBWrduyp5Z72gotXVMMxdKyIYJ",
	"6c6e974stbypZWlErD5NvYQVMSqr6DSY7hbsBsKDNkzuoaNW9FVWIbatjtAVY1dv+JP0S7jCeGYigfZG",
	"bbXSR05k3Sepk0KFeKXO1C5MK6VeQr3aWjOEqLC0oAUDfKXtxo3JGD+Mxp9GnatOX/836EN6vHpaxmA6",
	"HU9riDIGMqaWOU+10592IUdNbzhemARMiztVqyqoJ3gajefhNJhNxmVCK8jrFPRDM4x6tqfB6DZcTCB7",
	"+mA0D0bdUU/3Drmq6mnczSOd+gqeVA2Ydvs/jbp3g15Y+wZ4ZTCb6exVk2F3NDLZKHU6nGlQja9spUxC",
	"tXtuvrFsfjSe3rXC1FFsAOt7GQjptiFJmBpI1zhSE1y+s+wxc+bkwUnCHrVJmReZFlGQEoMKvapeweaB",
	"/cQAW4pTyC1oNdNUaLmiAS5XAAvANNPAbqaj8263GLftid4EqZKaQXl3Imx3XqggeltorJzg5BzjM8vq",
	"VGrB+1z4H32iEaUEetzsKK8R3hFGP8MO/rlzpX6p5Rj0a38MRrf6L7Wx4A/EuPnz544bNkQPJtSX8XGI",
	"pTX3pf5EXddc3HsD8ssAmAPyCiLD5bYpidfjhunZr+jsQCKEGDftPr+2pc4Z1W+bjLqcE64U4orPaMak",
	"nrS/dKrB1bXDtHNwI9s3FamRy40gZBpB24jfcnv+RRh5rQgDvi/wbeVm1ZsQdujPnQqbcpcpUGcnN03o",
	"kfhtdIFwLCBrwpMoYNUpwZgr4QXPKl8GjV2p3Gvhu67bI/E22tBcNOgCLkPm7lojbHmdtWd7MCqjPpaf",
	"25/1Mqa7FJLjSAL7HvQP1Ma9zuF2RtAHuF3c3SLACoSfQpLcaqGrD8OlavVYugSThtG2IPb2SitdV9C/",
	"ccLRl/N6fPp+oO0Ss2fpHVUcGdJQVK5EGsTYotf6U9elnbokSXPGMd9CgiOXGg9oyUaJX6HqHZPpSLvR",
	"qfJ5mt/MzgIDaNrFCVsDDykRAKzX0wbXp02Pdscllq3ouuBKG+E4ut/LJO+ONLXbBOfHLZxyubE3/0jo",
	"elPdnxyexA5kj5ZX36BPWKDyxdoRcEkTbcm3fN9eVv5qDmNWLOvonkbq7bvZWXzY4ibnNz0yy6EJnpdn",
	"VX2psZ8kOi94zgRppf62cb/2MQvNMQulL+C5QQqV8cMHKvzHBSpUtPfRCj5awUcr+GgFH63goxWeH63Q",
	"dI9ShizU6jTELcCusJXoex+bc3DCHrvle7ZNRLKt7U4i27rfsn0jLr2QGxyUG7yNmx2NrS8aM8b+REgs",
	"7t2uur28uKZZy8sjqQ6LjjNkWy9e20zF2l/YMngr2M/3bNkv33hGSvs+Wd2RdEJ4b7JQilX196j1xdVO",
	"Ez6nM68iXWB2Ohsl7ZhPh+vE0/LCaGm/jjCsYu4B7C7btdjqgchx5Er3dqvKFFXbfQ2cTs7WE271W63k",
	"faqxLy19KMHclFsePynp6TnLxTq9VwR0gfPtSDjzqNYXSsRTqtodftrTC6u/2+uFjiDsO/w0MjZXvyou",
	"bFWwB8LDJkjj8QPhSswModhT8CIpuEtCeSR8a4kl99JPq8dHd9oEKXLPytbU+FyexSvGI9LqDhZuAp1Q",
	"2Vk9uamo+6vufdjeneWzTtntD611TuhX/Is+tB4KMU/LS3O22mCr38IeH2ppnrOek+7wkzkledpf/IHX",
	"YPFbzpAu1ZJmpWr5LKFgv+ipQhmcYTwsJqGwOwmymMyI3TRbfYT1DB4aZxWrB4A6jkcjV2L4qPLysQ/I",
	"7onTYM7+okmt+PPxpzo87Qy8UuVsZ3eq6/bmg4/Bnlcd+IiVvmfgJHZaI7EOmVPGqdxaTfDhCkfSmsHY",
	"vPU9W97oKi0ZFWlobN7Se8L2Gb+ys008P0Dw8TGalAkys7iz2F9wXxtZX7DKApKQSDrCN2cVXLuOY99z",
	"9EL6Vchgr+M6j5aP1uVm496HYA7ekuCeeD3uTvudq85dcDee/tS56oxHQTjvzj6Ek2AamkqTbu9DOBr3",
	"g5l5MewHN93FcB72B7N5eD0c9z50rjrDoVqFw8Eo6E7bpVlvTOQ606VguH11Oxxfd4eK1S6Z3IAAUFKn",
	"lEUQCL9S3Ng7olxonhlW2C74TKSHJQW0ej7X73nyv/BE+HonN25xT+Y/oTpbumTvk2pJk4Rma+MELex5",
	"YK51pU+mzpk6n2rhed4q3p34XHfiPT+dc32Ka3GK3qv4P86reC9K1fsVe79i71fs/Yq9X7H3K36uX3FN",
	"oDR4Fu/VauVb3C4vYk54SqV6ghv8iwHKONRYxsdtX6vSa13oQPoNdU5my7A46bVN1gwNVdHHrhmbllHO",
	"OuIa6q8MELt75uzJnyGEerULnNZR3g4r8SlkCxI7YCzaKChum1NQ2pu8FnLxWogb3PJmB2l5DInZ6A4g",
	"BIso7GmYII0Bs4NbsZhVIWYcAs7D8me/Oxj+pB+VPz8FwYfyWfV7cDsaT4Pw+/H1TJfsP+iOfqqMrrN5",
	"dz7o6VrV70l3Oq9qjMbh3t/jj8F02J2odydBr3o8H9wF4c1w3J1DbPpk2O2ZcPyqymQxvQ3C3vhuYgbe",
	"79ZGrv9Qv4JRf/dY/3EzDH7Uz8yv/mLanQ/Go3AyXMzqf98NRgsz7PfjYR++OezezINpWLW7N5C77u0o",
	"0N89+zBQT96PF9NyTqvfi1kwDfvBMJgHumT/wTQY93qL6XQwum1lod55jR46n9r9Qq86CY1IJuypOEyJ",
	"TWbiJ4OpEpMEb623uDNV3lfFiGYlCE87Zm9Xu6a7ld14z+cQNyMWtxc30JCSk2fcz+1do515QZkXfK1G",
	"nuYJMXH2B2ExVv4/WKHdqkOKVyiuJIi8qjPSGgYSwGDUj7HAZAWVOtWH0qwTpP5StR7YPTB0L0ou3nLZ",
	"BHAEG9GrCS8lKsQBC2JX4UvDJrJbkLWR4FlHAv2iDThjh6/fDATy1+/QUrESPZk7cskN0lqNX30v4U7E",
	"Xy+cdb1wcFh/xgWDv1T4E1wqeJuztzl7m7O3OfsU6S9BgJ8Uy9rt3UtnL529dPbS2UtnL51/I+nsiq9a",
	"YcqhDNFsxY4Yk+u1rrkhoixDpo77GvS5QE67NKGQltNyTVlWuEKZkg06G6iu3Arntfp6S7ysI9bjppqw",
	"1VGoh7ujhDzYMg0dNqYzRVKBoP4/AXO4TNupb+UQFgijRIlv3dsVWhZSZxsDJGqJMkJiA74bU5GXFyX6",
	"O1uM1rZ8bMm46msAQK6ffQMzgylwLYMcc2tK4Ak8b3rt5LWJ82XXuq9lf4Aae8DC3up4aQ73Wrve8Qbb",
	"rVvFNyo+5unYzMz+sLsLi3IclkBWVt/3N7pUpwpwSyg7V1INOBkETKjjHV3m19GF3YG1OcDxIgtLlwJX",
	"dGqyRbzIdB4hTsQbQSKB/guteQ5w+SEg25uGhF90ftGdWnQO7faOYFFwbbTA0QauYivl9vddVC00xNO2",
	"L/u5FJKNKc1XH7cr3zOHn9liFkw7V53ubDbuDcCHqpUD0+kpVru2TCFRZFSK43OEe1FB1bZ6Rtmu36kX",
	"pWa02akAlRC6Dgc6iUx2cER4bn51b09vvhA3s9vm8lunoVrGoY6VdJjb3Y7uNcBrl5P8jms1W0sEotkD",
	"Sx6qLIQl33vFsmSLcpYXCXjOUO2EQ4Qk8euT3vnOMT8HWduaVDu2HobBVI+fYQhoczpvb4oGIWIXcAer",
	"Bt7/pcVWjxjjMc2wtF7BlCEU4M1kcr1zgjCqvaZz/Xw5iWPK1RiPeXMW0whLSA9LFMcF1lwfgNp3+u1k",
	"u0sXXWYtw4crpC4PrHpE+2mGSm2muZFHdfmSSsjApbsxLGqpNw85/oIv8G/ftXWkc2i3abWwP1G5qW9m",
	"86hXXytXnRFTEyW6nECBenTwoI3KYieB2dZObY7xNc5MIIsFTatWqtbB44ZGe5+PliRhWqg0E3hfWJjR",
	"7HXehvrt2ebX5YC7ux3na2qNcRIpctUzx3Ki926FOHNCIQf/yTYJ1I7vBO1fBXq54SfvFAtJqOIfaE0y",
	"xYxxkmxft1NabSx90FcsLUY0g3urJW6bR/LEweP591bQhL6v6k0WV+guuLtCREavTy5RKP3FmpGitNke",
	"41K5zv61pJt5sUv9a0srd46Sd9qurrSpT4zfJwzHKNpgjiNJeLmH78m2tcgFX+7GbN5qtYPQMGlqn/tV",
	"R7L02ak8WJpabf87yVBWsUJRAeT9MZUNPJYVIB+1hqlqFDEm8euJ0+xOsozYQjtzXnWCJxzJryZGbCts",
	"kdFfC9J64VAR1qbygGEIZMr21MAV46AbWZWLhGbEehzvmTgVlGO5QUUOU7ihhGMebbYlNC1n7NBMYAsk",
	"skK42eUHL6yS4A4/fc+Woqsq+AP7Bd7vYLj8dRLOk+zySJbrGWi7BW957rfgRaeEsGuphm6eYpeIQrfU",
	"oVhWqs2g1NPuMmn3iJMkjBIW3VuF3iecJP2Cg1Y0Ifx7tvREfBGxcHYE5jv85Lfjy6KkS70ppeR+QdN2",
	"vuW52s6e7JdP9jNdlmwLxH6OueX5fBrMpkV2R5tMoN5U+FuZCo8CPFzeZoZUnk6XQCdHSomScvtEsbJs",
	"a8LdO/xU0rjSrjylL47Sbm3KU+/yqXf2dvTEvBTh6Ey9Zchkcm95Or0UlmmUGk+zy6OZQ8WxqDcmnVAo",
	"N5yIDUtia/asCadsXtXwh86XYGuA+LfQ6f9SIsXqek3OUl8UKldPmeV2ZChr7aIm/Qq7MOOy1SuidHTE",
	"D5iCbzz6YazZ5d451/5SverpLFgGCgM/OrLegd+VCbsEAbBiHO3ilyOcREVSegS0mODfz5VUe7kIp//L",
	"GY7FB2mjGLMskumBgwSEdqvp0FPjHYh/A6rb70YzyVmS2E40Gyas0OXwxntVaGO1jLtfmqjCZ+YLbHJl",
	"svktTYPbwWweAH7wVeduMZwPJsMgnA0X0zsAQA76gUY47lx1gh/nwXTUHX6B16tZV03wvI4UnG7+w/Mo",
	"rMFGHGyhSa/EYKiUTfCurhZ4Kw4OeQx3UCTHyJbH82GPLLH6i3ql/PIOUocQ+x7C6YVBONFMSJxFtl04",
	"qIp+A6yTJ8lxiwiISvFRPA+taCIJPKcrBE1AVlTJMc2kgJAUkql9E1tFsvme0Lahewkr1HbWVbRYdrdg",
	"34IHbZiUrHZ0dTsfUCzcxfVLVOpjQPPQmmWxcnSuBgQKPMliG4B1Cz4IXZ3yqt7vDGo/q7vnBSx6QDIP",
	"SOYByTwg2eUBklmtDTr24jna0E5QnmAdTUedKyQZwg+MxihlMV1t1V6LTE56zSlN7qctGo3n4QxSiB+d",
	"jnZF3X4fsq3cjT8GJlPNoMz7Mrhb3EGymf2C7o/2AshYMxzcDVS7wehmPO0F4WLWvQ3C+ftpMHs/Hpp8",
	"MdNgFkw/6jQvPywG06BvHpUHsn4w+qlqavwxmE4H/SDcdaWpMBqH/aDX1dlkVDc33d58PA1n3Rvd9rAL",
	"afh/pyAUgPAR7XHahqr+jTc2Xiik05pjpTZaE4vcqrI5TVueIK2xPvWQghb+Hk4r2F4M0ITwnVXML6kL",
	"s1/blcJDAi50VJqn3gt0qtR+kuG5cXw+iMgHEXmK/ca30a5N2bBjnyWJvQx+sTLYS98XLX3P3q674CW/",
	"aV/kpt0joN+6f7ZopPNCIpp2ei1KaW+r+xvqP9gl28exvBRKWe3hPgDw0sjklJX7LNAIS0+uF+A2/yxp",
	"58XcSxFzXsT5+DBPp68m47xw83F8nmZfkWb7IDBfgE3g0Z9ebJSVB/t5weY1H4r7H7aF7dbUM3g1zbw4",
	"fin2gXb73RG94AyZJiTNLe715Ek9d7jFTfRbAdQx7nGeN1wYb1Bb0pJ3A9Kz/DCe/UXo3Cs/jGcowhkq",
	"V8I5kQSp9RhtVsfdwRm6QpofzLrXQ4Cany1mk2DUN/7BwSLoXHV63VEvGHauOrfd0W0Ll16rHc0JBDAp",
	"S/yCvcDLX7wmocuLeqFKvRf1pXpRa+I1qJNAP69Mvuykg9yV3thrkJdhLBV2QIkmWI84pRkVkmPJeAjZ",
	"/i0xTarSUJWhNceZLHO3kTK1ynHkEZNoRnTymExN/jgn0EXnSrdWdtkqaueMpIYRJwDPsmJcKzhFo43Y",
	"g478IVkLyzyWOxIpbrWftHDF+H9sKkJHuijnai1TRjWs2sfonmzdb37qfSDbr5Bu6jCjoZNBjEcBRADq",
	"vFPPR2RpmP+rDktiRzz/hJMHygqz+Fzvw6S1AqOC+TudHNAn+vOJ/nyivwtO9Hd2utaScTpT6n1xWPK+",
	"LvPGfNob4E0oYulSSbbWYHP2bQNf4ZyUL9UadmBVpnpLNeK5AtRnLD+eEock83LLyy0vt7zc8nLr68qt",
	"oxoP7755983fvg1ZTjKc0xDgguJlDCGpISfCko7Hg/a9NNC+Mr54v/PPOnj8mTYo2K6f2RJxnKEii+0W",
	"JsNgKctCBwppeWiF4h1DLk15n8FNq8UU64+1eRhY8fu+Z0tgziv4Bnj5Sk0/iOTR2+6Xoe5YMVd4kWVW",
	"yBWJxb2w+qzRtEhLwzlbIUHTIpE4I6wQyRaZBhG8f6WHnjEEg3oe1G1LCzwWloxsM43ASJ5yTgQgw7IV",
	"DA0N+kIDxFJhhJRVfcDi3kqquW4DmlNNQJs02xHO39u8BASEekpyl3je8VUjpg9TxHs7+W9iJ1/akyzO",
	"NxogWm89gqCa2idLoo8Zr+BfWK7XSUHQLckIEluhRMrr58y+U2mKWJpaITf3roqagO9MCyjFMUHLLdp/",
	"0dKl1TnN3d5+Pv/aMRumo01LK85SBBpYJJO4LTBnhWdr0bMJlgUnr8TrnbQmvxYEDpxYX22Ur9snHc7N",
	"Nnp1l4IlhSQox0p1Z2jcG6CqPloWWZxYCRkTTh9IHJInKsPI6qvznq43REikqiBVBYzaSQIfICTJjw/b",
	"nMiCZ472JpxFRCjZoyrpFl8Zhe61Fx4XmIObrjMdqHFAGgsfnkFdJNQGkgzlhtaevhdMXwd4rpWSLWFu",
	"JZaFsCml6jla0weSKSZdYwE2K8Ng9LE7BCk+CUZ9nb5htuj1gtmsc9UJptPxVD0Z3I662lmwN54GYX9x",
	"N2llmrCNvIEPBiX/8+zOszvP7jy7+1Owu98/kcMK04TEoT2+ukwDB/3IDZYowtC5UjbVmwX/Oqbtz/tR",
	"9gcuJ71h0J2Gs977oL8YakrscLJn8+50HvTD8SicLa41MHX9mX4r2H963e19uBkMh+XTcBr0gsHHljZ0",
	"RyaDW0hhUBpjtKednjX2mInadx51sCGyvXXuPZGEszUBSxdQYtC/QntXUO32uuqArVbWLW9sDkKdiLKo",
	"YibQRc35KmJpzjK1S803bw4H53nuS7A/2T3A37MkRq8kL8hrxHiF6v9qpbp/vb+Ya3PcbFZuNyf3NElC",
	"cx4PG0w7g77eYbujuyQ8NddU5aJ07LqERiQTdrs7lLwSr1FpIlISo6GtNLJYuhO8tPnm3hWJpG96WJI1",
	"41s0I1EB6S2hOmKZu5/2AlTNdXZ+yjP1xY5rhudl/tx313S35Yz/mWrCmtwJNAKGl/ugoJcVpP5DgRO1",
	"xNkKzQh/oBFpuzJ2JtrD3dWbLIQ1QPbgYkjVq7Zxy7QAJGV8G+aEh1FeuDvR9RDNUErWeLmVRKBciclq",
	"C/UmC79IT3rr/O6LtEZgB7JQawpnNhuEJ/EFKjmcCMIfqku20/aE44s3tqppGvX2vsAhpjxk1ZpTK6EQ",
	"pOV5F9qyqwBLLKMN0k//iViWaCVG+03slHeaIYzeE6leoQLlLC+0JyDjaMMOFlrt9kZiaUmjZ7IeWe6x",
	"TDok/Z7lvLc7aU8Xo1F55oaQY3PEvptoV6cy7FgfvW+6A/1jPrgLxos5HBD7QaieqwP8NAjuJvq16/F4",
	"Xj7vB93+cABHzPFiHo5vwrvgbjz9qXPVGXYXo977sGrYhDvXfoYma9JsEvQG3WEY/AhHz2kwG/wfPfLe",
	"eHQzuF1My79g7Oaj5uPJxLSmq1VjHX8KpuFiUmZxmgYfxx/2+r0xf80+hv1gWA0DDBFl693bIFTz0OY0",
	"ywkW1jy28BzsDHkZejEhWWycXm/AcFDRspVhJiac27RFfUumy9GK2i/HdHFInnKcxcRxvjBtAP8qa6IV",
	"JUksHG3SrHFENGsaEM1Oj4dm5wyHFbJxPKyQTQNihTw9ItVG+yGRXNijth5oXOBEXzqWSY4/N8ElKmXo",
	"OC0keyDcmktuWnHa3mSBVlzbIraofEP1ef/+3y6tEV4Nq9ecjkh2xyLu6Lzq0wv8Czt4pLadXOpxnpx/",
	"Rmx6fz/o7wf9/aC/H/wPuR/8qkZxpbY1WodbRWztQoe0j/pODSw7aOUpbgO+2nd+h2tHY4M3LbeHveI4",
	"W5PzLN6O+bGCV9l4TSlI7Mnvq5OzPyBf/gFZUYMKSaO2RxocyQIn+0ePgyv9B8LxmqBHQtebY63UuHRC",
	"7MJORX1WuBrJCF9vbfs5E0VqOyTOmcQJ0u+hsho4BdeHhGGTQKRBkRCfaPEFWEDtwpDkLZUnSXIHN3PI",
	"aPWC0/XeGThziBqj3lkW9nvG+YagBG9ZIetSDULDHjckQ1TC7zK4qPU4zkDFgs2yu2zSbz8rvuiqU2J3",
	"HoQUJjgXto0a6AKkXlM7sYzvbSVzSWZrMTOtvVqMBj/CTyFxmnvN+ALvsBwhz3NFP/JEItgzaEnWOPP0",
	"fAn0LERO7HbbebnDyypaQzx70+/CbQ6z+UWcOeEBZvAWqCjAHA5VcbgdrbfQ8iT5Bd3Ze2ofw1/mujhn",
	"GjSr/71moUVvXzgJ5QHynDmA4+XvNQWnO/uiGWgPz76HqXES7OT4OHl4XvVYKH8M3mb9zHNAYX0ecx/U",
	"YHQAh7M7EuGUZevdqchT+I+ncOOVnqfhy6Bh0z2ep+GLoKEjmZhWajwNX2i6seo+4csEaC3M3lP9pUpQ",
	"T8Q/gQj1RPwTyFBPxD9ZkjDLDWSxTKkME5rZLo1ZmuIs1pMrGdKVm2Jqftd7hoSu6TIhDqPmYwnQ+Zkt",
	"0ZJEip7lK+pjeGE1XrdYgmdfcLRoU6PHuX1Gi6yapJRmhfT3opfoUpQnOMucZvYq4BP8rTGXGktvJQlX",
	"C5SlAOR3sET3doUn+J/rpqzNJymeC8CObfgcoBADl1bS9bk9um+LQEOQF3tnZBxHGm4KnAvn+b39ETdG",
	"syKFiFc9OrV73Vcav8GknN/7Rd0off0Z+W2///e7T2oMsvG6/e91QNszh50m4+6cttx6El6qjVPNQbi2",
	"pk281fNcI2nJQhznrAYX7VawQI4EYI0ZE470TwcWUzeS9IEgXWrxNO7OZoPbUdAP+8FNdzFs5ynrGnAD",
	"5P8B5XQLJYKUjYSPjN/TbB3qjHCMb93hkiYQGZlX0O6VZyHFp0RiFwS+KtNasiXZSUKt6LwOGKkeVEdQ",
	"CpvnPmOP2etzstSYJkwWlxMI//ZVapoADKumQdhxd8EiYWl0OECm0MIW2vvz50mxpllT6ptQSGa/kND0",
	"2tVEpjEbHC+WOMwxF+7UB7UqDQ05HGShBf3WF7LKvaY0yzzVlPWgpJqxyCMXMLXuNjoBT21wo1yvl7BS",
	"5gVLAw+ECytoQ4o/M36qXaiEyjZs2E1KwzzZiqrU3ErWYiyqkruV59oLffas5jRkkM3jl3NSvPzKfIaX",
	"P0uGFy+3vdz2ctvL7cuT21asvDLu9Yfx7JlyZAcYfIKFNOH0XqkTFH5gNEYpi+lqq/ZceaLSHNOAMm7R",
	"Do3XAuFbFnX7Oizzbvwx6Fx1Jt3pfDAfjEfh3WA0uFvclQGdtYLuj/aC+eAuCIcDDfYbjG7G014QLmbd",
	"2yCcv58GMxPyORqH02AWTD8GJjp0MA365lFXNQQhrqOfqqbGH4PpdNAPwl1XmgqjcdgPet2fOlcd3c1N",
	"tzcfT8NZ90a3PezOBx+DL8/A92WptVY4siZ6Gar6N7rQ30/p2Y1ZsazDKJmR/BH3U2uOIxKWt/KHoNI4",
	"InOatjTGWZOr4SjihTW7Wm4z2DszR93hp+/ZUnRVc2RC+C6TlF9SF3bHbVcODwm40GmZPPVeIPYRBgNu",
	"WKavdO/4Q36S75aAp/3l7VwH7zV08xR7CXD6rk3ZsGOfJYm9DH6xMthL3xctfc/erjPw9/Kb9sVu2j0C",
	"+q37creu3Ser9Nf+csE8nwazaZHd0Wx/q3tnnz/YX8uas9gQzFDre++WdQmUstrFb3le21qeTH88mZyy",
	"cp8FGmHpyXXxsWhXz5N2Xsy9FDHnRdylUMmRdqoi0+gAdtrT6QJlnBduF+zJ74ifN2qkp9kl0uwRJ0kY",
	"JSy6b3kQdwm7TzhJ+gWHsIhK6HlzzUvIFXrLc0U9T6+XaF5rSMx0sJtNCt9QbjgR9vzTdzSbcMrmVQ2/",
	"JC5uC9utqWfwapp5cfxysWrap+wZObyMc05Imlvc7MmTeu5wi5votwKoY9zjPG+4MN5gz+szVh+DfhjP",
	"/iKQ3FChfqIIZ6hcCedEFKSOLG7Q0p0jdVN/MOte67Q1JnnOLntMlTinc9W57Y5un5mqyZ3QfuJz11/w",
	"5S9ek9DlRb1Qpd6L+lK9qDXxGtRJoJ9XJi+WhG1i+Xyka3OkqzpRtwl0VWq7I8AV1HGr/umV9D/eHu3D",
	"j334sQ8/9uHHPvzYhx972JDfVpkCnaeNNqXYnccL8QLbC2wvsL3A9gL7txLYIGeO+9aPnTIExynNqJAc",
	"S8bDhDwQi1tMV1UaqjK05jiroc0WBx5OFbIHk2gGpp0Ry9SCGOcEuuhc6dbKLluhYmAhWETBX8OGVlkr",
	"RREngIa7YlxfIBSNPlhO79Wdz+rR6Jw7oWcKLO/YTBQjIwdrX9ca5CPHXFK74J9UReehjraC4IT326VT",
	"ZDymmSKxcM6u2JEIUYEwqr2lKNig+gBap8Xsk8U0wpJAjm+4S1KrtN6sUgT028lWTT1dZ+VyVkM4JHvd",
	"Cmtl4O3nDiq1mbuYrHCRyDNWa1+/gRpWrQN+tXwTYFjbCYgmYKBqMZNY25ydDGI8CgBhZxjMg34rLnD2",
	"/F91WBKH9tcmnDxQVpjF53ofJq0Bhgk/YJoAlDPMnzjJaKywC92dHsJJxHgswBaPaaYfJTCdJbKwzuzj",
	"7slhoj0GnT7WUb2h9jcy1O6Buu9PuhOQfqRvSdgKRXlRos/v8N6fi8Nvo0F3TwKpo1MjjHRrKeXIrfGp",
	"zHehV7tOeaGqPv+rjsTPCRnt3PFnMTf1DSXjPHYkOIO1NcJ+7esyb8ynvQHepE5SSyXZtLx/9rZpQuH+",
	"cq0hqhQjU72lGvFcAeptV80Tqc8EbYxXsMi88cobr7zxyhuvvPHKG6/8bdPvI7HdZ0/z3J80/UnTnzT9",
	"SdOfNH+Dk6bhsU0npCKPsSRhxmISpmJtu1mJORG27cZi0o1jflVlZSZC4mVCxQZM4GlaZDTSeyDHcnOW",
	"YqleJ9YLjQr3vaxiu9rIi3BJbYpvaSdOidwwfb2iKiqxAfnEARC+ykXYmyzapoB+khw3jVYPTk+V6lVN",
	"OFrRRDGKbK2EBDSh5JiQHNNMCoTVySlTzDi27jyCZWHN4tat7LlVnXMmv3wpxLa7iZ7Gx0+2CJv8as/p",
	"o2X6Odt3b5iQjvgrFpP3Zek5o3E3Nzq3KU6wsOluU3i+o/2SKLr3x59GSnz0p93BaDC6tavt6s2wsPI8",
	"xVIGfVi2Ja/dsVr9JnqVERIrjWGlj5GcMYmoQILolZ8SoTSk1/bORZGSEHJDN4ncStxCEunHDY0gPR0u",
	"JEux1EoP0o3tf3TQh/nwoQqXFyoEyZQtRCePJs+yXnV0nZX36JkjGm0w+tgdghK0GH0YjT9BVgr936A/",
	"DDpXne5wOO515xCwFkyn42nnqnM3+BH+vlnMF1OdgwIyXeh2YPV0rjq94Xihg9tmizu4jCsLxneTYTDX",
	"u2o0nofTYDYZj/r6wWT8KZgG/dAM46Y7GJZPB6PbcDFRA+gORvNg1B31dO/XY2jlh0Uw0yM1j3Q0HTyp",
	"GjDt9n8ade8GvbD2DfDKYDZb6BeG3dEIfplJCqdBNb6yFf0HjMk8N99YNj8aT+/apa8kdL2xqZjwXO3k",
	"ko7AqkS0IXGRgHmm4DkTPt3/CwEtECQqOJXbWbQhqSbUkmBOeLeQm91fN+XXfP9p3rk6GPI1VEHqDZJJ",
	"o8x1rjoC2lSDggq7QW6kzDUuzT3JHNIKRxERStFSVa46VBVsCI536u4/Oj++mQ0X07s3i1kwfTMffwhG",
	"uz5wTtUBopWWfbrxURd4xkHbagJptmL6kJ9JowiRFNNEbS+cEPH/wt5I428ilu4aV9Md3/XRcNhTajtP",
	"zKyIf7x9+/j4+E3tpbfaSWJPcZsMgKnqKVK7QfXOWYLAfNW56iQ0Ipm24ZkeuzmONgR99807a4cYir9h",
	"fP3WvCveDge9YDQL3nz3zbtvNjJNgGSEp2K8mhH+QCNSa2RN5aZYwoDNx70F8+TbZcKWb1OsDipv+4NZ",
	"b9gd3AWKb0sqE1KZ3KbBbI66k0GnZj/URW+++/s37/4O4356U5k8a5Zc0fnHv6rsvsbZ4ped1bk8xHT+",
	"+5erjrnqUfXMTz3MSEIc5N6zeBmrdip7aGc3kJqJ0xg1O9/9vVPZJjvvOpWFsfPu73qlVF13/vrNu2/+",
	"qhgklhvYcmaqzEDfxhSv38KVg+YQDNzJKMsGcTkpH9+9+9u3t0T2KV53QP/KmSKaqv7du3flijSHI2Ov",
	"UU28/Wz0Ttid2F90+Ysuf9HlL7r8RZe/6Pr6F13q/EeFpJFFntTKDhkTXpNMho5rk50xAaohueEExy1V",
	"bt3yrwUpSCjov0lT8ySDejFihVwztSOnkx7i5NeCCCkQzRDOkGqbZzhBnEi+hSucc0aiB+/61DmTOCl1",
	"ffXB2pJmvrjy/l5uEU6S50zHchXqNo/7vsbR/Uodf8zZTp1uKpMeL7Jsb0/UTlrLVbg075I43BBZpflx",
	"TfSGSMLZmmSEFQJ9ZkvFi3OWqZNUeYGhvosV6w0q21b0EDSLCEqwkFrx1ZVbf3ptmKeGqMrbDkU8YyjR",
	"NkqIXgbNBrTlAVkgFal6WdSHwIk+FJ7TuXrxuOfgiUQFGOclTYla9MBwSjseW+kOncM6cxAmaePZY2DZ",
	"mnzNYai1fAzQRrB7CHuL4VzaOO51q/GIInVxh995PDHJ5aZpfnbciiR0TZcJ2P94kek9lHOmDq0kRnEB",
	"VxqKc/3mYw0lt0QDzDcEiWIpCBi0+qo20jTeYAlmoOUxE8RSkjQ3QUHl4zOH1EDObJ/lfP3pci99PTbJ",
	"t/bxzaqZqn/HF8+VezzkiUrXBYkAs6O5P7B0Xs0HUq2Q2DYr+zrHcqWYjxIEoeN6fUqwavyQRDhJ2KP5",
	"xLN4ftmdJOJZvS0JUq8eXe4392gHESx7S/ETTYu06mZHS9k68e5ype+JRY4jl5ZV9ifh+lHVQZDJueU1",
	"agYSW+tx7sZJFqt507XaOlZIEkYbnK2J5Zg42wpJUnOrUdZq0bBNNV6uQOL+VkrIeVsfRgJ7uqn/HTOC",
	"kRiOtCf/bSzpGaOw8+svHolmVhscIwzki0i1a1EhgL1WV+L1u+V2w9enisRm0T6gYW5uVPUm3n3Mcrs3",
	"fJysGadyk54/hHYS+msMxi3rdoM5Q96dOZjnL3ngPCfPgDFdrQjk+Qc9SyRMCsN11Zgcco9miEqhR0Wl",
	"sd0+Y2TtqPisMbamYm00rcj4NUbjnpvHDck0n9Csxe0D13wsQRuc5yQjMXq1GA1+hLEKidP8tb+3PLkq",
	"fncPg3gZh+dYboynilYSwTLQv+5r5o850QpBS61pTaRaG2wV422YYEmyyCKZhrpA9f3tu3fvUISTRJTe",
	"DvUmXr1GYitU8eGZ7QphgVKCRcFJjLAsr/QUPwEJVeTtRmw0WElEKEXDBvnMlqUmo6PTHwknaI3VEvH7",
	"4kXsCyUyw0jpMQmJT2odZUUjMysmeYbc1B2yNE+IbNNjWfOZYhq6W2Ha5ut0NRQXWqeD+1vEuCbtzkxL",
	"hSiefUiG8RgVpbWSZ47HIA1Z5eRPwR6iN2rY1mEE+i9tr6f6N/W+ev+lR3nbg8oXTLWARMOtOitrPrO7",
	"HHMpwhxH97bO/g/hTO1SliVbuASo7i4QzaKkiNtKE7MmQp7bbkQmZsXs9bB31+6s3zropHaGqr19lkg0",
	"0jW03/jd6VJ92QcBCK7bM/UgtHmrHjZR9t3upH0YOKK6OBj0lZmdNtHVdZKFy224YULa0fzr5EBltZbk",
	"U6px1fLZpIQWOIkIfQAinpE04D+Klpz86rB/1UJn4HoPfDNSHBOvB70APaika3gqMCrGEivRpymdMy4r",
	"MeXp/ALobHjwCa7FhEQr2MhwWQ0qX4w4SZk0NqW44MQc0l4p5vnazaVL7myYzYGjwgPhMBArU+nqUmMI",
	"yUkmS4tWKeVpVkZE+OV2ecvtbLnbQnlqums/aHhn/VRzSWtmLbV0QGM7x8DecMF+Z259shMDwIc9G237",
	"jHuvmLM8b1booe+yXquV8bW0GKMFnxrbOcoypF518IfaBf5p7tBiGv54Jayawh2h95Z8fRXuzc3VPitt",
	"pcwZYWB3EwVCGc6/3Gp3UYgsOsHmDYKfZ/OezX8Jm/89t/3ZUeT6lbApUPSVcYh//QweUTZuRrbjDV+2",
	"38vLIuMS5bitPuFFo+b20GOmpWvAfvd2CT63OWOtGDeOgc+6GD/o2CXAKwMfzrbH112HY3qelexwKGd6",
	"yamJwM9xXXRxiuPhuJYFDKqMWmxYHPgUkdoNJSc8TGlWyMZrqlpXpHRxFCgnHJl3n9N1wyUtL742Ydqt",
	"E0f6eetEfJ1+z3Ede7bHmAEuNneSjoX31d24fjPfpzLsz+IKnrDonsSIZaiq1M5S/Ds61Km+eB6FUdbQ",
	"kxKvZ/iZqTZhefzmXnPW4IlyNVeONOtm/6y9ayeaneX4RvgD4SfCEWrISToSoAxIqCIoz4k+8MBo50OZ",
	"1m6FjlWm/z6KE44pXmcM7qk4EUUixQHgug8R9SGiPkTUh4j6EFEfIupDRH2IqA8R9SGiPkTUh4j6EFEf",
	"IupDRH2IqA8R9SGiPkTUh4j6EFEfIupDRL1rsA8R9SGiPkTUh4j6EFEfIupDRH2IqA8R9SGiPkTU60E+",
	"RNTT2YeI+hBRHzvkQ0R9iKgPEfUhop7NezbvQ0R9iKgPEfUhoj5E1IeI+hBRHyLqQ0R9iOhLCBFVX1Wk",
	"Kebbzj86ayLRrhJk2jd5VnXE1S+q+kH+0s9s+VYt9MgkBs+ZaMxjOmFCfs+W3fIV/UVEyGsWb78gTnVD",
	"5Ge2PKbNe6K6O6CsY7WYaDvLmU4X7BLqx7uM+qpXy1oxbYXagyI0Bkibt4gaXi3OT53bcs5WVPss4jRP",
	"9AaWhD/gROwfCI77jVOahRFLU2L9Er6kkmO+RaaKvtZYbhG8SIXkWDJubVmTjLJMO/Tar72GLFIaN4sJ",
	"SvE9OO9tdu6TaNdImy5yZhMUE8bhzCuUVNu9og6WK6rYDMSGsJaBV3z9YJumdZFCwJHx2tGFZ12m6R92",
	"cqsiRLOYPOnTsjr6RXRF3VOzxDLahCuCZcFtUvnGlKCSQYBeA2+Zwf9FlMn4jxsna5o5pFqfrJTk2tRp",
	"V+rOn9kSqWWb6DnS36BktVIr/RXK5Rs7lgUXMlwWq5VtKq5VKdKl+yvUynpMgG0YsUyxEWpXvcrVWa5X",
	"7YeHViRWAoPEVZxuWgiJNvgBPHjgf4wEXQI3BG+1yslDLQnZMCJhixvXJcfdQ8AhzuB4ZN+Kz2CuxvRh",
	"aaqcKtsYWZpiJEiO9cgUw1U772DqOKn2vKMLiWlmo293KVhSSIJyrIQZQ+PeAFX10bLI4oQ0tmm1Gu23",
	"AmZWawt0XbBCuBe8ooT5MoF2LwAXE9Y9HTFOwn1WeqysqWKc0H+rpaZ2ammPanNpkhfhkjocvu6I3DDD",
	"dqnxW8fiHkRIqSHFqDdZ2DfPrunQpLc/YvHqMbTfmyzKPuoiiWTqtP+vTm+yCK8Ho344H4fz99Og2591",
	"rvae9sbT4PDZbNz7EMwPnw7747u9Z5Byv/b3tDv6UP/7rjvZ/3O2VzzsH74w7B+8oh7ASx+D6fV4ttfb",
	"eBSYTwonwRS+o6b7uoWxmt4GHWyqdVBNH1RVRBxna4J+Lt69+2uUfwv/k3+9yb/75V//yP/6i4OOAgw+",
	"ivZNhya1EHbCerlF6vQIK6b1WjQdWfWBGUlpxBKWoZjAGbfGQObTYPZf/8PggJT/qeWk9ky2Rhv2iFKc",
	"bfUYxYYVSayE3m4Vq0UI493JfNUoerULCgfvuEKYymtOxNt1XljBIiKuuMXSsVfLrQztCFPXqN2HnlEu",
	"QA8D5qFDT+0YGtuQrcKUZVazDcR2matC881bMNSVQa0xBndveL+c0Vfkm/U36N2bb99dffe/Xzf0+kjI",
	"/Rd0ql7f6/Pdm79e/T/WDps4i42TfBoM++HdYLSYq10If70fL6bl7373p3B8E96NR/P35bO9P0yFT0Hw",
	"odU23bCCP2cm1HuH0/73q+/+ap2EhGbEAnRkWziBtpvJDRWIZJIrpR2taNI+gNB2gJlBiNmz27Upci7z",
	"8ump029a1uzf31ln79lbxLo3/n717Xd2zKBmKT4392U19vDq/4dSgjNgaDSurNilFU53/Bq9Kb8Y1kx9",
	"35sR1jdlOxwhzfPCR8bVgTeMKSeRZLaYxU+6CqqqKJZUCAKjbbAmxATH5bI9jjURJrqqCr5WmlOKtyaW",
	"0XIQa3EWiUmCt+GSsUbTX3lngFdKZVf9VvTWncOYQGOrzk6cqFaNSRdLKlbbUqc9Oge38SEhOcliu1wf",
	"g7s/WEJhIHCmSAmRKCJcKago4lQSTjFakpXSBmFLlmeA0uB8TA+qfi8Lh2ERb1lx8r0wT3Dmil6aqDId",
	"Cb2/yh83JEP1ZioRLBA06I/ZLczbv/Mxm2SuO4PgKQdrMNzQuMwmLXYryR4oZ5n9XBrsCtED5hQvEyLM",
	"ZZOa4X3m097CRZ50tEOoT2StD7CaHegNibcoY1KNROmK53cvKriinBNQTjv/kLwgFmVGPVazqWi5c0dI",
	"taGb5ayVhkKeJMdNR38jASvNF0yhK5ooLpOt1RqCJlDt6A9neJIpssRnaG3fsyVauTS3D4PhMByMPnaH",
	"g37YDybBqB+Mej91rjqjcegufN+dhbN5dx6E/cE06M3HU/V0Hszmg9FteN3tfbgZDIedq87tNJjBkUw9",
	"D0Y342kv6Juq4Wj8KRyPhurVWTDqh9+Pr8Ng9HEwHY/ugtFcPZ7AGe778XXnqjOZBjfBVOmZg7vFXTga",
	"94OwN15ARfUqDPf9YgpjmX0YTEJ12Ahn86nqvNuDuoPRrSodXA/Vw95wMZsH03Ax6auPMYN5H8yD6fg2",
	"GAXjxcx0HvzY7c3DeXf2QfcZToMfFsFsDl+jC9Xp87isnJRP78fDQA+6Nj/z8SScTAfj6WD+k+mp2+tN",
	"F+bLwt4w6E6hnb2Z7A9m3eshPFdf/qk7C6eL0Uh/nHpiGpkP7oJwGswCNUe96Xi09zV3wd14+tPeaBcz",
	"aD646S6G83LOjp5PutP5YD4Yj45KfhjPjp596n0I1LSWK0i1d9e9HQXzQU+RtWws7M5mg9sRjKOcorA7",
	"nwd3Ez24We990F8A4fYez4PJ3e00DEZ6TtrsT8CjtJqlbgGpctAvjdfgBAhMiD1mokn70ndLoQMIc5HR",
	"XwvFSMFmUIkkuLzSSg7oFBWIWdn/Ec5ZO+G1YYnl496zJEavFId7jRivgPxeAbN7vf9hNelM05TEFNuU",
	"g8EKAR8FBwjFtioIDGBXimnv4DFqLskgxHLCKYt31gFr52pObYRSfA2shi1m454mSVheF60wTRo+RNUF",
	"1Y5lhitjmhScWAcHDZvb2xB04TZqsFEiK2Fe3lKpiSmvggVdZzjxatrlqWl7NG80wnKSYHOCgasIIKlV",
	"Dl935733pQCYTrs/gajpXHVuFsNhqDjcrJRO8ETXvAn6wbQLvBOY+CJQ0stIwPFiDlYXYPJaoJdi7/vx",
	"tWLTSjBMP+r3dYM1U6oRFqrep+5UiZZwpnh3G+66N0NmIR+bN+B5tfbhxILznDMcbcAiUKm6YAT4ufPt",
	"u587imv93FnMpt/+3HFYbVwOSUNd8kq83rOnNjD0FNPEFR6AaYLIAyCWbHPVqJWqwe1AychgpPjUTXcw",
	"hFkvKaWk8399++7d/yx//+/dz/+1+/l3+Dmbd2+DcLyY760QRR6LhtaGSPB1DW7AkpXuy4iouoqXN9/s",
	"GY+mMMpt9zXH8SJ7tu3WzlXQheMoUfWh+PYZNzZpJMIEL4llmd4ViaRveliSNeNbNCNRwancIqiuZETT",
	"AiIp41v3XdC1uQBKcQ6HgBTnb1Ms7tUMnm7PGbnivmDSDdiWqrmvMbcu+qrF3K8Mx73ucI85zMbTeaWQ",
	"t1tseuQ54fBtx4OmGRBO1wNfU7LGy60k2rd172bMC8XLcxGoERjcRzyF/8QU/tK7xMNLxCLaWNfFb3+n",
	"mOpVGS4Z5rFoWL7XUAFWKgiXM8WW6cYhGc3W+DLJWOuixTY86Kv8rvP6cknhso9zpbBpVrDonkj9FUAY",
	"my8tVIFxQ5UzZ8uew0AdKV3RTxmRj4zb7up1AaxH7XehQbJIbm2GRqTJsUC9m3PKQMfQaKEtv8hOi1FF",
	"A+OlcHAbBrr1t2++/fs//mbdIBnoDg27fne6NVrGBku4FcFRRITQe/UWWHqLr2A5ycLUunLHOcmQKtpt",
	"bSFjVkjg6ELGhHO4HLUesLqTidbC59PFqNedt/MHYQ+ERyxNbYEh46psD/bzWHqoRkSxVO8uHUbo45dy",
	"zCW13xtNyiKEhTpcldYjpxqas0fC6ydVlw3chmTDidXpr73XmW4BTluFBINQkx9aufade6RawHtbxSsM",
	"l2cn0e7ptltLXaD3sTmC4yiqvODNi7sUNJbTyjzURm1zbglGwfT2J3VYWczmU/VkFMw/jafq/AKWlDa7",
	"/VdmjSHBieLFbIVmhD/QiLTddvoC28GSdWGJHKTmQdsED+6Sa2sKqhZW12tJeEozItDjhsBVdv12f2nw",
	"iQrHWi1347nXc5URpXS0bH8lV3UpHqmMNqSVtaCq67f6xW11TgThDw4nnBHWMca1Ssafxb5rIKwMgjrE",
	"iaiOB8ypdvXdWaZQKtatwzo4EQ9hmlNXbzvlxgwrBp/tIis7g/f+CfoOnDrMBbWaSQiAUmpgDMogSnGG",
	"13pqd5e4bcYIZylbHJJlwN045krrAhh9HbX4jd8wlwgfwa1eWhwy0oDDOYjASptekjJz05U6I8P52FP2",
	"EilrM29OCH9jIAPAdRw25lUtRs+T8hIRxLEtRWapmYDXHVtpeEBB1inJZG1vIk/Ry6Poyu5GWfJdz3Jf",
	"qmU6YdG9Ncr4nsRvaPbGWJdxXT3ypLw8UmYOk8FOEWc50TEQfi9eJAGVmtMmC5Mn30WC5QrhFo+cCEhy",
	"Dh+rJGld3ZlvqEB4tSKRFEg84jyn2fqfO3LvDMLkKSIkNpgPlB83W01qqiYuofck2VbR3flmK2iEk/LC",
	"UOJ7xRA4S1VzqV9VF7iqhMQ28XyoSUM1iyrtSXppJLUjTwH2ifVStQ4w8k9tKVNTo6GOdi7PgKVnoHio",
	"QDnLC+1AyTjasAOK1IIA9YpxxEjNdKleZRDDwnKWsPX27RK0Rr+4Ls6cLEhCs+IphGE+2UJjg6GqgMoK",
	"tkWxwZxYXeAfq+sRCN7baGiM0msdpo9VAYFX6iuU4EoS20VUxiCUbv+K97lBQ4JKEq5wJK2p96kkb6q7",
	"z8pFwFRvR8eaX4XdO6TuVvEMNxeR4+w+fEaQWek1kXO1M9+SnCZsbfiFAPhtItFyi2aT7uiDuRc878pJ",
	"SJzFmMch4dw2vRODbVLzI7CuqrIZmuWFbGxmF6rtboUV8lQzrJDOdsDj4qRLRkvw4crPw+Fyc+TooTje",
	"A7sniGXay0O/eGZvdkv46c7gvTP7si/6032194za9aU323N6M2+264+kOeOYb8OYivsWfl8yzZGqam6I",
	"qkvc8xzADOTjGRg6+o1zvMEMKmTDIpnrGjB2uDI5j1tB8hcN7OlUTffRb7NC+vvnS1QYgJTGfdC99j0x",
	"XwYxOREQ42DpFot7Ndng8VtGN2iUDPpArEEp0NqKk18tralWdihOLdpRvMiKH+pyktn3e9ax9Ae+zA+E",
	"b10uRFWndqb+pb26gB6rbl1C7Es7rkScu2s7MNaXdmyAs87PbdAqAvgRUxniJHG5UlUxpqpiLYs8YGNq",
	"bBScJAb4AKxdGgLFyiugsxXjxonKLcPKEFPoFNxmjSeVO2mEgxU8RvfEAVeTMCXdN5jjSBJO/63dY1R1",
	"yzw9ffvtcSs/fvutGt0j5rCrWV7GmR0dum7G00/daT/sDocQUD+DgPF57z381bnq3AymAC8Afwy75e82",
	"Z7Cnb78NU7ymURgxdk+toX9rGiFdCtO5P3DH94YS8zWRkAnSdigVMgM3KY4A2ENvEMVDa+/mjMv/enei",
	"AzsY7rw3AV+l5wJHHU6TlQkeIyh74GQPnOyBkz1wsgdO9sDJHjjZAyd74GQPnOyBkz1wsgdO9sDJHjjZ",
	"Ayd74GQPnOyBk/2NkQdO9sDJHjjZAyd74GQPnOyBkz1wsgdO9sDJHjjZAyd74GQPnOyBkz1wsgdO9hT2",
	"wMkeONkDJ3vgZA+c7IGTPXCyB072wMkeONkDJ3vgZA+c7IGTPXCyB072wMkeONmT0gMne4p64GRPVQ+c",
	"7IGTPXCyB0725PPAyR442QMne5J64GQPnOyBkz1wsgdO9sDJHjjZAyd74GQPnOyxdj1wsgdO9sDJHjjZ",
	"Ayd74GQPnPy1gZMtTwBR5wiwdgf9Wi/UjlY5K+Myv3v3TuOwgRgCV6Y8T4wa+faz0LqkiDYkxRYELnWA",
	"szpqqg1uSmurZv/tvXeO7wuztSJlqps5QIE+mnXHUXK2YVye20zoEv2zpODgBkk4jUyDYC6nK0paH/wL",
	"HlmP+4C2zFamXcbR44ZwYv58xMKY6GIiAX+mHdKVBWXbyltnFTTrObH8qjUN6grRq2Eq1najI1QSQq1G",
	"AHFIiRB4TeyBlTZPDz31qswIlmMowYSaFbz/3IEB0YPqCErRK7pC9xl7zOzAZg6SmSYMTvaJlWWP7jVN",
	"wJw0DcLut+bCThwOkCmERs2OXibk9Vl2GuPzfezsWEGfh0IyrujooFcNJL1yILdAKkoc5pgL95arVWlo",
	"yB5IpFvQb0FEkWVOHFPR2JSqcropq0lVNXM8rQb62NVtCbLsCooyACKu10t8EfOCpYEHwoVhxfsDS/Fn",
	"xk+1C5VQ2YY1vC/i7GQrqlJzK1mLsahK7lZaCVUL3QyKglPeVeVfKvFK3JETLOW0KCkbqoRJ+eDriJM2",
	"usjnfV2kVD40DOAKF4n0+ofXP7z+4fUPr394/cPrH17/+J30D/UBRZpivlV9ghBBGXlEBy88UrnRge1b",
	"iB2rwxIvicERM8jIkgHOAMR2/8tss19UR2/h99uHd9+8++Zv3779zJZvdY9AImOGUoSCPgdxuaI+vnv3",
	"t28nTMjv2VJLyI4JPhXymsXbL1CdfLotn27Lp9vy6ba8b6VPt+XTbfl0Wz7dlk+35dNt+XRbPt2WT7fl",
	"0235dFs+3ZZPt+XTbXk/Y59uy6fb8um2fLotn27Lp9vy6bZ8ui2fbsun2/Lptny6LZ9uy6fb8um2fLot",
	"7yLg0235dFs+3ZZPt+XTbfl0Wz7dlk+35dNt+XRbPt2WT7fl0235dFs+3ZZPt+UP0z7dlk+35dNt+XRb",
	"nqI+3Zanqk+35Unp0235dFuefD7dlk+35dNt+XRbPt2WT7flzck+3ZZPt+XTbfl0Wz7dlk+35dNteYXB",
	"p9vy6bZ8ui2fbsun2/Lptny6rT8o3RYEYVvWszHV7IMlO1C3PWqyR032qMkeNdmjJnvUZI+a7FGTPWqy",
	"R032qMkeNdmjJnvUZI+a7FGTPWqyR032qMn+usijJnvUZI+a7FGTPWqyR032qMkeNdmjJnvUZI+a7FGT",
	"PWqyR032qMkeU9ejJnsKe9Rkj5rsUZM9arJHTfaoyR412aMme9Rkj5rsUZM9arJHTfaoyR412aMmewhP",
	"j5rsSelRkz1FPWqyp6pHTfaoyR412aMme/J51GSPmuxRkz1JPWqyR032qMkeNdmjJnvUZI+a7FGTPWqy",
	"R032qMkeNdmjJnvUZI+a7FGTPWqyR03+GqjJR8epmrHn0Jv40DuxLP8nmhiDjjnZoRUlSaxWoTpp/+vd",
	"L0gfA9vgKf33f19Z7Ez1J9q9K2dlNOh3795p9DcQfuBAleeJUV7ffhZagxXRhqTYgvuljo1W91DFVkyp",
	"EzJ6753jW8psrRZQqps5AKE+orXjADvbMC7PbSZ0KRyzpODgfEk4jUyDYKSnK0pamxsKHlmNDIDxzFam",
	"XcbR44ZwYv58xMIYBmMiAfWmHb7W4RJ14QbMKkDYcxAEVGsaShZiZsNUrO2mTqgkhOJ+AB2REiHwmtjD",
	"OW3+JXrqVZkRZ8cAhgk1K3j/uQN5ogfVEZSiV3SF7jP2mNnh1BwkM00YdO4TK8seU2yagDlpGoTdW86F",
	"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",
	"///OwknsHXEHAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
