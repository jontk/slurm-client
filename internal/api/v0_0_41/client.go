// SPDX-FileCopyrightText: 2025 Jon Thor Kristinsson
// SPDX-License-Identifier: Apache-2.0
//
// This file was generated from SLURM OpenAPI specifications
// Original specifications: Copyright (C) SchedMD LLC, Apache-2.0
// Source: https://github.com/SchedMD/slurm
// Contact: sales@schedmd.com
//
// Package v0_0_41 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v0_0_41

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"gopkg.in/yaml.v2"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for V0041JobDescMsgCpuBindingFlags.
const (
	V0041JobDescMsgCpuBindingFlagsCPUBINDLDMAP            V0041JobDescMsgCpuBindingFlags = "CPU_BIND_LDMAP"
	V0041JobDescMsgCpuBindingFlagsCPUBINDLDMASK           V0041JobDescMsgCpuBindingFlags = "CPU_BIND_LDMASK"
	V0041JobDescMsgCpuBindingFlagsCPUBINDLDRANK           V0041JobDescMsgCpuBindingFlags = "CPU_BIND_LDRANK"
	V0041JobDescMsgCpuBindingFlagsCPUBINDMAP              V0041JobDescMsgCpuBindingFlags = "CPU_BIND_MAP"
	V0041JobDescMsgCpuBindingFlagsCPUBINDMASK             V0041JobDescMsgCpuBindingFlags = "CPU_BIND_MASK"
	V0041JobDescMsgCpuBindingFlagsCPUBINDNONE             V0041JobDescMsgCpuBindingFlags = "CPU_BIND_NONE"
	V0041JobDescMsgCpuBindingFlagsCPUBINDONETHREADPERCORE V0041JobDescMsgCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	V0041JobDescMsgCpuBindingFlagsCPUBINDRANK             V0041JobDescMsgCpuBindingFlags = "CPU_BIND_RANK"
	V0041JobDescMsgCpuBindingFlagsCPUBINDTOCORES          V0041JobDescMsgCpuBindingFlags = "CPU_BIND_TO_CORES"
	V0041JobDescMsgCpuBindingFlagsCPUBINDTOLDOMS          V0041JobDescMsgCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	V0041JobDescMsgCpuBindingFlagsCPUBINDTOSOCKETS        V0041JobDescMsgCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	V0041JobDescMsgCpuBindingFlagsCPUBINDTOTHREADS        V0041JobDescMsgCpuBindingFlags = "CPU_BIND_TO_THREADS"
	V0041JobDescMsgCpuBindingFlagsVERBOSE                 V0041JobDescMsgCpuBindingFlags = "VERBOSE"
)

// Defines values for V0041JobDescMsgCrontabFlags.
const (
	WILDDAYOFMONTH V0041JobDescMsgCrontabFlags = "WILD_DAY_OF_MONTH"
	WILDDAYOFWEEK  V0041JobDescMsgCrontabFlags = "WILD_DAY_OF_WEEK"
	WILDHOUR       V0041JobDescMsgCrontabFlags = "WILD_HOUR"
	WILDMINUTE     V0041JobDescMsgCrontabFlags = "WILD_MINUTE"
	WILDMONTH      V0041JobDescMsgCrontabFlags = "WILD_MONTH"
)

// Defines values for V0041JobDescMsgExclusive.
const (
	V0041JobDescMsgExclusiveFalse V0041JobDescMsgExclusive = "false"
	V0041JobDescMsgExclusiveMcs   V0041JobDescMsgExclusive = "mcs"
	V0041JobDescMsgExclusiveTopo  V0041JobDescMsgExclusive = "topo"
	V0041JobDescMsgExclusiveTrue  V0041JobDescMsgExclusive = "true"
	V0041JobDescMsgExclusiveUser  V0041JobDescMsgExclusive = "user"
)

// Defines values for V0041JobDescMsgFlags.
const (
	V0041JobDescMsgFlagsACCRUECOUNTCLEARED       V0041JobDescMsgFlags = "ACCRUE_COUNT_CLEARED"
	V0041JobDescMsgFlagsBACKFILLATTEMPTED        V0041JobDescMsgFlags = "BACKFILL_ATTEMPTED"
	V0041JobDescMsgFlagsCRONJOB                  V0041JobDescMsgFlags = "CRON_JOB"
	V0041JobDescMsgFlagsDEPENDENT                V0041JobDescMsgFlags = "DEPENDENT"
	V0041JobDescMsgFlagsEXACTCPUCOUNTREQUESTED   V0041JobDescMsgFlags = "EXACT_CPU_COUNT_REQUESTED"
	V0041JobDescMsgFlagsEXACTMEMORYREQUESTED     V0041JobDescMsgFlags = "EXACT_MEMORY_REQUESTED"
	V0041JobDescMsgFlagsEXACTTASKCOUNTREQUESTED  V0041JobDescMsgFlags = "EXACT_TASK_COUNT_REQUESTED"
	V0041JobDescMsgFlagsGRESBINDINGDISABLED      V0041JobDescMsgFlags = "GRES_BINDING_DISABLED"
	V0041JobDescMsgFlagsGRESBINDINGENFORCED      V0041JobDescMsgFlags = "GRES_BINDING_ENFORCED"
	V0041JobDescMsgFlagsHASSTATEDIRECTORY        V0041JobDescMsgFlags = "HAS_STATE_DIRECTORY"
	V0041JobDescMsgFlagsHETEROGENEOUSJOB         V0041JobDescMsgFlags = "HETEROGENEOUS_JOB"
	V0041JobDescMsgFlagsJOBACCRUETIMERESET       V0041JobDescMsgFlags = "JOB_ACCRUE_TIME_RESET"
	V0041JobDescMsgFlagsJOBKILLHURRY             V0041JobDescMsgFlags = "JOB_KILL_HURRY"
	V0041JobDescMsgFlagsJOBWASRUNNING            V0041JobDescMsgFlags = "JOB_WAS_RUNNING"
	V0041JobDescMsgFlagsKILLINVALIDDEPENDENCY    V0041JobDescMsgFlags = "KILL_INVALID_DEPENDENCY"
	V0041JobDescMsgFlagsMAGNETIC                 V0041JobDescMsgFlags = "MAGNETIC"
	V0041JobDescMsgFlagsNOKILLINVALIDDEPENDENCY  V0041JobDescMsgFlags = "NO_KILL_INVALID_DEPENDENCY"
	V0041JobDescMsgFlagsPARTITIONASSIGNED        V0041JobDescMsgFlags = "PARTITION_ASSIGNED"
	V0041JobDescMsgFlagsPREFERMINIMUMNODECOUNT   V0041JobDescMsgFlags = "PREFER_MINIMUM_NODE_COUNT"
	V0041JobDescMsgFlagsSCHEDULINGATTEMPTED      V0041JobDescMsgFlags = "SCHEDULING_ATTEMPTED"
	V0041JobDescMsgFlagsSENDJOBENVIRONMENT       V0041JobDescMsgFlags = "SEND_JOB_ENVIRONMENT"
	V0041JobDescMsgFlagsSIBLINGCLUSTERUPDATEONLY V0041JobDescMsgFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	V0041JobDescMsgFlagsSKIPTRESSTRINGACCOUNTING V0041JobDescMsgFlags = "SKIP_TRES_STRING_ACCOUNTING"
	V0041JobDescMsgFlagsSPREADJOB                V0041JobDescMsgFlags = "SPREAD_JOB"
	V0041JobDescMsgFlagsSTEPMGRENABLED           V0041JobDescMsgFlags = "STEPMGR_ENABLED"
	V0041JobDescMsgFlagsTESTINGBACKFILL          V0041JobDescMsgFlags = "TESTING_BACKFILL"
	V0041JobDescMsgFlagsTESTINGWHOLENODEBACKFILL V0041JobDescMsgFlags = "TESTING_WHOLE_NODE_BACKFILL"
	V0041JobDescMsgFlagsTESTNOWONLY              V0041JobDescMsgFlags = "TEST_NOW_ONLY"
	V0041JobDescMsgFlagsTOPPRIORITYJOB           V0041JobDescMsgFlags = "TOP_PRIORITY_JOB"
	V0041JobDescMsgFlagsUSINGDEFAULTACCOUNT      V0041JobDescMsgFlags = "USING_DEFAULT_ACCOUNT"
	V0041JobDescMsgFlagsUSINGDEFAULTPARTITION    V0041JobDescMsgFlags = "USING_DEFAULT_PARTITION"
	V0041JobDescMsgFlagsUSINGDEFAULTQOS          V0041JobDescMsgFlags = "USING_DEFAULT_QOS"
	V0041JobDescMsgFlagsUSINGDEFAULTWCKEY        V0041JobDescMsgFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for V0041JobDescMsgKillWarningFlags.
const (
	V0041JobDescMsgKillWarningFlagsARRAYTASK         V0041JobDescMsgKillWarningFlags = "ARRAY_TASK"
	V0041JobDescMsgKillWarningFlagsBATCHJOB          V0041JobDescMsgKillWarningFlags = "BATCH_JOB"
	V0041JobDescMsgKillWarningFlagsCRONJOBS          V0041JobDescMsgKillWarningFlags = "CRON_JOBS"
	V0041JobDescMsgKillWarningFlagsFEDERATIONREQUEUE V0041JobDescMsgKillWarningFlags = "FEDERATION_REQUEUE"
	V0041JobDescMsgKillWarningFlagsFULLJOB           V0041JobDescMsgKillWarningFlags = "FULL_JOB"
	V0041JobDescMsgKillWarningFlagsFULLSTEPSONLY     V0041JobDescMsgKillWarningFlags = "FULL_STEPS_ONLY"
	V0041JobDescMsgKillWarningFlagsHURRY             V0041JobDescMsgKillWarningFlags = "HURRY"
	V0041JobDescMsgKillWarningFlagsNOSIBLINGJOBS     V0041JobDescMsgKillWarningFlags = "NO_SIBLING_JOBS"
	V0041JobDescMsgKillWarningFlagsOUTOFMEMORY       V0041JobDescMsgKillWarningFlags = "OUT_OF_MEMORY"
	V0041JobDescMsgKillWarningFlagsRESERVATIONJOB    V0041JobDescMsgKillWarningFlags = "RESERVATION_JOB"
	V0041JobDescMsgKillWarningFlagsVERBOSE           V0041JobDescMsgKillWarningFlags = "VERBOSE"
	V0041JobDescMsgKillWarningFlagsWARNINGSENT       V0041JobDescMsgKillWarningFlags = "WARNING_SENT"
)

// Defines values for V0041JobDescMsgMailType.
const (
	V0041JobDescMsgMailTypeARRAYTASKS        V0041JobDescMsgMailType = "ARRAY_TASKS"
	V0041JobDescMsgMailTypeBEGIN             V0041JobDescMsgMailType = "BEGIN"
	V0041JobDescMsgMailTypeEND               V0041JobDescMsgMailType = "END"
	V0041JobDescMsgMailTypeFAIL              V0041JobDescMsgMailType = "FAIL"
	V0041JobDescMsgMailTypeINVALIDDEPENDENCY V0041JobDescMsgMailType = "INVALID_DEPENDENCY"
	V0041JobDescMsgMailTypeREQUEUE           V0041JobDescMsgMailType = "REQUEUE"
	V0041JobDescMsgMailTypeSTAGEOUT          V0041JobDescMsgMailType = "STAGE_OUT"
	V0041JobDescMsgMailTypeTIME100           V0041JobDescMsgMailType = "TIME=100%"
	V0041JobDescMsgMailTypeTIME50            V0041JobDescMsgMailType = "TIME=50%"
	V0041JobDescMsgMailTypeTIME80            V0041JobDescMsgMailType = "TIME=80%"
	V0041JobDescMsgMailTypeTIME90            V0041JobDescMsgMailType = "TIME=90%"
)

// Defines values for V0041JobDescMsgMemoryBindingType.
const (
	V0041JobDescMsgMemoryBindingTypeLOCAL   V0041JobDescMsgMemoryBindingType = "LOCAL"
	V0041JobDescMsgMemoryBindingTypeMAP     V0041JobDescMsgMemoryBindingType = "MAP"
	V0041JobDescMsgMemoryBindingTypeMASK    V0041JobDescMsgMemoryBindingType = "MASK"
	V0041JobDescMsgMemoryBindingTypeNONE    V0041JobDescMsgMemoryBindingType = "NONE"
	V0041JobDescMsgMemoryBindingTypePREFER  V0041JobDescMsgMemoryBindingType = "PREFER"
	V0041JobDescMsgMemoryBindingTypeRANK    V0041JobDescMsgMemoryBindingType = "RANK"
	V0041JobDescMsgMemoryBindingTypeSORT    V0041JobDescMsgMemoryBindingType = "SORT"
	V0041JobDescMsgMemoryBindingTypeVERBOSE V0041JobDescMsgMemoryBindingType = "VERBOSE"
)

// Defines values for V0041JobDescMsgOpenMode.
const (
	APPEND   V0041JobDescMsgOpenMode = "APPEND"
	TRUNCATE V0041JobDescMsgOpenMode = "TRUNCATE"
)

// Defines values for V0041JobDescMsgProfile.
const (
	V0041JobDescMsgProfileENERGY  V0041JobDescMsgProfile = "ENERGY"
	V0041JobDescMsgProfileLUSTRE  V0041JobDescMsgProfile = "LUSTRE"
	V0041JobDescMsgProfileNETWORK V0041JobDescMsgProfile = "NETWORK"
	V0041JobDescMsgProfileNONE    V0041JobDescMsgProfile = "NONE"
	V0041JobDescMsgProfileNOTSET  V0041JobDescMsgProfile = "NOT_SET"
	V0041JobDescMsgProfileTASK    V0041JobDescMsgProfile = "TASK"
)

// Defines values for V0041JobDescMsgShared.
const (
	V0041JobDescMsgSharedMcs           V0041JobDescMsgShared = "mcs"
	V0041JobDescMsgSharedNone          V0041JobDescMsgShared = "none"
	V0041JobDescMsgSharedOversubscribe V0041JobDescMsgShared = "oversubscribe"
	V0041JobDescMsgSharedTopo          V0041JobDescMsgShared = "topo"
	V0041JobDescMsgSharedUser          V0041JobDescMsgShared = "user"
)

// Defines values for V0041JobDescMsgX11.
const (
	BATCHNODE       V0041JobDescMsgX11 = "BATCH_NODE"
	FIRSTNODE       V0041JobDescMsgX11 = "FIRST_NODE"
	FORWARDALLNODES V0041JobDescMsgX11 = "FORWARD_ALL_NODES"
	LASTNODE        V0041JobDescMsgX11 = "LAST_NODE"
)

// Defines values for V0041KillJobsMsgFlags.
const (
	V0041KillJobsMsgFlagsARRAYTASK         V0041KillJobsMsgFlags = "ARRAY_TASK"
	V0041KillJobsMsgFlagsBATCHJOB          V0041KillJobsMsgFlags = "BATCH_JOB"
	V0041KillJobsMsgFlagsCRONJOBS          V0041KillJobsMsgFlags = "CRON_JOBS"
	V0041KillJobsMsgFlagsFEDERATIONREQUEUE V0041KillJobsMsgFlags = "FEDERATION_REQUEUE"
	V0041KillJobsMsgFlagsFULLJOB           V0041KillJobsMsgFlags = "FULL_JOB"
	V0041KillJobsMsgFlagsFULLSTEPSONLY     V0041KillJobsMsgFlags = "FULL_STEPS_ONLY"
	V0041KillJobsMsgFlagsHURRY             V0041KillJobsMsgFlags = "HURRY"
	V0041KillJobsMsgFlagsNOSIBLINGJOBS     V0041KillJobsMsgFlags = "NO_SIBLING_JOBS"
	V0041KillJobsMsgFlagsOUTOFMEMORY       V0041KillJobsMsgFlags = "OUT_OF_MEMORY"
	V0041KillJobsMsgFlagsRESERVATIONJOB    V0041KillJobsMsgFlags = "RESERVATION_JOB"
	V0041KillJobsMsgFlagsVERBOSE           V0041KillJobsMsgFlags = "VERBOSE"
	V0041KillJobsMsgFlagsWARNINGSENT       V0041KillJobsMsgFlags = "WARNING_SENT"
)

// Defines values for V0041KillJobsMsgJobState.
const (
	V0041KillJobsMsgJobStateBOOTFAIL     V0041KillJobsMsgJobState = "BOOT_FAIL"
	V0041KillJobsMsgJobStateCANCELLED    V0041KillJobsMsgJobState = "CANCELLED"
	V0041KillJobsMsgJobStateCOMPLETED    V0041KillJobsMsgJobState = "COMPLETED"
	V0041KillJobsMsgJobStateCOMPLETING   V0041KillJobsMsgJobState = "COMPLETING"
	V0041KillJobsMsgJobStateCONFIGURING  V0041KillJobsMsgJobState = "CONFIGURING"
	V0041KillJobsMsgJobStateDEADLINE     V0041KillJobsMsgJobState = "DEADLINE"
	V0041KillJobsMsgJobStateFAILED       V0041KillJobsMsgJobState = "FAILED"
	V0041KillJobsMsgJobStateLAUNCHFAILED V0041KillJobsMsgJobState = "LAUNCH_FAILED"
	V0041KillJobsMsgJobStateNODEFAIL     V0041KillJobsMsgJobState = "NODE_FAIL"
	V0041KillJobsMsgJobStateOUTOFMEMORY  V0041KillJobsMsgJobState = "OUT_OF_MEMORY"
	V0041KillJobsMsgJobStatePENDING      V0041KillJobsMsgJobState = "PENDING"
	V0041KillJobsMsgJobStatePOWERUPNODE  V0041KillJobsMsgJobState = "POWER_UP_NODE"
	V0041KillJobsMsgJobStatePREEMPTED    V0041KillJobsMsgJobState = "PREEMPTED"
	V0041KillJobsMsgJobStateRECONFIGFAIL V0041KillJobsMsgJobState = "RECONFIG_FAIL"
	V0041KillJobsMsgJobStateREQUEUED     V0041KillJobsMsgJobState = "REQUEUED"
	V0041KillJobsMsgJobStateREQUEUEFED   V0041KillJobsMsgJobState = "REQUEUE_FED"
	V0041KillJobsMsgJobStateREQUEUEHOLD  V0041KillJobsMsgJobState = "REQUEUE_HOLD"
	V0041KillJobsMsgJobStateRESIZING     V0041KillJobsMsgJobState = "RESIZING"
	V0041KillJobsMsgJobStateRESVDELHOLD  V0041KillJobsMsgJobState = "RESV_DEL_HOLD"
	V0041KillJobsMsgJobStateREVOKED      V0041KillJobsMsgJobState = "REVOKED"
	V0041KillJobsMsgJobStateRUNNING      V0041KillJobsMsgJobState = "RUNNING"
	V0041KillJobsMsgJobStateSIGNALING    V0041KillJobsMsgJobState = "SIGNALING"
	V0041KillJobsMsgJobStateSPECIALEXIT  V0041KillJobsMsgJobState = "SPECIAL_EXIT"
	V0041KillJobsMsgJobStateSTAGEOUT     V0041KillJobsMsgJobState = "STAGE_OUT"
	V0041KillJobsMsgJobStateSTOPPED      V0041KillJobsMsgJobState = "STOPPED"
	V0041KillJobsMsgJobStateSUSPENDED    V0041KillJobsMsgJobState = "SUSPENDED"
	V0041KillJobsMsgJobStateTIMEOUT      V0041KillJobsMsgJobState = "TIMEOUT"
)

// Defines values for V0041OpenapiAccountsRespAccountsFlags.
const (
	V0041OpenapiAccountsRespAccountsFlagsDELETED          V0041OpenapiAccountsRespAccountsFlags = "DELETED"
	V0041OpenapiAccountsRespAccountsFlagsNoUsersAreCoords V0041OpenapiAccountsRespAccountsFlags = "NoUsersAreCoords"
	V0041OpenapiAccountsRespAccountsFlagsUsersAreCoords   V0041OpenapiAccountsRespAccountsFlags = "UsersAreCoords"
	V0041OpenapiAccountsRespAccountsFlagsWithAssociations V0041OpenapiAccountsRespAccountsFlags = "WithAssociations"
	V0041OpenapiAccountsRespAccountsFlagsWithCoordinators V0041OpenapiAccountsRespAccountsFlags = "WithCoordinators"
)

// Defines values for V0041OpenapiAssocsRespAssociationsFlags.
const (
	V0041OpenapiAssocsRespAssociationsFlagsDELETED          V0041OpenapiAssocsRespAssociationsFlags = "DELETED"
	V0041OpenapiAssocsRespAssociationsFlagsExact            V0041OpenapiAssocsRespAssociationsFlags = "Exact"
	V0041OpenapiAssocsRespAssociationsFlagsNoUpdate         V0041OpenapiAssocsRespAssociationsFlags = "NoUpdate"
	V0041OpenapiAssocsRespAssociationsFlagsNoUsersAreCoords V0041OpenapiAssocsRespAssociationsFlags = "NoUsersAreCoords"
	V0041OpenapiAssocsRespAssociationsFlagsUsersAreCoords   V0041OpenapiAssocsRespAssociationsFlags = "UsersAreCoords"
)

// Defines values for V0041OpenapiClustersRespClustersFlags.
const (
	V0041OpenapiClustersRespClustersFlagsEXTERNAL       V0041OpenapiClustersRespClustersFlags = "EXTERNAL"
	V0041OpenapiClustersRespClustersFlagsFEDERATION     V0041OpenapiClustersRespClustersFlags = "FEDERATION"
	V0041OpenapiClustersRespClustersFlagsMULTIPLESLURMD V0041OpenapiClustersRespClustersFlags = "MULTIPLE_SLURMD"
	V0041OpenapiClustersRespClustersFlagsREGISTERING    V0041OpenapiClustersRespClustersFlags = "REGISTERING"
)

// Defines values for V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus.
const (
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusCOREDUMPED V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusERROR      V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "ERROR"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusINVALID    V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "INVALID"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusPENDING    V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "PENDING"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusSIGNALED   V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "SIGNALED"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusSUCCESS    V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiJobInfoRespJobsExclusive.
const (
	V0041OpenapiJobInfoRespJobsExclusiveFalse V0041OpenapiJobInfoRespJobsExclusive = "false"
	V0041OpenapiJobInfoRespJobsExclusiveMcs   V0041OpenapiJobInfoRespJobsExclusive = "mcs"
	V0041OpenapiJobInfoRespJobsExclusiveTopo  V0041OpenapiJobInfoRespJobsExclusive = "topo"
	V0041OpenapiJobInfoRespJobsExclusiveTrue  V0041OpenapiJobInfoRespJobsExclusive = "true"
	V0041OpenapiJobInfoRespJobsExclusiveUser  V0041OpenapiJobInfoRespJobsExclusive = "user"
)

// Defines values for V0041OpenapiJobInfoRespJobsExitCodeStatus.
const (
	V0041OpenapiJobInfoRespJobsExitCodeStatusCOREDUMPED V0041OpenapiJobInfoRespJobsExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiJobInfoRespJobsExitCodeStatusERROR      V0041OpenapiJobInfoRespJobsExitCodeStatus = "ERROR"
	V0041OpenapiJobInfoRespJobsExitCodeStatusINVALID    V0041OpenapiJobInfoRespJobsExitCodeStatus = "INVALID"
	V0041OpenapiJobInfoRespJobsExitCodeStatusPENDING    V0041OpenapiJobInfoRespJobsExitCodeStatus = "PENDING"
	V0041OpenapiJobInfoRespJobsExitCodeStatusSIGNALED   V0041OpenapiJobInfoRespJobsExitCodeStatus = "SIGNALED"
	V0041OpenapiJobInfoRespJobsExitCodeStatusSUCCESS    V0041OpenapiJobInfoRespJobsExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiJobInfoRespJobsFlags.
const (
	V0041OpenapiJobInfoRespJobsFlagsACCRUECOUNTCLEARED       V0041OpenapiJobInfoRespJobsFlags = "ACCRUE_COUNT_CLEARED"
	V0041OpenapiJobInfoRespJobsFlagsBACKFILLATTEMPTED        V0041OpenapiJobInfoRespJobsFlags = "BACKFILL_ATTEMPTED"
	V0041OpenapiJobInfoRespJobsFlagsCRONJOB                  V0041OpenapiJobInfoRespJobsFlags = "CRON_JOB"
	V0041OpenapiJobInfoRespJobsFlagsDEPENDENT                V0041OpenapiJobInfoRespJobsFlags = "DEPENDENT"
	V0041OpenapiJobInfoRespJobsFlagsEXACTCPUCOUNTREQUESTED   V0041OpenapiJobInfoRespJobsFlags = "EXACT_CPU_COUNT_REQUESTED"
	V0041OpenapiJobInfoRespJobsFlagsEXACTMEMORYREQUESTED     V0041OpenapiJobInfoRespJobsFlags = "EXACT_MEMORY_REQUESTED"
	V0041OpenapiJobInfoRespJobsFlagsEXACTTASKCOUNTREQUESTED  V0041OpenapiJobInfoRespJobsFlags = "EXACT_TASK_COUNT_REQUESTED"
	V0041OpenapiJobInfoRespJobsFlagsGRESBINDINGDISABLED      V0041OpenapiJobInfoRespJobsFlags = "GRES_BINDING_DISABLED"
	V0041OpenapiJobInfoRespJobsFlagsGRESBINDINGENFORCED      V0041OpenapiJobInfoRespJobsFlags = "GRES_BINDING_ENFORCED"
	V0041OpenapiJobInfoRespJobsFlagsHASSTATEDIRECTORY        V0041OpenapiJobInfoRespJobsFlags = "HAS_STATE_DIRECTORY"
	V0041OpenapiJobInfoRespJobsFlagsHETEROGENEOUSJOB         V0041OpenapiJobInfoRespJobsFlags = "HETEROGENEOUS_JOB"
	V0041OpenapiJobInfoRespJobsFlagsJOBACCRUETIMERESET       V0041OpenapiJobInfoRespJobsFlags = "JOB_ACCRUE_TIME_RESET"
	V0041OpenapiJobInfoRespJobsFlagsJOBKILLHURRY             V0041OpenapiJobInfoRespJobsFlags = "JOB_KILL_HURRY"
	V0041OpenapiJobInfoRespJobsFlagsJOBWASRUNNING            V0041OpenapiJobInfoRespJobsFlags = "JOB_WAS_RUNNING"
	V0041OpenapiJobInfoRespJobsFlagsKILLINVALIDDEPENDENCY    V0041OpenapiJobInfoRespJobsFlags = "KILL_INVALID_DEPENDENCY"
	V0041OpenapiJobInfoRespJobsFlagsMAGNETIC                 V0041OpenapiJobInfoRespJobsFlags = "MAGNETIC"
	V0041OpenapiJobInfoRespJobsFlagsNOKILLINVALIDDEPENDENCY  V0041OpenapiJobInfoRespJobsFlags = "NO_KILL_INVALID_DEPENDENCY"
	V0041OpenapiJobInfoRespJobsFlagsPARTITIONASSIGNED        V0041OpenapiJobInfoRespJobsFlags = "PARTITION_ASSIGNED"
	V0041OpenapiJobInfoRespJobsFlagsPREFERMINIMUMNODECOUNT   V0041OpenapiJobInfoRespJobsFlags = "PREFER_MINIMUM_NODE_COUNT"
	V0041OpenapiJobInfoRespJobsFlagsSCHEDULINGATTEMPTED      V0041OpenapiJobInfoRespJobsFlags = "SCHEDULING_ATTEMPTED"
	V0041OpenapiJobInfoRespJobsFlagsSENDJOBENVIRONMENT       V0041OpenapiJobInfoRespJobsFlags = "SEND_JOB_ENVIRONMENT"
	V0041OpenapiJobInfoRespJobsFlagsSIBLINGCLUSTERUPDATEONLY V0041OpenapiJobInfoRespJobsFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	V0041OpenapiJobInfoRespJobsFlagsSKIPTRESSTRINGACCOUNTING V0041OpenapiJobInfoRespJobsFlags = "SKIP_TRES_STRING_ACCOUNTING"
	V0041OpenapiJobInfoRespJobsFlagsSPREADJOB                V0041OpenapiJobInfoRespJobsFlags = "SPREAD_JOB"
	V0041OpenapiJobInfoRespJobsFlagsSTEPMGRENABLED           V0041OpenapiJobInfoRespJobsFlags = "STEPMGR_ENABLED"
	V0041OpenapiJobInfoRespJobsFlagsTESTINGBACKFILL          V0041OpenapiJobInfoRespJobsFlags = "TESTING_BACKFILL"
	V0041OpenapiJobInfoRespJobsFlagsTESTINGWHOLENODEBACKFILL V0041OpenapiJobInfoRespJobsFlags = "TESTING_WHOLE_NODE_BACKFILL"
	V0041OpenapiJobInfoRespJobsFlagsTESTNOWONLY              V0041OpenapiJobInfoRespJobsFlags = "TEST_NOW_ONLY"
	V0041OpenapiJobInfoRespJobsFlagsTOPPRIORITYJOB           V0041OpenapiJobInfoRespJobsFlags = "TOP_PRIORITY_JOB"
	V0041OpenapiJobInfoRespJobsFlagsUSINGDEFAULTACCOUNT      V0041OpenapiJobInfoRespJobsFlags = "USING_DEFAULT_ACCOUNT"
	V0041OpenapiJobInfoRespJobsFlagsUSINGDEFAULTPARTITION    V0041OpenapiJobInfoRespJobsFlags = "USING_DEFAULT_PARTITION"
	V0041OpenapiJobInfoRespJobsFlagsUSINGDEFAULTQOS          V0041OpenapiJobInfoRespJobsFlags = "USING_DEFAULT_QOS"
	V0041OpenapiJobInfoRespJobsFlagsUSINGDEFAULTWCKEY        V0041OpenapiJobInfoRespJobsFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus.
const (
	V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatusALLOCATED   V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus = "ALLOCATED"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatusINUSE       V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus = "IN_USE"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatusINVALID     V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus = "INVALID"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatusUNALLOCATED V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus = "UNALLOCATED"
)

// Defines values for V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType.
const (
	V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectTypeAVAILABLE V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType = "AVAILABLE"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectTypeONEROW    V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType = "ONE_ROW"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectTypeRESERVED  V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType = "RESERVED"
)

// Defines values for V0041OpenapiJobInfoRespJobsJobResourcesSelectType.
const (
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeBOARD                V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "BOARD"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeCORE                 V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "CORE"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeCOREDEFAULTDISTBLOCK V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "CORE_DEFAULT_DIST_BLOCK"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeCPU                  V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "CPU"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeLINEAR               V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "LINEAR"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeLLN                  V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "LLN"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeMEMORY               V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "MEMORY"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeONETASKPERCORE       V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "ONE_TASK_PER_CORE"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypePACKNODES            V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "PACK_NODES"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeSOCKET               V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "SOCKET"
)

// Defines values for V0041OpenapiJobInfoRespJobsJobState.
const (
	V0041OpenapiJobInfoRespJobsJobStateBOOTFAIL     V0041OpenapiJobInfoRespJobsJobState = "BOOT_FAIL"
	V0041OpenapiJobInfoRespJobsJobStateCANCELLED    V0041OpenapiJobInfoRespJobsJobState = "CANCELLED"
	V0041OpenapiJobInfoRespJobsJobStateCOMPLETED    V0041OpenapiJobInfoRespJobsJobState = "COMPLETED"
	V0041OpenapiJobInfoRespJobsJobStateCOMPLETING   V0041OpenapiJobInfoRespJobsJobState = "COMPLETING"
	V0041OpenapiJobInfoRespJobsJobStateCONFIGURING  V0041OpenapiJobInfoRespJobsJobState = "CONFIGURING"
	V0041OpenapiJobInfoRespJobsJobStateDEADLINE     V0041OpenapiJobInfoRespJobsJobState = "DEADLINE"
	V0041OpenapiJobInfoRespJobsJobStateFAILED       V0041OpenapiJobInfoRespJobsJobState = "FAILED"
	V0041OpenapiJobInfoRespJobsJobStateLAUNCHFAILED V0041OpenapiJobInfoRespJobsJobState = "LAUNCH_FAILED"
	V0041OpenapiJobInfoRespJobsJobStateNODEFAIL     V0041OpenapiJobInfoRespJobsJobState = "NODE_FAIL"
	V0041OpenapiJobInfoRespJobsJobStateOUTOFMEMORY  V0041OpenapiJobInfoRespJobsJobState = "OUT_OF_MEMORY"
	V0041OpenapiJobInfoRespJobsJobStatePENDING      V0041OpenapiJobInfoRespJobsJobState = "PENDING"
	V0041OpenapiJobInfoRespJobsJobStatePOWERUPNODE  V0041OpenapiJobInfoRespJobsJobState = "POWER_UP_NODE"
	V0041OpenapiJobInfoRespJobsJobStatePREEMPTED    V0041OpenapiJobInfoRespJobsJobState = "PREEMPTED"
	V0041OpenapiJobInfoRespJobsJobStateRECONFIGFAIL V0041OpenapiJobInfoRespJobsJobState = "RECONFIG_FAIL"
	V0041OpenapiJobInfoRespJobsJobStateREQUEUED     V0041OpenapiJobInfoRespJobsJobState = "REQUEUED"
	V0041OpenapiJobInfoRespJobsJobStateREQUEUEFED   V0041OpenapiJobInfoRespJobsJobState = "REQUEUE_FED"
	V0041OpenapiJobInfoRespJobsJobStateREQUEUEHOLD  V0041OpenapiJobInfoRespJobsJobState = "REQUEUE_HOLD"
	V0041OpenapiJobInfoRespJobsJobStateRESIZING     V0041OpenapiJobInfoRespJobsJobState = "RESIZING"
	V0041OpenapiJobInfoRespJobsJobStateRESVDELHOLD  V0041OpenapiJobInfoRespJobsJobState = "RESV_DEL_HOLD"
	V0041OpenapiJobInfoRespJobsJobStateREVOKED      V0041OpenapiJobInfoRespJobsJobState = "REVOKED"
	V0041OpenapiJobInfoRespJobsJobStateRUNNING      V0041OpenapiJobInfoRespJobsJobState = "RUNNING"
	V0041OpenapiJobInfoRespJobsJobStateSIGNALING    V0041OpenapiJobInfoRespJobsJobState = "SIGNALING"
	V0041OpenapiJobInfoRespJobsJobStateSPECIALEXIT  V0041OpenapiJobInfoRespJobsJobState = "SPECIAL_EXIT"
	V0041OpenapiJobInfoRespJobsJobStateSTAGEOUT     V0041OpenapiJobInfoRespJobsJobState = "STAGE_OUT"
	V0041OpenapiJobInfoRespJobsJobStateSTOPPED      V0041OpenapiJobInfoRespJobsJobState = "STOPPED"
	V0041OpenapiJobInfoRespJobsJobStateSUSPENDED    V0041OpenapiJobInfoRespJobsJobState = "SUSPENDED"
	V0041OpenapiJobInfoRespJobsJobStateTIMEOUT      V0041OpenapiJobInfoRespJobsJobState = "TIMEOUT"
)

// Defines values for V0041OpenapiJobInfoRespJobsMailType.
const (
	V0041OpenapiJobInfoRespJobsMailTypeARRAYTASKS        V0041OpenapiJobInfoRespJobsMailType = "ARRAY_TASKS"
	V0041OpenapiJobInfoRespJobsMailTypeBEGIN             V0041OpenapiJobInfoRespJobsMailType = "BEGIN"
	V0041OpenapiJobInfoRespJobsMailTypeEND               V0041OpenapiJobInfoRespJobsMailType = "END"
	V0041OpenapiJobInfoRespJobsMailTypeFAIL              V0041OpenapiJobInfoRespJobsMailType = "FAIL"
	V0041OpenapiJobInfoRespJobsMailTypeINVALIDDEPENDENCY V0041OpenapiJobInfoRespJobsMailType = "INVALID_DEPENDENCY"
	V0041OpenapiJobInfoRespJobsMailTypeREQUEUE           V0041OpenapiJobInfoRespJobsMailType = "REQUEUE"
	V0041OpenapiJobInfoRespJobsMailTypeSTAGEOUT          V0041OpenapiJobInfoRespJobsMailType = "STAGE_OUT"
	V0041OpenapiJobInfoRespJobsMailTypeTIME100           V0041OpenapiJobInfoRespJobsMailType = "TIME=100%"
	V0041OpenapiJobInfoRespJobsMailTypeTIME50            V0041OpenapiJobInfoRespJobsMailType = "TIME=50%"
	V0041OpenapiJobInfoRespJobsMailTypeTIME80            V0041OpenapiJobInfoRespJobsMailType = "TIME=80%"
	V0041OpenapiJobInfoRespJobsMailTypeTIME90            V0041OpenapiJobInfoRespJobsMailType = "TIME=90%"
)

// Defines values for V0041OpenapiJobInfoRespJobsProfile.
const (
	V0041OpenapiJobInfoRespJobsProfileENERGY  V0041OpenapiJobInfoRespJobsProfile = "ENERGY"
	V0041OpenapiJobInfoRespJobsProfileLUSTRE  V0041OpenapiJobInfoRespJobsProfile = "LUSTRE"
	V0041OpenapiJobInfoRespJobsProfileNETWORK V0041OpenapiJobInfoRespJobsProfile = "NETWORK"
	V0041OpenapiJobInfoRespJobsProfileNONE    V0041OpenapiJobInfoRespJobsProfile = "NONE"
	V0041OpenapiJobInfoRespJobsProfileNOTSET  V0041OpenapiJobInfoRespJobsProfile = "NOT_SET"
	V0041OpenapiJobInfoRespJobsProfileTASK    V0041OpenapiJobInfoRespJobsProfile = "TASK"
)

// Defines values for V0041OpenapiJobInfoRespJobsShared.
const (
	V0041OpenapiJobInfoRespJobsSharedMcs           V0041OpenapiJobInfoRespJobsShared = "mcs"
	V0041OpenapiJobInfoRespJobsSharedNone          V0041OpenapiJobInfoRespJobsShared = "none"
	V0041OpenapiJobInfoRespJobsSharedOversubscribe V0041OpenapiJobInfoRespJobsShared = "oversubscribe"
	V0041OpenapiJobInfoRespJobsSharedTopo          V0041OpenapiJobInfoRespJobsShared = "topo"
	V0041OpenapiJobInfoRespJobsSharedUser          V0041OpenapiJobInfoRespJobsShared = "user"
)

// Defines values for V0041OpenapiJobInfoRespJobsShowFlags.
const (
	V0041OpenapiJobInfoRespJobsShowFlagsALL        V0041OpenapiJobInfoRespJobsShowFlags = "ALL"
	V0041OpenapiJobInfoRespJobsShowFlagsDETAIL     V0041OpenapiJobInfoRespJobsShowFlags = "DETAIL"
	V0041OpenapiJobInfoRespJobsShowFlagsFEDERATION V0041OpenapiJobInfoRespJobsShowFlags = "FEDERATION"
	V0041OpenapiJobInfoRespJobsShowFlagsFUTURE     V0041OpenapiJobInfoRespJobsShowFlags = "FUTURE"
	V0041OpenapiJobInfoRespJobsShowFlagsLOCAL      V0041OpenapiJobInfoRespJobsShowFlags = "LOCAL"
	V0041OpenapiJobInfoRespJobsShowFlagsMIXED      V0041OpenapiJobInfoRespJobsShowFlags = "MIXED"
	V0041OpenapiJobInfoRespJobsShowFlagsSIBLING    V0041OpenapiJobInfoRespJobsShowFlags = "SIBLING"
)

// Defines values for V0041OpenapiNodesRespNodesNextStateAfterReboot.
const (
	V0041OpenapiNodesRespNodesNextStateAfterRebootALLOCATED       V0041OpenapiNodesRespNodesNextStateAfterReboot = "ALLOCATED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootCLOUD           V0041OpenapiNodesRespNodesNextStateAfterReboot = "CLOUD"
	V0041OpenapiNodesRespNodesNextStateAfterRebootCOMPLETING      V0041OpenapiNodesRespNodesNextStateAfterReboot = "COMPLETING"
	V0041OpenapiNodesRespNodesNextStateAfterRebootDOWN            V0041OpenapiNodesRespNodesNextStateAfterReboot = "DOWN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootDRAIN           V0041OpenapiNodesRespNodesNextStateAfterReboot = "DRAIN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootDYNAMICFUTURE   V0041OpenapiNodesRespNodesNextStateAfterReboot = "DYNAMIC_FUTURE"
	V0041OpenapiNodesRespNodesNextStateAfterRebootDYNAMICNORM     V0041OpenapiNodesRespNodesNextStateAfterReboot = "DYNAMIC_NORM"
	V0041OpenapiNodesRespNodesNextStateAfterRebootERROR           V0041OpenapiNodesRespNodesNextStateAfterReboot = "ERROR"
	V0041OpenapiNodesRespNodesNextStateAfterRebootFAIL            V0041OpenapiNodesRespNodesNextStateAfterReboot = "FAIL"
	V0041OpenapiNodesRespNodesNextStateAfterRebootFUTURE          V0041OpenapiNodesRespNodesNextStateAfterReboot = "FUTURE"
	V0041OpenapiNodesRespNodesNextStateAfterRebootIDLE            V0041OpenapiNodesRespNodesNextStateAfterReboot = "IDLE"
	V0041OpenapiNodesRespNodesNextStateAfterRebootINVALID         V0041OpenapiNodesRespNodesNextStateAfterReboot = "INVALID"
	V0041OpenapiNodesRespNodesNextStateAfterRebootINVALIDREG      V0041OpenapiNodesRespNodesNextStateAfterReboot = "INVALID_REG"
	V0041OpenapiNodesRespNodesNextStateAfterRebootMAINTENANCE     V0041OpenapiNodesRespNodesNextStateAfterReboot = "MAINTENANCE"
	V0041OpenapiNodesRespNodesNextStateAfterRebootMIXED           V0041OpenapiNodesRespNodesNextStateAfterReboot = "MIXED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootNOTRESPONDING   V0041OpenapiNodesRespNodesNextStateAfterReboot = "NOT_RESPONDING"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPLANNED         V0041OpenapiNodesRespNodesNextStateAfterReboot = "PLANNED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERDOWN       V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWER_DOWN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERDRAIN      V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWER_DRAIN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWEREDDOWN     V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWERED_DOWN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERINGDOWN    V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWERING_DOWN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERINGUP      V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWERING_UP"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERUP         V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWER_UP"
	V0041OpenapiNodesRespNodesNextStateAfterRebootREBOOTCANCELED  V0041OpenapiNodesRespNodesNextStateAfterReboot = "REBOOT_CANCELED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootREBOOTISSUED    V0041OpenapiNodesRespNodesNextStateAfterReboot = "REBOOT_ISSUED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootREBOOTREQUESTED V0041OpenapiNodesRespNodesNextStateAfterReboot = "REBOOT_REQUESTED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootRESERVED        V0041OpenapiNodesRespNodesNextStateAfterReboot = "RESERVED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootRESUME          V0041OpenapiNodesRespNodesNextStateAfterReboot = "RESUME"
	V0041OpenapiNodesRespNodesNextStateAfterRebootUNDRAIN         V0041OpenapiNodesRespNodesNextStateAfterReboot = "UNDRAIN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootUNKNOWN         V0041OpenapiNodesRespNodesNextStateAfterReboot = "UNKNOWN"
)

// Defines values for V0041OpenapiNodesRespNodesState.
const (
	V0041OpenapiNodesRespNodesStateALLOCATED       V0041OpenapiNodesRespNodesState = "ALLOCATED"
	V0041OpenapiNodesRespNodesStateCLOUD           V0041OpenapiNodesRespNodesState = "CLOUD"
	V0041OpenapiNodesRespNodesStateCOMPLETING      V0041OpenapiNodesRespNodesState = "COMPLETING"
	V0041OpenapiNodesRespNodesStateDOWN            V0041OpenapiNodesRespNodesState = "DOWN"
	V0041OpenapiNodesRespNodesStateDRAIN           V0041OpenapiNodesRespNodesState = "DRAIN"
	V0041OpenapiNodesRespNodesStateDYNAMICFUTURE   V0041OpenapiNodesRespNodesState = "DYNAMIC_FUTURE"
	V0041OpenapiNodesRespNodesStateDYNAMICNORM     V0041OpenapiNodesRespNodesState = "DYNAMIC_NORM"
	V0041OpenapiNodesRespNodesStateERROR           V0041OpenapiNodesRespNodesState = "ERROR"
	V0041OpenapiNodesRespNodesStateFAIL            V0041OpenapiNodesRespNodesState = "FAIL"
	V0041OpenapiNodesRespNodesStateFUTURE          V0041OpenapiNodesRespNodesState = "FUTURE"
	V0041OpenapiNodesRespNodesStateIDLE            V0041OpenapiNodesRespNodesState = "IDLE"
	V0041OpenapiNodesRespNodesStateINVALID         V0041OpenapiNodesRespNodesState = "INVALID"
	V0041OpenapiNodesRespNodesStateINVALIDREG      V0041OpenapiNodesRespNodesState = "INVALID_REG"
	V0041OpenapiNodesRespNodesStateMAINTENANCE     V0041OpenapiNodesRespNodesState = "MAINTENANCE"
	V0041OpenapiNodesRespNodesStateMIXED           V0041OpenapiNodesRespNodesState = "MIXED"
	V0041OpenapiNodesRespNodesStateNOTRESPONDING   V0041OpenapiNodesRespNodesState = "NOT_RESPONDING"
	V0041OpenapiNodesRespNodesStatePLANNED         V0041OpenapiNodesRespNodesState = "PLANNED"
	V0041OpenapiNodesRespNodesStatePOWERDOWN       V0041OpenapiNodesRespNodesState = "POWER_DOWN"
	V0041OpenapiNodesRespNodesStatePOWERDRAIN      V0041OpenapiNodesRespNodesState = "POWER_DRAIN"
	V0041OpenapiNodesRespNodesStatePOWEREDDOWN     V0041OpenapiNodesRespNodesState = "POWERED_DOWN"
	V0041OpenapiNodesRespNodesStatePOWERINGDOWN    V0041OpenapiNodesRespNodesState = "POWERING_DOWN"
	V0041OpenapiNodesRespNodesStatePOWERINGUP      V0041OpenapiNodesRespNodesState = "POWERING_UP"
	V0041OpenapiNodesRespNodesStatePOWERUP         V0041OpenapiNodesRespNodesState = "POWER_UP"
	V0041OpenapiNodesRespNodesStateREBOOTCANCELED  V0041OpenapiNodesRespNodesState = "REBOOT_CANCELED"
	V0041OpenapiNodesRespNodesStateREBOOTISSUED    V0041OpenapiNodesRespNodesState = "REBOOT_ISSUED"
	V0041OpenapiNodesRespNodesStateREBOOTREQUESTED V0041OpenapiNodesRespNodesState = "REBOOT_REQUESTED"
	V0041OpenapiNodesRespNodesStateRESERVED        V0041OpenapiNodesRespNodesState = "RESERVED"
	V0041OpenapiNodesRespNodesStateRESUME          V0041OpenapiNodesRespNodesState = "RESUME"
	V0041OpenapiNodesRespNodesStateUNDRAIN         V0041OpenapiNodesRespNodesState = "UNDRAIN"
	V0041OpenapiNodesRespNodesStateUNKNOWN         V0041OpenapiNodesRespNodesState = "UNKNOWN"
)

// Defines values for V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags.
const (
	Force V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags = "force"
)

// Defines values for V0041OpenapiPartitionRespPartitionsPartitionState.
const (
	V0041OpenapiPartitionRespPartitionsPartitionStateDOWN     V0041OpenapiPartitionRespPartitionsPartitionState = "DOWN"
	V0041OpenapiPartitionRespPartitionsPartitionStateDRAIN    V0041OpenapiPartitionRespPartitionsPartitionState = "DRAIN"
	V0041OpenapiPartitionRespPartitionsPartitionStateINACTIVE V0041OpenapiPartitionRespPartitionsPartitionState = "INACTIVE"
	V0041OpenapiPartitionRespPartitionsPartitionStateUNKNOWN  V0041OpenapiPartitionRespPartitionsPartitionState = "UNKNOWN"
	V0041OpenapiPartitionRespPartitionsPartitionStateUP       V0041OpenapiPartitionRespPartitionsPartitionState = "UP"
)

// Defines values for V0041OpenapiPartitionRespPartitionsSelectType.
const (
	V0041OpenapiPartitionRespPartitionsSelectTypeBOARD                V0041OpenapiPartitionRespPartitionsSelectType = "BOARD"
	V0041OpenapiPartitionRespPartitionsSelectTypeCORE                 V0041OpenapiPartitionRespPartitionsSelectType = "CORE"
	V0041OpenapiPartitionRespPartitionsSelectTypeCOREDEFAULTDISTBLOCK V0041OpenapiPartitionRespPartitionsSelectType = "CORE_DEFAULT_DIST_BLOCK"
	V0041OpenapiPartitionRespPartitionsSelectTypeCPU                  V0041OpenapiPartitionRespPartitionsSelectType = "CPU"
	V0041OpenapiPartitionRespPartitionsSelectTypeLINEAR               V0041OpenapiPartitionRespPartitionsSelectType = "LINEAR"
	V0041OpenapiPartitionRespPartitionsSelectTypeLLN                  V0041OpenapiPartitionRespPartitionsSelectType = "LLN"
	V0041OpenapiPartitionRespPartitionsSelectTypeMEMORY               V0041OpenapiPartitionRespPartitionsSelectType = "MEMORY"
	V0041OpenapiPartitionRespPartitionsSelectTypeONETASKPERCORE       V0041OpenapiPartitionRespPartitionsSelectType = "ONE_TASK_PER_CORE"
	V0041OpenapiPartitionRespPartitionsSelectTypePACKNODES            V0041OpenapiPartitionRespPartitionsSelectType = "PACK_NODES"
	V0041OpenapiPartitionRespPartitionsSelectTypeSOCKET               V0041OpenapiPartitionRespPartitionsSelectType = "SOCKET"
)

// Defines values for V0041OpenapiReservationRespReservationsFlags.
const (
	ALLNODES           V0041OpenapiReservationRespReservationsFlags = "ALL_NODES"
	ANYNODES           V0041OpenapiReservationRespReservationsFlags = "ANY_NODES"
	DAILY              V0041OpenapiReservationRespReservationsFlags = "DAILY"
	DURATIONMINUS      V0041OpenapiReservationRespReservationsFlags = "DURATION_MINUS"
	DURATIONPLUS       V0041OpenapiReservationRespReservationsFlags = "DURATION_PLUS"
	FLEX               V0041OpenapiReservationRespReservationsFlags = "FLEX"
	HOURLY             V0041OpenapiReservationRespReservationsFlags = "HOURLY"
	IGNOREJOBS         V0041OpenapiReservationRespReservationsFlags = "IGNORE_JOBS"
	MAGNETIC           V0041OpenapiReservationRespReservationsFlags = "MAGNETIC"
	MAINT              V0041OpenapiReservationRespReservationsFlags = "MAINT"
	NODAILY            V0041OpenapiReservationRespReservationsFlags = "NO_DAILY"
	NOFLEX             V0041OpenapiReservationRespReservationsFlags = "NO_FLEX"
	NOHOLDJOBSAFTEREND V0041OpenapiReservationRespReservationsFlags = "NO_HOLD_JOBS_AFTER_END"
	NOHOURLY           V0041OpenapiReservationRespReservationsFlags = "NO_HOURLY"
	NOIGNOREJOBS       V0041OpenapiReservationRespReservationsFlags = "NO_IGNORE_JOBS"
	NOMAINT            V0041OpenapiReservationRespReservationsFlags = "NO_MAINT"
	NOPARTNODES        V0041OpenapiReservationRespReservationsFlags = "NO_PART_NODES"
	NOPURGECOMP        V0041OpenapiReservationRespReservationsFlags = "NO_PURGE_COMP"
	NOSTATIC           V0041OpenapiReservationRespReservationsFlags = "NO_STATIC"
	NOUSERDELETE       V0041OpenapiReservationRespReservationsFlags = "NO_USER_DELETE"
	NOWEEKDAY          V0041OpenapiReservationRespReservationsFlags = "NO_WEEKDAY"
	NOWEEKEND          V0041OpenapiReservationRespReservationsFlags = "NO_WEEKEND"
	NOWEEKLY           V0041OpenapiReservationRespReservationsFlags = "NO_WEEKLY"
	OVERLAP            V0041OpenapiReservationRespReservationsFlags = "OVERLAP"
	PARTNODES          V0041OpenapiReservationRespReservationsFlags = "PART_NODES"
	PURGECOMP          V0041OpenapiReservationRespReservationsFlags = "PURGE_COMP"
	REOCCURRING        V0041OpenapiReservationRespReservationsFlags = "REOCCURRING"
	REPLACE            V0041OpenapiReservationRespReservationsFlags = "REPLACE"
	SKIP               V0041OpenapiReservationRespReservationsFlags = "SKIP"
	SPECNODES          V0041OpenapiReservationRespReservationsFlags = "SPEC_NODES"
	STATIC             V0041OpenapiReservationRespReservationsFlags = "STATIC"
	TIMEFLOAT          V0041OpenapiReservationRespReservationsFlags = "TIME_FLOAT"
	USERDELETE         V0041OpenapiReservationRespReservationsFlags = "USER_DELETE"
	WEEKDAY            V0041OpenapiReservationRespReservationsFlags = "WEEKDAY"
	WEEKEND            V0041OpenapiReservationRespReservationsFlags = "WEEKEND"
	WEEKLY             V0041OpenapiReservationRespReservationsFlags = "WEEKLY"
)

// Defines values for V0041OpenapiSharesRespSharesSharesType.
const (
	ASSOCIATION V0041OpenapiSharesRespSharesSharesType = "ASSOCIATION"
	USER        V0041OpenapiSharesRespSharesSharesType = "USER"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespAccountsFlags.
const (
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsDELETED          V0041OpenapiSlurmdbdConfigRespAccountsFlags = "DELETED"
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsNoUsersAreCoords V0041OpenapiSlurmdbdConfigRespAccountsFlags = "NoUsersAreCoords"
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsUsersAreCoords   V0041OpenapiSlurmdbdConfigRespAccountsFlags = "UsersAreCoords"
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsWithAssociations V0041OpenapiSlurmdbdConfigRespAccountsFlags = "WithAssociations"
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsWithCoordinators V0041OpenapiSlurmdbdConfigRespAccountsFlags = "WithCoordinators"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespAssociationsFlags.
const (
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsDELETED          V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "DELETED"
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsExact            V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "Exact"
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsNoUpdate         V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "NoUpdate"
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsNoUsersAreCoords V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "NoUsersAreCoords"
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsUsersAreCoords   V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "UsersAreCoords"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespClustersFlags.
const (
	V0041OpenapiSlurmdbdConfigRespClustersFlagsEXTERNAL       V0041OpenapiSlurmdbdConfigRespClustersFlags = "EXTERNAL"
	V0041OpenapiSlurmdbdConfigRespClustersFlagsFEDERATION     V0041OpenapiSlurmdbdConfigRespClustersFlags = "FEDERATION"
	V0041OpenapiSlurmdbdConfigRespClustersFlagsMULTIPLESLURMD V0041OpenapiSlurmdbdConfigRespClustersFlags = "MULTIPLE_SLURMD"
	V0041OpenapiSlurmdbdConfigRespClustersFlagsREGISTERING    V0041OpenapiSlurmdbdConfigRespClustersFlags = "REGISTERING"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespQosFlags.
const (
	V0041OpenapiSlurmdbdConfigRespQosFlagsADD                   V0041OpenapiSlurmdbdConfigRespQosFlags = "ADD"
	V0041OpenapiSlurmdbdConfigRespQosFlagsDENYLIMIT             V0041OpenapiSlurmdbdConfigRespQosFlags = "DENY_LIMIT"
	V0041OpenapiSlurmdbdConfigRespQosFlagsENFORCEUSAGETHRESHOLD V0041OpenapiSlurmdbdConfigRespQosFlags = "ENFORCE_USAGE_THRESHOLD"
	V0041OpenapiSlurmdbdConfigRespQosFlagsNODECAY               V0041OpenapiSlurmdbdConfigRespQosFlags = "NO_DECAY"
	V0041OpenapiSlurmdbdConfigRespQosFlagsNORESERVE             V0041OpenapiSlurmdbdConfigRespQosFlags = "NO_RESERVE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsNOTSET                V0041OpenapiSlurmdbdConfigRespQosFlags = "NOT_SET"
	V0041OpenapiSlurmdbdConfigRespQosFlagsOVERRIDEPARTITIONQOS  V0041OpenapiSlurmdbdConfigRespQosFlags = "OVERRIDE_PARTITION_QOS"
	V0041OpenapiSlurmdbdConfigRespQosFlagsPARTITIONMAXIMUMNODE  V0041OpenapiSlurmdbdConfigRespQosFlags = "PARTITION_MAXIMUM_NODE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsPARTITIONMINIMUMNODE  V0041OpenapiSlurmdbdConfigRespQosFlags = "PARTITION_MINIMUM_NODE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsPARTITIONTIMELIMIT    V0041OpenapiSlurmdbdConfigRespQosFlags = "PARTITION_TIME_LIMIT"
	V0041OpenapiSlurmdbdConfigRespQosFlagsRELATIVE              V0041OpenapiSlurmdbdConfigRespQosFlags = "RELATIVE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsREMOVE                V0041OpenapiSlurmdbdConfigRespQosFlags = "REMOVE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsREQUIREDRESERVATION   V0041OpenapiSlurmdbdConfigRespQosFlags = "REQUIRED_RESERVATION"
	V0041OpenapiSlurmdbdConfigRespQosFlagsUSAGEFACTORSAFE       V0041OpenapiSlurmdbdConfigRespQosFlags = "USAGE_FACTOR_SAFE"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespQosPreemptMode.
const (
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeCANCEL   V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "CANCEL"
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeDISABLED V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "DISABLED"
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeGANG     V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "GANG"
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeREQUEUE  V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "REQUEUE"
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeSUSPEND  V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "SUSPEND"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel.
const (
	V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevelAdministrator V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel = "Administrator"
	V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevelNone          V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel = "None"
	V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevelNotSet        V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel = "Not Set"
	V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevelOperator      V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel = "Operator"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespUsersFlags.
const (
	V0041OpenapiSlurmdbdConfigRespUsersFlagsDELETED V0041OpenapiSlurmdbdConfigRespUsersFlags = "DELETED"
	V0041OpenapiSlurmdbdConfigRespUsersFlagsNONE    V0041OpenapiSlurmdbdConfigRespUsersFlags = "NONE"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags.
const (
	V0041OpenapiSlurmdbdConfigRespUsersWckeysFlagsDELETED V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags = "DELETED"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespWckeysFlags.
const (
	V0041OpenapiSlurmdbdConfigRespWckeysFlagsDELETED V0041OpenapiSlurmdbdConfigRespWckeysFlags = "DELETED"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus.
const (
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusCOREDUMPED V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusERROR      V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "ERROR"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusINVALID    V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "INVALID"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusPENDING    V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusSIGNALED   V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "SIGNALED"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusSUCCESS    V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus.
const (
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusCOREDUMPED V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusERROR      V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "ERROR"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusINVALID    V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "INVALID"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusPENDING    V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusSIGNALED   V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "SIGNALED"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusSUCCESS    V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsFlags.
const (
	V0041OpenapiSlurmdbdJobsRespJobsFlagsCLEARSCHEDULING   V0041OpenapiSlurmdbdJobsRespJobsFlags = "CLEAR_SCHEDULING"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsNONE              V0041OpenapiSlurmdbdJobsRespJobsFlags = "NONE"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsNOTSET            V0041OpenapiSlurmdbdJobsRespJobsFlags = "NOT_SET"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsSTARTEDONBACKFILL V0041OpenapiSlurmdbdJobsRespJobsFlags = "STARTED_ON_BACKFILL"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsSTARTEDONSCHEDULE V0041OpenapiSlurmdbdJobsRespJobsFlags = "STARTED_ON_SCHEDULE"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsSTARTEDONSUBMIT   V0041OpenapiSlurmdbdJobsRespJobsFlags = "STARTED_ON_SUBMIT"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsSTARTRECEIVED     V0041OpenapiSlurmdbdJobsRespJobsFlags = "START_RECEIVED"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsStateCurrent.
const (
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentBOOTFAIL     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "BOOT_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentCANCELLED    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "CANCELLED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentCOMPLETED    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "COMPLETED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentCOMPLETING   V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "COMPLETING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentCONFIGURING  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "CONFIGURING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentDEADLINE     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "DEADLINE"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentFAILED       V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "FAILED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentLAUNCHFAILED V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "LAUNCH_FAILED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentNODEFAIL     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "NODE_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentOUTOFMEMORY  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "OUT_OF_MEMORY"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentPENDING      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentPOWERUPNODE  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "POWER_UP_NODE"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentPREEMPTED    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "PREEMPTED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentRECONFIGFAIL V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "RECONFIG_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentREQUEUED     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "REQUEUED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentREQUEUEFED   V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "REQUEUE_FED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentREQUEUEHOLD  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "REQUEUE_HOLD"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentRESIZING     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "RESIZING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentRESVDELHOLD  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "RESV_DEL_HOLD"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentREVOKED      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "REVOKED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentRUNNING      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "RUNNING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSIGNALING    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "SIGNALING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSPECIALEXIT  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "SPECIAL_EXIT"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSTAGEOUT     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "STAGE_OUT"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSTOPPED      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "STOPPED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSUSPENDED    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "SUSPENDED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentTIMEOUT      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "TIMEOUT"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus.
const (
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusCOREDUMPED V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusERROR      V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "ERROR"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusINVALID    V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "INVALID"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusPENDING    V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusSIGNALED   V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "SIGNALED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusSUCCESS    V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsStepsState.
const (
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateBOOTFAIL     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "BOOT_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateCANCELLED    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "CANCELLED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateCOMPLETED    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "COMPLETED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateCOMPLETING   V0041OpenapiSlurmdbdJobsRespJobsStepsState = "COMPLETING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateCONFIGURING  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "CONFIGURING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateDEADLINE     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "DEADLINE"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateFAILED       V0041OpenapiSlurmdbdJobsRespJobsStepsState = "FAILED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateLAUNCHFAILED V0041OpenapiSlurmdbdJobsRespJobsStepsState = "LAUNCH_FAILED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateNODEFAIL     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "NODE_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateOUTOFMEMORY  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "OUT_OF_MEMORY"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStatePENDING      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStatePOWERUPNODE  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "POWER_UP_NODE"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStatePREEMPTED    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "PREEMPTED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateRECONFIGFAIL V0041OpenapiSlurmdbdJobsRespJobsStepsState = "RECONFIG_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateREQUEUED     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "REQUEUED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateREQUEUEFED   V0041OpenapiSlurmdbdJobsRespJobsStepsState = "REQUEUE_FED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateREQUEUEHOLD  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "REQUEUE_HOLD"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateRESIZING     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "RESIZING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateRESVDELHOLD  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "RESV_DEL_HOLD"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateREVOKED      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "REVOKED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateRUNNING      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "RUNNING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSIGNALING    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "SIGNALING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSPECIALEXIT  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "SPECIAL_EXIT"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSTAGEOUT     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "STAGE_OUT"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSTOPPED      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "STOPPED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSUSPENDED    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "SUSPENDED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateTIMEOUT      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "TIMEOUT"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags.
const (
	ASSIGNEDDEFAULT V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags = "ASSIGNED_DEFAULT"
)

// Defines values for V0041OpenapiSlurmdbdQosRespQosFlags.
const (
	V0041OpenapiSlurmdbdQosRespQosFlagsADD                   V0041OpenapiSlurmdbdQosRespQosFlags = "ADD"
	V0041OpenapiSlurmdbdQosRespQosFlagsDENYLIMIT             V0041OpenapiSlurmdbdQosRespQosFlags = "DENY_LIMIT"
	V0041OpenapiSlurmdbdQosRespQosFlagsENFORCEUSAGETHRESHOLD V0041OpenapiSlurmdbdQosRespQosFlags = "ENFORCE_USAGE_THRESHOLD"
	V0041OpenapiSlurmdbdQosRespQosFlagsNODECAY               V0041OpenapiSlurmdbdQosRespQosFlags = "NO_DECAY"
	V0041OpenapiSlurmdbdQosRespQosFlagsNORESERVE             V0041OpenapiSlurmdbdQosRespQosFlags = "NO_RESERVE"
	V0041OpenapiSlurmdbdQosRespQosFlagsNOTSET                V0041OpenapiSlurmdbdQosRespQosFlags = "NOT_SET"
	V0041OpenapiSlurmdbdQosRespQosFlagsOVERRIDEPARTITIONQOS  V0041OpenapiSlurmdbdQosRespQosFlags = "OVERRIDE_PARTITION_QOS"
	V0041OpenapiSlurmdbdQosRespQosFlagsPARTITIONMAXIMUMNODE  V0041OpenapiSlurmdbdQosRespQosFlags = "PARTITION_MAXIMUM_NODE"
	V0041OpenapiSlurmdbdQosRespQosFlagsPARTITIONMINIMUMNODE  V0041OpenapiSlurmdbdQosRespQosFlags = "PARTITION_MINIMUM_NODE"
	V0041OpenapiSlurmdbdQosRespQosFlagsPARTITIONTIMELIMIT    V0041OpenapiSlurmdbdQosRespQosFlags = "PARTITION_TIME_LIMIT"
	V0041OpenapiSlurmdbdQosRespQosFlagsRELATIVE              V0041OpenapiSlurmdbdQosRespQosFlags = "RELATIVE"
	V0041OpenapiSlurmdbdQosRespQosFlagsREMOVE                V0041OpenapiSlurmdbdQosRespQosFlags = "REMOVE"
	V0041OpenapiSlurmdbdQosRespQosFlagsREQUIREDRESERVATION   V0041OpenapiSlurmdbdQosRespQosFlags = "REQUIRED_RESERVATION"
	V0041OpenapiSlurmdbdQosRespQosFlagsUSAGEFACTORSAFE       V0041OpenapiSlurmdbdQosRespQosFlags = "USAGE_FACTOR_SAFE"
)

// Defines values for V0041OpenapiSlurmdbdQosRespQosPreemptMode.
const (
	V0041OpenapiSlurmdbdQosRespQosPreemptModeCANCEL   V0041OpenapiSlurmdbdQosRespQosPreemptMode = "CANCEL"
	V0041OpenapiSlurmdbdQosRespQosPreemptModeDISABLED V0041OpenapiSlurmdbdQosRespQosPreemptMode = "DISABLED"
	V0041OpenapiSlurmdbdQosRespQosPreemptModeGANG     V0041OpenapiSlurmdbdQosRespQosPreemptMode = "GANG"
	V0041OpenapiSlurmdbdQosRespQosPreemptModeREQUEUE  V0041OpenapiSlurmdbdQosRespQosPreemptMode = "REQUEUE"
	V0041OpenapiSlurmdbdQosRespQosPreemptModeSUSPEND  V0041OpenapiSlurmdbdQosRespQosPreemptMode = "SUSPEND"
)

// Defines values for V0041OpenapiUsersAddCondRespUserAdminlevel.
const (
	V0041OpenapiUsersAddCondRespUserAdminlevelAdministrator V0041OpenapiUsersAddCondRespUserAdminlevel = "Administrator"
	V0041OpenapiUsersAddCondRespUserAdminlevelNone          V0041OpenapiUsersAddCondRespUserAdminlevel = "None"
	V0041OpenapiUsersAddCondRespUserAdminlevelNotSet        V0041OpenapiUsersAddCondRespUserAdminlevel = "Not Set"
	V0041OpenapiUsersAddCondRespUserAdminlevelOperator      V0041OpenapiUsersAddCondRespUserAdminlevel = "Operator"
)

// Defines values for V0041OpenapiUsersRespUsersAdministratorLevel.
const (
	V0041OpenapiUsersRespUsersAdministratorLevelAdministrator V0041OpenapiUsersRespUsersAdministratorLevel = "Administrator"
	V0041OpenapiUsersRespUsersAdministratorLevelNone          V0041OpenapiUsersRespUsersAdministratorLevel = "None"
	V0041OpenapiUsersRespUsersAdministratorLevelNotSet        V0041OpenapiUsersRespUsersAdministratorLevel = "Not Set"
	V0041OpenapiUsersRespUsersAdministratorLevelOperator      V0041OpenapiUsersRespUsersAdministratorLevel = "Operator"
)

// Defines values for V0041OpenapiUsersRespUsersFlags.
const (
	V0041OpenapiUsersRespUsersFlagsDELETED V0041OpenapiUsersRespUsersFlags = "DELETED"
	V0041OpenapiUsersRespUsersFlagsNONE    V0041OpenapiUsersRespUsersFlags = "NONE"
)

// Defines values for V0041OpenapiUsersRespUsersWckeysFlags.
const (
	V0041OpenapiUsersRespUsersWckeysFlagsDELETED V0041OpenapiUsersRespUsersWckeysFlags = "DELETED"
)

// Defines values for V0041OpenapiWckeyRespWckeysFlags.
const (
	V0041OpenapiWckeyRespWckeysFlagsDELETED V0041OpenapiWckeyRespWckeysFlags = "DELETED"
)

// Defines values for V0041UpdateNodeMsgState.
const (
	V0041UpdateNodeMsgStateALLOCATED       V0041UpdateNodeMsgState = "ALLOCATED"
	V0041UpdateNodeMsgStateCLOUD           V0041UpdateNodeMsgState = "CLOUD"
	V0041UpdateNodeMsgStateCOMPLETING      V0041UpdateNodeMsgState = "COMPLETING"
	V0041UpdateNodeMsgStateDOWN            V0041UpdateNodeMsgState = "DOWN"
	V0041UpdateNodeMsgStateDRAIN           V0041UpdateNodeMsgState = "DRAIN"
	V0041UpdateNodeMsgStateDYNAMICFUTURE   V0041UpdateNodeMsgState = "DYNAMIC_FUTURE"
	V0041UpdateNodeMsgStateDYNAMICNORM     V0041UpdateNodeMsgState = "DYNAMIC_NORM"
	V0041UpdateNodeMsgStateERROR           V0041UpdateNodeMsgState = "ERROR"
	V0041UpdateNodeMsgStateFAIL            V0041UpdateNodeMsgState = "FAIL"
	V0041UpdateNodeMsgStateFUTURE          V0041UpdateNodeMsgState = "FUTURE"
	V0041UpdateNodeMsgStateIDLE            V0041UpdateNodeMsgState = "IDLE"
	V0041UpdateNodeMsgStateINVALID         V0041UpdateNodeMsgState = "INVALID"
	V0041UpdateNodeMsgStateINVALIDREG      V0041UpdateNodeMsgState = "INVALID_REG"
	V0041UpdateNodeMsgStateMAINTENANCE     V0041UpdateNodeMsgState = "MAINTENANCE"
	V0041UpdateNodeMsgStateMIXED           V0041UpdateNodeMsgState = "MIXED"
	V0041UpdateNodeMsgStateNOTRESPONDING   V0041UpdateNodeMsgState = "NOT_RESPONDING"
	V0041UpdateNodeMsgStatePLANNED         V0041UpdateNodeMsgState = "PLANNED"
	V0041UpdateNodeMsgStatePOWERDOWN       V0041UpdateNodeMsgState = "POWER_DOWN"
	V0041UpdateNodeMsgStatePOWERDRAIN      V0041UpdateNodeMsgState = "POWER_DRAIN"
	V0041UpdateNodeMsgStatePOWEREDDOWN     V0041UpdateNodeMsgState = "POWERED_DOWN"
	V0041UpdateNodeMsgStatePOWERINGDOWN    V0041UpdateNodeMsgState = "POWERING_DOWN"
	V0041UpdateNodeMsgStatePOWERINGUP      V0041UpdateNodeMsgState = "POWERING_UP"
	V0041UpdateNodeMsgStatePOWERUP         V0041UpdateNodeMsgState = "POWER_UP"
	V0041UpdateNodeMsgStateREBOOTCANCELED  V0041UpdateNodeMsgState = "REBOOT_CANCELED"
	V0041UpdateNodeMsgStateREBOOTISSUED    V0041UpdateNodeMsgState = "REBOOT_ISSUED"
	V0041UpdateNodeMsgStateREBOOTREQUESTED V0041UpdateNodeMsgState = "REBOOT_REQUESTED"
	V0041UpdateNodeMsgStateRESERVED        V0041UpdateNodeMsgState = "RESERVED"
	V0041UpdateNodeMsgStateRESUME          V0041UpdateNodeMsgState = "RESUME"
	V0041UpdateNodeMsgStateUNDRAIN         V0041UpdateNodeMsgState = "UNDRAIN"
	V0041UpdateNodeMsgStateUNKNOWN         V0041UpdateNodeMsgState = "UNKNOWN"
)

// Defines values for SlurmV0041DeleteJobParamsFlags.
const (
	SlurmV0041DeleteJobParamsFlagsARRAYTASK         SlurmV0041DeleteJobParamsFlags = "ARRAY_TASK"
	SlurmV0041DeleteJobParamsFlagsBATCHJOB          SlurmV0041DeleteJobParamsFlags = "BATCH_JOB"
	SlurmV0041DeleteJobParamsFlagsCRONJOBS          SlurmV0041DeleteJobParamsFlags = "CRON_JOBS"
	SlurmV0041DeleteJobParamsFlagsFEDERATIONREQUEUE SlurmV0041DeleteJobParamsFlags = "FEDERATION_REQUEUE"
	SlurmV0041DeleteJobParamsFlagsFULLJOB           SlurmV0041DeleteJobParamsFlags = "FULL_JOB"
	SlurmV0041DeleteJobParamsFlagsFULLSTEPSONLY     SlurmV0041DeleteJobParamsFlags = "FULL_STEPS_ONLY"
	SlurmV0041DeleteJobParamsFlagsHURRY             SlurmV0041DeleteJobParamsFlags = "HURRY"
	SlurmV0041DeleteJobParamsFlagsNOSIBLINGJOBS     SlurmV0041DeleteJobParamsFlags = "NO_SIBLING_JOBS"
	SlurmV0041DeleteJobParamsFlagsOUTOFMEMORY       SlurmV0041DeleteJobParamsFlags = "OUT_OF_MEMORY"
	SlurmV0041DeleteJobParamsFlagsRESERVATIONJOB    SlurmV0041DeleteJobParamsFlags = "RESERVATION_JOB"
	SlurmV0041DeleteJobParamsFlagsVERBOSE           SlurmV0041DeleteJobParamsFlags = "VERBOSE"
	SlurmV0041DeleteJobParamsFlagsWARNINGSENT       SlurmV0041DeleteJobParamsFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041GetJobParamsFlags.
const (
	SlurmV0041GetJobParamsFlagsALL        SlurmV0041GetJobParamsFlags = "ALL"
	SlurmV0041GetJobParamsFlagsDETAIL     SlurmV0041GetJobParamsFlags = "DETAIL"
	SlurmV0041GetJobParamsFlagsFEDERATION SlurmV0041GetJobParamsFlags = "FEDERATION"
	SlurmV0041GetJobParamsFlagsFUTURE     SlurmV0041GetJobParamsFlags = "FUTURE"
	SlurmV0041GetJobParamsFlagsLOCAL      SlurmV0041GetJobParamsFlags = "LOCAL"
	SlurmV0041GetJobParamsFlagsMIXED      SlurmV0041GetJobParamsFlags = "MIXED"
	SlurmV0041GetJobParamsFlagsSIBLING    SlurmV0041GetJobParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetJobsParamsFlags.
const (
	SlurmV0041GetJobsParamsFlagsALL        SlurmV0041GetJobsParamsFlags = "ALL"
	SlurmV0041GetJobsParamsFlagsDETAIL     SlurmV0041GetJobsParamsFlags = "DETAIL"
	SlurmV0041GetJobsParamsFlagsFEDERATION SlurmV0041GetJobsParamsFlags = "FEDERATION"
	SlurmV0041GetJobsParamsFlagsFUTURE     SlurmV0041GetJobsParamsFlags = "FUTURE"
	SlurmV0041GetJobsParamsFlagsLOCAL      SlurmV0041GetJobsParamsFlags = "LOCAL"
	SlurmV0041GetJobsParamsFlagsMIXED      SlurmV0041GetJobsParamsFlags = "MIXED"
	SlurmV0041GetJobsParamsFlagsSIBLING    SlurmV0041GetJobsParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetNodeParamsFlags.
const (
	SlurmV0041GetNodeParamsFlagsALL        SlurmV0041GetNodeParamsFlags = "ALL"
	SlurmV0041GetNodeParamsFlagsDETAIL     SlurmV0041GetNodeParamsFlags = "DETAIL"
	SlurmV0041GetNodeParamsFlagsFEDERATION SlurmV0041GetNodeParamsFlags = "FEDERATION"
	SlurmV0041GetNodeParamsFlagsFUTURE     SlurmV0041GetNodeParamsFlags = "FUTURE"
	SlurmV0041GetNodeParamsFlagsLOCAL      SlurmV0041GetNodeParamsFlags = "LOCAL"
	SlurmV0041GetNodeParamsFlagsMIXED      SlurmV0041GetNodeParamsFlags = "MIXED"
	SlurmV0041GetNodeParamsFlagsSIBLING    SlurmV0041GetNodeParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetNodesParamsFlags.
const (
	SlurmV0041GetNodesParamsFlagsALL        SlurmV0041GetNodesParamsFlags = "ALL"
	SlurmV0041GetNodesParamsFlagsDETAIL     SlurmV0041GetNodesParamsFlags = "DETAIL"
	SlurmV0041GetNodesParamsFlagsFEDERATION SlurmV0041GetNodesParamsFlags = "FEDERATION"
	SlurmV0041GetNodesParamsFlagsFUTURE     SlurmV0041GetNodesParamsFlags = "FUTURE"
	SlurmV0041GetNodesParamsFlagsLOCAL      SlurmV0041GetNodesParamsFlags = "LOCAL"
	SlurmV0041GetNodesParamsFlagsMIXED      SlurmV0041GetNodesParamsFlags = "MIXED"
	SlurmV0041GetNodesParamsFlagsSIBLING    SlurmV0041GetNodesParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetPartitionParamsFlags.
const (
	SlurmV0041GetPartitionParamsFlagsALL        SlurmV0041GetPartitionParamsFlags = "ALL"
	SlurmV0041GetPartitionParamsFlagsDETAIL     SlurmV0041GetPartitionParamsFlags = "DETAIL"
	SlurmV0041GetPartitionParamsFlagsFEDERATION SlurmV0041GetPartitionParamsFlags = "FEDERATION"
	SlurmV0041GetPartitionParamsFlagsFUTURE     SlurmV0041GetPartitionParamsFlags = "FUTURE"
	SlurmV0041GetPartitionParamsFlagsLOCAL      SlurmV0041GetPartitionParamsFlags = "LOCAL"
	SlurmV0041GetPartitionParamsFlagsMIXED      SlurmV0041GetPartitionParamsFlags = "MIXED"
	SlurmV0041GetPartitionParamsFlagsSIBLING    SlurmV0041GetPartitionParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetPartitionsParamsFlags.
const (
	SlurmV0041GetPartitionsParamsFlagsALL        SlurmV0041GetPartitionsParamsFlags = "ALL"
	SlurmV0041GetPartitionsParamsFlagsDETAIL     SlurmV0041GetPartitionsParamsFlags = "DETAIL"
	SlurmV0041GetPartitionsParamsFlagsFEDERATION SlurmV0041GetPartitionsParamsFlags = "FEDERATION"
	SlurmV0041GetPartitionsParamsFlagsFUTURE     SlurmV0041GetPartitionsParamsFlags = "FUTURE"
	SlurmV0041GetPartitionsParamsFlagsLOCAL      SlurmV0041GetPartitionsParamsFlags = "LOCAL"
	SlurmV0041GetPartitionsParamsFlagsMIXED      SlurmV0041GetPartitionsParamsFlags = "MIXED"
	SlurmV0041GetPartitionsParamsFlagsSIBLING    SlurmV0041GetPartitionsParamsFlags = "SIBLING"
)

// Defines values for SlurmdbV0041DeleteClusterParamsClassification.
const (
	SlurmdbV0041DeleteClusterParamsClassificationCAPABILITY                          SlurmdbV0041DeleteClusterParamsClassification = "CAPABILITY"
	SlurmdbV0041DeleteClusterParamsClassificationCAPACITY                            SlurmdbV0041DeleteClusterParamsClassification = "CAPACITY"
	SlurmdbV0041DeleteClusterParamsClassificationCAPAPACITYBothCAPABILITYAndCAPACITY SlurmdbV0041DeleteClusterParamsClassification = "CAPAPACITY (both CAPABILITY and CAPACITY)"
	SlurmdbV0041DeleteClusterParamsClassificationUNCLASSIFIED                        SlurmdbV0041DeleteClusterParamsClassification = "UNCLASSIFIED"
)

// Defines values for SlurmdbV0041DeleteClusterParamsFlags.
const (
	SlurmdbV0041DeleteClusterParamsFlagsEXTERNAL       SlurmdbV0041DeleteClusterParamsFlags = "EXTERNAL"
	SlurmdbV0041DeleteClusterParamsFlagsFEDERATION     SlurmdbV0041DeleteClusterParamsFlags = "FEDERATION"
	SlurmdbV0041DeleteClusterParamsFlagsMULTIPLESLURMD SlurmdbV0041DeleteClusterParamsFlags = "MULTIPLE_SLURMD"
	SlurmdbV0041DeleteClusterParamsFlagsREGISTERING    SlurmdbV0041DeleteClusterParamsFlags = "REGISTERING"
)

// Defines values for SlurmdbV0041GetClusterParamsClassification.
const (
	SlurmdbV0041GetClusterParamsClassificationCAPABILITY                          SlurmdbV0041GetClusterParamsClassification = "CAPABILITY"
	SlurmdbV0041GetClusterParamsClassificationCAPACITY                            SlurmdbV0041GetClusterParamsClassification = "CAPACITY"
	SlurmdbV0041GetClusterParamsClassificationCAPAPACITYBothCAPABILITYAndCAPACITY SlurmdbV0041GetClusterParamsClassification = "CAPAPACITY (both CAPABILITY and CAPACITY)"
	SlurmdbV0041GetClusterParamsClassificationUNCLASSIFIED                        SlurmdbV0041GetClusterParamsClassification = "UNCLASSIFIED"
)

// Defines values for SlurmdbV0041GetClusterParamsFlags.
const (
	SlurmdbV0041GetClusterParamsFlagsEXTERNAL       SlurmdbV0041GetClusterParamsFlags = "EXTERNAL"
	SlurmdbV0041GetClusterParamsFlagsFEDERATION     SlurmdbV0041GetClusterParamsFlags = "FEDERATION"
	SlurmdbV0041GetClusterParamsFlagsMULTIPLESLURMD SlurmdbV0041GetClusterParamsFlags = "MULTIPLE_SLURMD"
	SlurmdbV0041GetClusterParamsFlagsREGISTERING    SlurmdbV0041GetClusterParamsFlags = "REGISTERING"
)

// Defines values for SlurmdbV0041GetQosParamsPreemptMode.
const (
	SlurmdbV0041GetQosParamsPreemptModeCANCEL   SlurmdbV0041GetQosParamsPreemptMode = "CANCEL"
	SlurmdbV0041GetQosParamsPreemptModeDISABLED SlurmdbV0041GetQosParamsPreemptMode = "DISABLED"
	SlurmdbV0041GetQosParamsPreemptModeGANG     SlurmdbV0041GetQosParamsPreemptMode = "GANG"
	SlurmdbV0041GetQosParamsPreemptModeREQUEUE  SlurmdbV0041GetQosParamsPreemptMode = "REQUEUE"
	SlurmdbV0041GetQosParamsPreemptModeSUSPEND  SlurmdbV0041GetQosParamsPreemptMode = "SUSPEND"
)

// Defines values for SlurmdbV0041PostQosParamsPreemptMode.
const (
	CANCEL   SlurmdbV0041PostQosParamsPreemptMode = "CANCEL"
	DISABLED SlurmdbV0041PostQosParamsPreemptMode = "DISABLED"
	GANG     SlurmdbV0041PostQosParamsPreemptMode = "GANG"
	REQUEUE  SlurmdbV0041PostQosParamsPreemptMode = "REQUEUE"
	SUSPEND  SlurmdbV0041PostQosParamsPreemptMode = "SUSPEND"
)

// Defines values for SlurmdbV0041GetUsersParamsAdminLevel.
const (
	SlurmdbV0041GetUsersParamsAdminLevelAdministrator SlurmdbV0041GetUsersParamsAdminLevel = "Administrator"
	SlurmdbV0041GetUsersParamsAdminLevelNone          SlurmdbV0041GetUsersParamsAdminLevel = "None"
	SlurmdbV0041GetUsersParamsAdminLevelNotSet        SlurmdbV0041GetUsersParamsAdminLevel = "Not Set"
	SlurmdbV0041GetUsersParamsAdminLevelOperator      SlurmdbV0041GetUsersParamsAdminLevel = "Operator"
)

// Defines values for SlurmdbV0041PostUsersAssociationParamsFlags.
const (
	SlurmdbV0041PostUsersAssociationParamsFlagsALL        SlurmdbV0041PostUsersAssociationParamsFlags = "ALL"
	SlurmdbV0041PostUsersAssociationParamsFlagsDETAIL     SlurmdbV0041PostUsersAssociationParamsFlags = "DETAIL"
	SlurmdbV0041PostUsersAssociationParamsFlagsFEDERATION SlurmdbV0041PostUsersAssociationParamsFlags = "FEDERATION"
	SlurmdbV0041PostUsersAssociationParamsFlagsFUTURE     SlurmdbV0041PostUsersAssociationParamsFlags = "FUTURE"
	SlurmdbV0041PostUsersAssociationParamsFlagsLOCAL      SlurmdbV0041PostUsersAssociationParamsFlags = "LOCAL"
	SlurmdbV0041PostUsersAssociationParamsFlagsMIXED      SlurmdbV0041PostUsersAssociationParamsFlags = "MIXED"
	SlurmdbV0041PostUsersAssociationParamsFlagsSIBLING    SlurmdbV0041PostUsersAssociationParamsFlags = "SIBLING"
)

// V0041JobAllocReq defines model for v0.0.41_job_alloc_req.
type V0041JobAllocReq struct {
	// Hetjob HetJob description
	Hetjob *[]V0041JobDescMsg `json:"hetjob,omitempty"`
	Job    *V0041JobDescMsg   `json:"job,omitempty"`
}

// V0041JobDescMsg defines model for v0.0.41_job_desc_msg.
type V0041JobDescMsg struct {
	// Account Account associated with the job
	Account *string `json:"account,omitempty"`

	// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
	AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

	// AdminComment Arbitrary comment made by administrator
	AdminComment *string `json:"admin_comment,omitempty"`

	// AllocationNodeList Local node making the resource allocation
	AllocationNodeList *string `json:"allocation_node_list,omitempty"`

	// AllocationNodePort Port to send allocation confirmation to
	AllocationNodePort *int32 `json:"allocation_node_port,omitempty"`

	// Argv Arguments to the script
	Argv *[]string `json:"argv,omitempty"`

	// Array Job array index value specification
	Array *string `json:"array,omitempty"`

	// BatchFeatures Features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// BeginTime Defer the allocation of the job until the specified time (UNIX timestamp)
	BeginTime *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"begin_time,omitempty"`

	// BurstBuffer Burst buffer specifications
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
	ClusterConstraint *string `json:"cluster_constraint,omitempty"`

	// Clusters Clusters that a federated job can run on
	Clusters *string `json:"clusters,omitempty"`

	// Comment Arbitrary comment made by user
	Comment *string `json:"comment,omitempty"`

	// Constraints Comma separated list of features that are required
	Constraints *string `json:"constraints,omitempty"`

	// Container Absolute path to OCI container bundle
	Container *string `json:"container,omitempty"`

	// ContainerId OCI container ID
	ContainerId *string `json:"container_id,omitempty"`

	// Contiguous True if job requires contiguous nodes
	Contiguous *bool `json:"contiguous,omitempty"`

	// CoreSpecification Specialized core count
	CoreSpecification *int32 `json:"core_specification,omitempty"`

	// CpuBinding Method for binding tasks to allocated CPUs
	CpuBinding *string `json:"cpu_binding,omitempty"`

	// CpuBindingFlags Flags for CPU binding
	CpuBindingFlags *[]V0041JobDescMsgCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

	// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
	CpuFrequency *string `json:"cpu_frequency,omitempty"`

	// CpusPerTask Number of CPUs required by each task
	CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

	// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
	CpusPerTres *string `json:"cpus_per_tres,omitempty"`

	// Crontab Specification for scrontab job
	Crontab *struct {
		// Command Command to run
		Command *string `json:"command,omitempty"`

		// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
		DayOfMonth *string `json:"day_of_month,omitempty"`

		// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
		DayOfWeek *string `json:"day_of_week,omitempty"`

		// Flags Flags
		Flags *[]V0041JobDescMsgCrontabFlags `json:"flags,omitempty"`

		// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
		Hour *string `json:"hour,omitempty"`
		Line *struct {
			// End End of this entry in file
			End *int32 `json:"end,omitempty"`

			// Start Start of this entry in file
			Start *int32 `json:"start,omitempty"`
		} `json:"line,omitempty"`

		// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
		Minute *string `json:"minute,omitempty"`

		// Month Ranged string specifying eligible month values (e.g. 0-5,12)
		Month *string `json:"month,omitempty"`

		// Specification Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
		Specification *string `json:"specification,omitempty"`
	} `json:"crontab,omitempty"`

	// CurrentWorkingDirectory Working directory to use for the job
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Deadline Latest time that the job may start (UNIX timestamp)
	Deadline *int64 `json:"deadline,omitempty"`

	// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
	DelayBoot *int32 `json:"delay_boot,omitempty"`

	// Dependency Other jobs that must meet certain criteria before this job can start
	Dependency *string `json:"dependency,omitempty"`

	// Distribution Layout
	Distribution *string `json:"distribution,omitempty"`

	// DistributionPlaneSize Plane size specification when distribution specifies plane
	DistributionPlaneSize *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"distribution_plane_size,omitempty"`

	// EndTime Expected end time (UNIX timestamp)
	EndTime *int64 `json:"end_time,omitempty"`

	// Environment Environment variables to be set for the job
	Environment *[]string `json:"environment,omitempty"`

	// ExcludedNodes Comma separated list of nodes that may not be used
	ExcludedNodes *[]string `json:"excluded_nodes,omitempty"`
	// Deprecated:
	Exclusive *[]V0041JobDescMsgExclusive `json:"exclusive,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// Flags Job flags
	Flags *[]V0041JobDescMsgFlags `json:"flags,omitempty"`

	// GroupId Group ID of the user that owns the job
	GroupId *string `json:"group_id,omitempty"`

	// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
	HetjobGroup *int32 `json:"hetjob_group,omitempty"`

	// Hold Hold (true) or release (false) job
	Hold *bool `json:"hold,omitempty"`

	// Immediate If true, exit if resources are not available within the time period specified
	Immediate *bool `json:"immediate,omitempty"`

	// JobId Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// KillOnNodeFail If true, kill job on node failure
	KillOnNodeFail *bool `json:"kill_on_node_fail,omitempty"`

	// KillWarningDelay Number of seconds before end time to send the warning signal
	KillWarningDelay *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"kill_warning_delay,omitempty"`

	// KillWarningFlags Flags related to job signals
	KillWarningFlags *[]V0041JobDescMsgKillWarningFlags `json:"kill_warning_flags,omitempty"`

	// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
	KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

	// Licenses License(s) required by the job
	Licenses *string `json:"licenses,omitempty"`

	// MailType Mail event type(s)
	MailType *[]V0041JobDescMsgMailType `json:"mail_type,omitempty"`

	// MailUser User to receive email notifications
	MailUser *string `json:"mail_user,omitempty"`

	// MaximumCpus Maximum number of CPUs required
	MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

	// MaximumNodes Maximum node count
	MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

	// McsLabel Multi-Category Security label on the job
	McsLabel *string `json:"mcs_label,omitempty"`

	// MemoryBinding Binding map for map/mask_cpu
	MemoryBinding *string `json:"memory_binding,omitempty"`

	// MemoryBindingType Method for binding tasks to memory
	MemoryBindingType *[]V0041JobDescMsgMemoryBindingType `json:"memory_binding_type,omitempty"`

	// MemoryPerCpu Minimum memory in megabytes per allocated CPU
	MemoryPerCpu *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"memory_per_cpu,omitempty"`

	// MemoryPerNode Minimum memory in megabytes per allocated CPU
	MemoryPerNode *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"memory_per_node,omitempty"`

	// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
	MemoryPerTres *string `json:"memory_per_tres,omitempty"`

	// MinimumBoardsPerNode Boards per node required
	MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

	// MinimumCpus Minimum number of CPUs required
	MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

	// MinimumCpusPerNode Minimum number of CPUs per node
	MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

	// MinimumNodes Minimum node count
	MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

	// MinimumSocketsPerBoard Sockets per board required
	MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

	// Name Job name
	Name *string `json:"name,omitempty"`

	// Network Network specs for job step
	Network *string `json:"network,omitempty"`

	// Nice Requested job priority change
	Nice *int32 `json:"nice,omitempty"`

	// Nodes Node count range specification (e.g. 1-15:4)
	Nodes *string `json:"nodes,omitempty"`

	// NtasksPerTres Number of tasks that can access each GPU
	NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

	// OpenMode Open mode used for stdout and stderr files
	OpenMode *[]V0041JobDescMsgOpenMode `json:"open_mode,omitempty"`

	// Overcommit Overcommit resources
	Overcommit *bool `json:"overcommit,omitempty"`
	// Deprecated:
	Oversubscribe *bool `json:"oversubscribe,omitempty"`

	// Partition Partition assigned to the job
	Partition *string `json:"partition,omitempty"`
	// Deprecated:
	PowerFlags *[]interface{} `json:"power_flags,omitempty"`

	// Prefer Comma separated list of features that are preferred but not required
	Prefer *string `json:"prefer,omitempty"`

	// Priority Request specific job priority
	Priority *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"priority,omitempty"`

	// Profile Profile used by the acct_gather_profile plugin
	Profile *[]V0041JobDescMsgProfile `json:"profile,omitempty"`

	// Qos Quality of Service assigned to the job
	Qos *string `json:"qos,omitempty"`

	// Reboot Node reboot requested before start
	Reboot *bool `json:"reboot,omitempty"`

	// Requeue Determines whether the job may be requeued
	Requeue *bool `json:"requeue,omitempty"`

	// RequiredNodes Comma separated list of required nodes
	RequiredNodes *[]string `json:"required_nodes,omitempty"`

	// RequiredSwitches Maximum number of switches
	RequiredSwitches *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"required_switches,omitempty"`

	// Reservation Name of reservation to use
	Reservation *string `json:"reservation,omitempty"`

	// ReservePorts Port to send various notification msg to
	ReservePorts *int32 `json:"reserve_ports,omitempty"`

	// ResvMpiPorts Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
	ResvMpiPorts *int32 `json:"resv_mpi_ports,omitempty"`
	Rlimits      *struct {
		// As Address space limit.
		As *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"as,omitempty"`

		// Core Largest core file that can be created, in bytes.
		Core *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"core,omitempty"`

		// Cpu Per-process CPU limit, in seconds.
		Cpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpu,omitempty"`

		// Data Maximum size of data segment, in bytes.
		Data *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"data,omitempty"`

		// Fsize Largest file that can be created, in bytes.
		Fsize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"fsize,omitempty"`

		// Memlock Locked-in-memory address space
		Memlock *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memlock,omitempty"`

		// Nofile Number of open files.
		Nofile *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"nofile,omitempty"`

		// Nproc Number of processes.
		Nproc *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"nproc,omitempty"`

		// Rss Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size will be more likely to have physical memory taken from them.
		Rss *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"rss,omitempty"`

		// Stack Maximum size of stack segment, in bytes.
		Stack *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"stack,omitempty"`
	} `json:"rlimits,omitempty"`

	// Script Job batch script; only the first component in a HetJob is populated or honored
	Script *string `json:"script,omitempty"`

	// SegmentSize Segment size for topology/block
	SegmentSize *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"segment_size,omitempty"`

	// SelinuxContext SELinux context
	SelinuxContext *string `json:"selinux_context,omitempty"`

	// Shared How the job can share resources with other jobs, if at all
	Shared *[]V0041JobDescMsgShared `json:"shared,omitempty"`

	// SiteFactor Site-specific priority factor
	SiteFactor *int32 `json:"site_factor,omitempty"`

	// SocketsPerNode Sockets per node required
	SocketsPerNode *int32 `json:"sockets_per_node,omitempty"`

	// SpankEnvironment Environment variables for job prolog/epilog scripts as set by SPANK plugins
	SpankEnvironment *[]string `json:"spank_environment,omitempty"`

	// StandardError Path to stderr file
	StandardError *string `json:"standard_error,omitempty"`

	// StandardInput Path to stdin file
	StandardInput *string `json:"standard_input,omitempty"`

	// StandardOutput Path to stdout file
	StandardOutput *string `json:"standard_output,omitempty"`

	// Tasks Number of tasks
	Tasks *int32 `json:"tasks,omitempty"`

	// TasksPerBoard Number of tasks to invoke on each board
	TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

	// TasksPerCore Number of tasks to invoke on each core
	TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

	// TasksPerNode Number of tasks to invoke on each node
	TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

	// TasksPerSocket Number of tasks to invoke on each socket
	TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

	// TemporaryDiskPerNode Minimum tmp disk space required per node
	TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

	// ThreadSpecification Specialized thread count
	ThreadSpecification *int32 `json:"thread_specification,omitempty"`

	// ThreadsPerCore Threads per core required
	ThreadsPerCore *int32 `json:"threads_per_core,omitempty"`

	// TimeLimit Maximum run time in minutes
	TimeLimit *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"time_limit,omitempty"`

	// TimeMinimum Minimum run time in minutes
	TimeMinimum *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"time_minimum,omitempty"`

	// TresBind Task to TRES binding directives
	TresBind *string `json:"tres_bind,omitempty"`

	// TresFreq TRES frequency directives
	TresFreq *string `json:"tres_freq,omitempty"`

	// TresPerJob Comma separated list of TRES=# values to be allocated for every job
	TresPerJob *string `json:"tres_per_job,omitempty"`

	// TresPerNode Comma separated list of TRES=# values to be allocated for every node
	TresPerNode *string `json:"tres_per_node,omitempty"`

	// TresPerSocket Comma separated list of TRES=# values to be allocated for every socket
	TresPerSocket *string `json:"tres_per_socket,omitempty"`

	// TresPerTask Comma separated list of TRES=# values to be allocated for every task
	TresPerTask *string `json:"tres_per_task,omitempty"`

	// UserId User ID that owns the job
	UserId *string `json:"user_id,omitempty"`

	// WaitAllNodes If true, wait to start until after all nodes have booted
	WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

	// WaitForSwitch Maximum time to wait for switches in seconds
	WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

	// Wckey Workload characterization key
	Wckey *string `json:"wckey,omitempty"`

	// X11 X11 forwarding options
	X11 *[]V0041JobDescMsgX11 `json:"x11,omitempty"`

	// X11MagicCookie Magic cookie for X11 forwarding
	X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

	// X11TargetHost Hostname or UNIX socket if x11_target_port=0
	X11TargetHost *string `json:"x11_target_host,omitempty"`

	// X11TargetPort TCP port
	X11TargetPort *int32 `json:"x11_target_port,omitempty"`
}

// V0041JobDescMsgCpuBindingFlags defines model for V0041JobDescMsg.CpuBindingFlags.
type V0041JobDescMsgCpuBindingFlags string

// V0041JobDescMsgCrontabFlags defines model for V0041JobDescMsg.Crontab.Flags.
type V0041JobDescMsgCrontabFlags string

// V0041JobDescMsgExclusive defines model for V0041JobDescMsg.Exclusive.
type V0041JobDescMsgExclusive string

// V0041JobDescMsgFlags defines model for V0041JobDescMsg.Flags.
type V0041JobDescMsgFlags string

// V0041JobDescMsgKillWarningFlags defines model for V0041JobDescMsg.KillWarningFlags.
type V0041JobDescMsgKillWarningFlags string

// V0041JobDescMsgMailType defines model for V0041JobDescMsg.MailType.
type V0041JobDescMsgMailType string

// V0041JobDescMsgMemoryBindingType defines model for V0041JobDescMsg.MemoryBindingType.
type V0041JobDescMsgMemoryBindingType string

// V0041JobDescMsgOpenMode defines model for V0041JobDescMsg.OpenMode.
type V0041JobDescMsgOpenMode string

// V0041JobDescMsgProfile defines model for V0041JobDescMsg.Profile.
type V0041JobDescMsgProfile string

// V0041JobDescMsgShared defines model for V0041JobDescMsg.Shared.
type V0041JobDescMsgShared string

// V0041JobDescMsgX11 defines model for V0041JobDescMsg.X11.
type V0041JobDescMsgX11 string

// V0041JobSubmitReq defines model for v0.0.41_job_submit_req.
type V0041JobSubmitReq struct {
	Job *V0041JobDescMsg `json:"job,omitempty"`

	// Jobs HetJob description
	Jobs *[]V0041JobDescMsg `json:"jobs,omitempty"`

	// Script Deprecated; Populate script field in jobs[0] or job
	// Deprecated:
	Script *string `json:"script,omitempty"`
}

// V0041KillJobsMsg defines model for v0.0.41_kill_jobs_msg.
type V0041KillJobsMsg struct {
	// Account Filter jobs to a specific account
	Account *string `json:"account,omitempty"`

	// Flags Filter jobs according to flags
	Flags *[]V0041KillJobsMsgFlags `json:"flags,omitempty"`

	// JobName Filter jobs to a specific name
	JobName *string `json:"job_name,omitempty"`

	// JobState Filter jobs to a specific state
	JobState *[]V0041KillJobsMsgJobState `json:"job_state,omitempty"`

	// Jobs List of jobs to signal
	Jobs *[]string `json:"jobs,omitempty"`

	// Nodes Filter jobs to a set of nodes
	Nodes *[]string `json:"nodes,omitempty"`

	// Partition Filter jobs to a specific partition
	Partition *string `json:"partition,omitempty"`

	// Qos Filter jobs to a specific QOS
	Qos *string `json:"qos,omitempty"`

	// Reservation Filter jobs to a specific reservation
	Reservation *string `json:"reservation,omitempty"`

	// Signal Signal to send to jobs
	Signal *string `json:"signal,omitempty"`

	// UserId Filter jobs to a specific numeric user id
	UserId *string `json:"user_id,omitempty"`

	// UserName Filter jobs to a specific user name
	UserName *string `json:"user_name,omitempty"`

	// Wckey Filter jobs to a specific wckey
	Wckey *string `json:"wckey,omitempty"`
}

// V0041KillJobsMsgFlags defines model for V0041KillJobsMsg.Flags.
type V0041KillJobsMsgFlags string

// V0041KillJobsMsgJobState defines model for V0041KillJobsMsg.JobState.
type V0041KillJobsMsgJobState string

// V0041OpenapiAccountsAddCondResp defines model for v0.0.41_openapi_accounts_add_cond_resp.
type V0041OpenapiAccountsAddCondResp struct {
	// Account Account organization and description
	Account *struct {
		// Description Arbitrary string describing the account
		Description *string `json:"description,omitempty"`

		// Organization Organization to which the account belongs
		Organization *string `json:"organization,omitempty"`
	} `json:"account,omitempty"`

	// AssociationCondition CSV list of accounts, association limits and options, CSV list of clusters
	AssociationCondition *struct {
		// Accounts CSV accounts list
		Accounts []string `json:"accounts"`

		// Association Association limits and options
		Association *struct {
			// Comment Arbitrary comment
			Comment *string `json:"comment,omitempty"`

			// Defaultqos Default QOS
			Defaultqos *string `json:"defaultqos,omitempty"`

			// Fairshare Allocated shares used for fairshare calculation
			Fairshare *int32 `json:"fairshare,omitempty"`

			// Grpjobs Maximum number of running jobs in this association and its children
			Grpjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpjobs,omitempty"`

			// Grpjobsaccrue Maximum number of pending jobs able to accrue age priority in this association and its children
			Grpjobsaccrue *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpjobsaccrue,omitempty"`

			// Grpsubmitjobs Maximum number of jobs which can be in a pending or running state at any time in this association and its children
			Grpsubmitjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpsubmitjobs,omitempty"`

			// Grptres Maximum number of TRES able to be allocated by running jobs in this association and its children
			Grptres *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptres,omitempty"`

			// Grptresmins Total number of TRES minutes that can possibly be used by past, present and future jobs in this association and its children
			Grptresmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptresmins,omitempty"`

			// Grptresrunmins Maximum number of TRES minutes able to be allocated by running jobs in this association and its children
			Grptresrunmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptresrunmins,omitempty"`

			// Grpwall Maximum wall clock time in minutes able to be allocated by running jobs in this association and its children
			Grpwall *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpwall,omitempty"`

			// Maxjobs Maximum number of running jobs per user in this association
			Maxjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxjobs,omitempty"`

			// Maxjobsaccrue Maximum number of pending jobs able to accrue age priority at any given time in this association
			Maxjobsaccrue *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxjobsaccrue,omitempty"`

			// Maxsubmitjobs Maximum number of jobs which can be in a pending or running state at any time in this association
			Maxsubmitjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxsubmitjobs,omitempty"`

			// Maxtresminsperjob Maximum number of TRES minutes each job is able to use in this association
			Maxtresminsperjob *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresminsperjob,omitempty"`

			// Maxtresperjob Maximum number of TRES each job is able to use in this association
			Maxtresperjob *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresperjob,omitempty"`

			// Maxtrespernode Maximum number of TRES each node is able to use
			Maxtrespernode *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtrespernode,omitempty"`

			// Maxtresrunmins Maximum number of TRES minutes able to be allocated by running jobs in this association
			Maxtresrunmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresrunmins,omitempty"`

			// Maxwalldurationperjob Maximum wall clock time each job is able to use in this association
			Maxwalldurationperjob *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxwalldurationperjob,omitempty"`

			// Minpriothresh Minimum priority required to reserve resources when scheduling
			Minpriothresh *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minpriothresh,omitempty"`

			// Parent Name of parent account
			Parent *string `json:"parent,omitempty"`

			// Priority Association priority factor
			Priority *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority,omitempty"`

			// Qoslevel List of available QOS names
			Qoslevel *[]string `json:"qoslevel,omitempty"`
		} `json:"association,omitempty"`

		// Clusters CSV clusters list
		Clusters *[]string `json:"clusters,omitempty"`
	} `json:"association_condition,omitempty"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiAccountsAddCondRespStr defines model for v0.0.41_openapi_accounts_add_cond_resp_str.
type V0041OpenapiAccountsAddCondRespStr struct {
	// AddedAccounts added_accounts
	AddedAccounts string `json:"added_accounts"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiAccountsRemovedResp defines model for v0.0.41_openapi_accounts_removed_resp.
type V0041OpenapiAccountsRemovedResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// RemovedAccounts removed_accounts
	RemovedAccounts []string `json:"removed_accounts"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiAccountsResp defines model for v0.0.41_openapi_accounts_resp.
type V0041OpenapiAccountsResp struct {
	// Accounts accounts
	Accounts []struct {
		// Associations Associations involving this account (only populated if requested)
		Associations *[]struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"associations,omitempty"`

		// Coordinators List of users that are a coordinator of this account (only populated if requested)
		Coordinators *[]struct {
			// Direct Indicates whether the coordinator was directly assigned to this account
			Direct *bool `json:"direct,omitempty"`

			// Name User name
			Name string `json:"name"`
		} `json:"coordinators,omitempty"`

		// Description Arbitrary string describing the account
		Description string `json:"description"`

		// Flags Flags associated with the account
		Flags *[]V0041OpenapiAccountsRespAccountsFlags `json:"flags,omitempty"`

		// Name Account name
		Name string `json:"name"`

		// Organization Organization to which the account belongs
		Organization string `json:"organization"`
	} `json:"accounts"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiAccountsRespAccountsFlags defines model for V0041OpenapiAccountsResp.Accounts.Flags.
type V0041OpenapiAccountsRespAccountsFlags string

// V0041OpenapiAssocsRemovedResp defines model for v0.0.41_openapi_assocs_removed_resp.
type V0041OpenapiAssocsRemovedResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// RemovedAssociations removed_associations
	RemovedAssociations []string `json:"removed_associations"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiAssocsResp defines model for v0.0.41_openapi_assocs_resp.
type V0041OpenapiAssocsResp struct {
	// Associations associations
	Associations []struct {
		// Account Account
		Account *string `json:"account,omitempty"`

		// Accounting Accounting records containing related resource usage
		Accounting *[]struct {
			// TRES Trackable resources
			TRES *struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"TRES,omitempty"`
			Allocated *struct {
				// Seconds Number of cpu seconds allocated
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"allocated,omitempty"`

			// Id Association ID or Workload characterization key ID
			Id *int32 `json:"id,omitempty"`

			// Start When the record was started
			Start *int64 `json:"start,omitempty"`
		} `json:"accounting,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Comment Arbitrary comment
		Comment *string `json:"comment,omitempty"`
		Default *struct {
			// Qos Default QOS
			Qos *string `json:"qos,omitempty"`
		} `json:"default,omitempty"`

		// Flags Flags on the association
		Flags *[]V0041OpenapiAssocsRespAssociationsFlags `json:"flags,omitempty"`

		// Id Unique ID
		Id *int32 `json:"id,omitempty"`

		// IsDefault Is default association for user
		IsDefault *bool `json:"is_default,omitempty"`

		// Lineage Complete path up the hierarchy to the root association
		Lineage *string `json:"lineage,omitempty"`
		Max     *struct {
			Jobs *struct {
				// Accruing MaxJobsAccrue
				Accruing *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"accruing,omitempty"`

				// Active MaxJobs
				Active *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"active,omitempty"`
				Per *struct {
					// Accruing GrpJobsAccrue
					Accruing *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"accruing,omitempty"`

					// Count GrpJobs
					Count *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"count,omitempty"`

					// Submitted GrpSubmitJobs
					Submitted *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"submitted,omitempty"`

					// WallClock MaxWallDurationPerJob
					WallClock *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"wall_clock,omitempty"`
				} `json:"per,omitempty"`

				// Total MaxSubmitJobs
				Total *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"total,omitempty"`
			} `json:"jobs,omitempty"`
			Per *struct {
				Account *struct {
					// WallClock GrpWall
					WallClock *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"wall_clock,omitempty"`
				} `json:"account,omitempty"`
			} `json:"per,omitempty"`
			Tres *struct {
				Group *struct {
					// Active GrpTRESRunMins
					Active *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"active,omitempty"`

					// Minutes GrpTRESMins
					Minutes *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"minutes,omitempty"`
				} `json:"group,omitempty"`
				Minutes *struct {
					Per *struct {
						// Job MaxTRESMinsPerJob
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`
					} `json:"per,omitempty"`

					// Total MaxTRESMinsPerJob
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"minutes,omitempty"`
				Per *struct {
					// Job MaxTRESPerJob
					Job *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"job,omitempty"`

					// Node MaxTRESPerNode
					Node *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"node,omitempty"`
				} `json:"per,omitempty"`

				// Total GrpTRES
				Total *[]struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"total,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"max,omitempty"`
		Min *struct {
			// PriorityThreshold MinPrioThreshold
			PriorityThreshold *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority_threshold,omitempty"`
		} `json:"min,omitempty"`

		// ParentAccount Name of parent account
		ParentAccount *string `json:"parent_account,omitempty"`

		// Partition Partition name
		Partition *string `json:"partition,omitempty"`

		// Priority Association priority factor
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Qos List of available QOS names
		Qos *[]string `json:"qos,omitempty"`

		// SharesRaw Allocated shares used for fairshare calculation
		SharesRaw *int32 `json:"shares_raw,omitempty"`

		// User User name
		User string `json:"user"`
	} `json:"associations"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiAssocsRespAssociationsFlags defines model for V0041OpenapiAssocsResp.Associations.Flags.
type V0041OpenapiAssocsRespAssociationsFlags string

// V0041OpenapiClustersRemovedResp defines model for v0.0.41_openapi_clusters_removed_resp.
type V0041OpenapiClustersRemovedResp struct {
	// DeletedClusters deleted_clusters
	DeletedClusters []string `json:"deleted_clusters"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiClustersResp defines model for v0.0.41_openapi_clusters_resp.
type V0041OpenapiClustersResp struct {
	// Clusters clusters
	Clusters []struct {
		Associations *struct {
			// Root Root association information
			Root *struct {
				// Account Account
				Account *string `json:"account,omitempty"`

				// Cluster Cluster
				Cluster *string `json:"cluster,omitempty"`

				// Id Numeric association ID
				Id *int32 `json:"id,omitempty"`

				// Partition Partition
				Partition *string `json:"partition,omitempty"`

				// User User name
				User string `json:"user"`
			} `json:"root,omitempty"`
		} `json:"associations,omitempty"`
		Controller *struct {
			// Host ControlHost
			Host *string `json:"host,omitempty"`

			// Port ControlPort
			Port *int32 `json:"port,omitempty"`
		} `json:"controller,omitempty"`

		// Flags Flags
		Flags *[]V0041OpenapiClustersRespClustersFlags `json:"flags,omitempty"`

		// Name ClusterName
		Name *string `json:"name,omitempty"`

		// Nodes Node names
		Nodes *string `json:"nodes,omitempty"`

		// RpcVersion RPC version used in the cluster
		RpcVersion *int32 `json:"rpc_version,omitempty"`
		// Deprecated:
		SelectPlugin *string `json:"select_plugin,omitempty"`

		// Tres Trackable resources
		Tres *[]struct {
			// Count TRES count (0 if listed generically)
			Count *int64 `json:"count,omitempty"`

			// Id ID used in database
			Id *int32 `json:"id,omitempty"`

			// Name TRES name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type TRES type (CPU, MEM, etc)
			Type string `json:"type"`
		} `json:"tres,omitempty"`
	} `json:"clusters"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiClustersRespClustersFlags defines model for V0041OpenapiClustersResp.Clusters.Flags.
type V0041OpenapiClustersRespClustersFlags string

// V0041OpenapiDiagResp defines model for v0.0.41_openapi_diag_resp.
type V0041OpenapiDiagResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Statistics statistics
	Statistics struct {
		// AgentCount Number of agent threads
		AgentCount *int32 `json:"agent_count,omitempty"`

		// AgentQueueSize Number of enqueued outgoing RPC requests in an internal retry list
		AgentQueueSize *int32 `json:"agent_queue_size,omitempty"`

		// AgentThreadCount Total number of active threads created by all agent threads
		AgentThreadCount *int32 `json:"agent_thread_count,omitempty"`

		// BfActive Backfill scheduler currently running
		BfActive *bool `json:"bf_active,omitempty"`

		// BfBackfilledHetJobs Number of heterogeneous job components started through backfilling since last Slurm start
		BfBackfilledHetJobs *int32 `json:"bf_backfilled_het_jobs,omitempty"`

		// BfBackfilledJobs Number of jobs started through backfilling since last slurm start
		BfBackfilledJobs *int32 `json:"bf_backfilled_jobs,omitempty"`

		// BfCycleCounter Number of backfill scheduling cycles since last reset
		BfCycleCounter *int32 `json:"bf_cycle_counter,omitempty"`

		// BfCycleLast Execution time in microseconds of last backfill scheduling cycle
		BfCycleLast *int32 `json:"bf_cycle_last,omitempty"`

		// BfCycleMax Execution time in microseconds of longest backfill scheduling cycle
		BfCycleMax *int32 `json:"bf_cycle_max,omitempty"`

		// BfCycleMean Mean time in microseconds of backfilling scheduling cycles since last reset
		BfCycleMean *int64 `json:"bf_cycle_mean,omitempty"`

		// BfCycleSum Total time in microseconds of backfilling scheduling cycles since last reset
		BfCycleSum *int64 `json:"bf_cycle_sum,omitempty"`

		// BfDepthMean Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
		BfDepthMean *int64 `json:"bf_depth_mean,omitempty"`

		// BfDepthMeanTry The subset of Depth Mean that the backfill scheduler attempted to schedule
		BfDepthMeanTry *int64 `json:"bf_depth_mean_try,omitempty"`

		// BfDepthSum Total number of jobs processed during all backfilling scheduling cycles since last reset
		BfDepthSum *int32 `json:"bf_depth_sum,omitempty"`

		// BfDepthTrySum Subset of bf_depth_sum that the backfill scheduler attempted to schedule
		BfDepthTrySum *int32 `json:"bf_depth_try_sum,omitempty"`

		// BfExit Reasons for which the backfill scheduling cycle exited since last reset
		BfExit *struct {
			// BfMaxJobStart Reached number of jobs allowed to start
			BfMaxJobStart *int32 `json:"bf_max_job_start,omitempty"`

			// BfMaxJobTest Reached number of jobs allowed to be tested
			BfMaxJobTest *int32 `json:"bf_max_job_test,omitempty"`

			// BfMaxTime Reached maximum allowed scheduler time
			BfMaxTime *int32 `json:"bf_max_time,omitempty"`

			// BfNodeSpaceSize Reached table size limit
			BfNodeSpaceSize *int32 `json:"bf_node_space_size,omitempty"`

			// EndJobQueue Reached end of queue
			EndJobQueue *int32 `json:"end_job_queue,omitempty"`

			// StateChanged System state changed
			StateChanged *int32 `json:"state_changed,omitempty"`
		} `json:"bf_exit,omitempty"`

		// BfLastBackfilledJobs Number of jobs started through backfilling since last reset
		BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`

		// BfLastDepth Number of processed jobs during last backfilling scheduling cycle
		BfLastDepth *int32 `json:"bf_last_depth,omitempty"`

		// BfLastDepthTry Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
		BfLastDepthTry *int32 `json:"bf_last_depth_try,omitempty"`

		// BfQueueLen Number of jobs pending to be processed by backfilling algorithm
		BfQueueLen *int32 `json:"bf_queue_len,omitempty"`

		// BfQueueLenMean Mean number of jobs pending to be processed by backfilling algorithm
		BfQueueLenMean *int64 `json:"bf_queue_len_mean,omitempty"`

		// BfQueueLenSum Total number of jobs pending to be processed by backfilling algorithm since last reset
		BfQueueLenSum *int32 `json:"bf_queue_len_sum,omitempty"`

		// BfTableSize Number of different time slots tested by the backfill scheduler in its last iteration
		BfTableSize *int32 `json:"bf_table_size,omitempty"`

		// BfTableSizeMean Mean number of different time slots tested by the backfill scheduler
		BfTableSizeMean *int64 `json:"bf_table_size_mean,omitempty"`

		// BfTableSizeSum Total number of different time slots tested by the backfill scheduler
		BfTableSizeSum *int32 `json:"bf_table_size_sum,omitempty"`

		// BfWhenLastCycle When the last backfill scheduling cycle happened (UNIX timestamp)
		BfWhenLastCycle *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"bf_when_last_cycle,omitempty"`

		// DbdAgentQueueSize Number of messages for SlurmDBD that are queued
		DbdAgentQueueSize *int32 `json:"dbd_agent_queue_size,omitempty"`

		// GettimeofdayLatency Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
		GettimeofdayLatency *int32 `json:"gettimeofday_latency,omitempty"`

		// JobStatesTs When the job state counts were gathered (UNIX timestamp)
		JobStatesTs *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"job_states_ts,omitempty"`

		// JobsCanceled Number of jobs canceled since the last reset
		JobsCanceled *int32 `json:"jobs_canceled,omitempty"`

		// JobsCompleted Number of jobs completed since last reset
		JobsCompleted *int32 `json:"jobs_completed,omitempty"`

		// JobsFailed Number of jobs failed due to slurmd or other internal issues since last reset
		JobsFailed *int32 `json:"jobs_failed,omitempty"`

		// JobsPending Number of jobs pending at the time of listed in job_state_ts
		JobsPending *int32 `json:"jobs_pending,omitempty"`

		// JobsRunning Number of jobs running at the time of listed in job_state_ts
		JobsRunning *int32 `json:"jobs_running,omitempty"`

		// JobsStarted Number of jobs started since last reset
		JobsStarted *int32 `json:"jobs_started,omitempty"`

		// JobsSubmitted Number of jobs submitted since last reset
		JobsSubmitted *int32 `json:"jobs_submitted,omitempty"`

		// PartsPacked Zero if only RPC statistic included
		PartsPacked *int32 `json:"parts_packed,omitempty"`

		// PendingRpcs Pending RPC statistics
		PendingRpcs *[]struct {
			// Count Number of pending RPCs queued
			Count int32 `json:"count"`

			// MessageType Message type as string
			MessageType string `json:"message_type"`

			// TypeId Message type as integer
			TypeId int32 `json:"type_id"`
		} `json:"pending_rpcs,omitempty"`

		// PendingRpcsByHostlist Pending RPCs hostlists
		PendingRpcsByHostlist *[]struct {
			// Count Number of RPCs received
			Count []string `json:"count"`

			// MessageType Message type as string
			MessageType string `json:"message_type"`

			// TypeId Message type as integer
			TypeId int32 `json:"type_id"`
		} `json:"pending_rpcs_by_hostlist,omitempty"`

		// ReqTime When the request was made (UNIX timestamp)
		ReqTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"req_time,omitempty"`

		// ReqTimeStart When the data in the report started (UNIX timestamp)
		ReqTimeStart *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"req_time_start,omitempty"`

		// RpcsByMessageType Most frequently issued remote procedure calls (RPCs)
		RpcsByMessageType *[]struct {
			// AverageTime Average time spent processing RPC in seconds
			AverageTime struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"average_time"`

			// Count Number of RPCs received
			Count int32 `json:"count"`

			// CycleLast Number of RPCs processed within the last RPC queue cycle
			CycleLast int32 `json:"cycle_last"`

			// CycleMax Maximum number of RPCs processed within a RPC queue cycle since start
			CycleMax int32 `json:"cycle_max"`

			// Dropped Number of RPCs dropped
			Dropped int64 `json:"dropped"`

			// MessageType Message type as string
			MessageType string `json:"message_type"`

			// Queued Number of RPCs queued
			Queued int32 `json:"queued"`

			// TotalTime Total time spent processing RPC in seconds
			TotalTime int64 `json:"total_time"`

			// TypeId Message type as integer
			TypeId int32 `json:"type_id"`
		} `json:"rpcs_by_message_type,omitempty"`

		// RpcsByUser RPCs issued by user ID
		RpcsByUser *[]struct {
			// AverageTime Average time spent processing RPC in seconds
			AverageTime struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"average_time"`

			// Count Number of RPCs received
			Count int32 `json:"count"`

			// TotalTime Total time spent processing RPC in seconds
			TotalTime int64 `json:"total_time"`

			// User User name
			User string `json:"user"`

			// UserId User ID (numeric)
			UserId int32 `json:"user_id"`
		} `json:"rpcs_by_user,omitempty"`

		// ScheduleCycleDepth Total number of jobs processed in scheduling cycles
		ScheduleCycleDepth *int32 `json:"schedule_cycle_depth,omitempty"`

		// ScheduleCycleLast Time in microseconds for last scheduling cycle
		ScheduleCycleLast *int32 `json:"schedule_cycle_last,omitempty"`

		// ScheduleCycleMax Max time of any scheduling cycle in microseconds since last reset
		ScheduleCycleMax *int32 `json:"schedule_cycle_max,omitempty"`

		// ScheduleCycleMean Mean time in microseconds for all scheduling cycles since last reset
		ScheduleCycleMean *int64 `json:"schedule_cycle_mean,omitempty"`

		// ScheduleCycleMeanDepth Mean of the number of jobs processed in a scheduling cycle
		ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`

		// ScheduleCyclePerMinute Number of scheduling executions per minute
		ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`

		// ScheduleCycleSum Total run time in microseconds for all scheduling cycles since last reset
		ScheduleCycleSum *int32 `json:"schedule_cycle_sum,omitempty"`

		// ScheduleCycleTotal Number of scheduling cycles since last reset
		ScheduleCycleTotal *int32 `json:"schedule_cycle_total,omitempty"`

		// ScheduleExit Reasons for which the scheduling cycle exited since last reset
		ScheduleExit *struct {
			// DefaultQueueDepth Reached number of jobs allowed to be tested
			DefaultQueueDepth *int32 `json:"default_queue_depth,omitempty"`

			// EndJobQueue Reached end of queue
			EndJobQueue *int32 `json:"end_job_queue,omitempty"`

			// Licenses Blocked on licenses
			Licenses *int32 `json:"licenses,omitempty"`

			// MaxJobStart Reached number of jobs allowed to start
			MaxJobStart *int32 `json:"max_job_start,omitempty"`

			// MaxRpcCnt Reached RPC limit
			MaxRpcCnt *int32 `json:"max_rpc_cnt,omitempty"`

			// MaxSchedTime Reached maximum allowed scheduler time
			MaxSchedTime *int32 `json:"max_sched_time,omitempty"`
		} `json:"schedule_exit,omitempty"`

		// ScheduleQueueLength Number of jobs pending in queue
		ScheduleQueueLength *int32 `json:"schedule_queue_length,omitempty"`

		// ServerThreadCount Number of current active slurmctld threads
		ServerThreadCount *int32 `json:"server_thread_count,omitempty"`
	} `json:"statistics"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiInstancesResp defines model for v0.0.41_openapi_instances_resp.
type V0041OpenapiInstancesResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Instances instances
	Instances []struct {
		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// InstanceId Cloud instance ID
		InstanceId *string `json:"instance_id,omitempty"`

		// InstanceType Cloud instance type
		InstanceType *string `json:"instance_type,omitempty"`

		// NodeName NodeName
		NodeName *string `json:"node_name,omitempty"`
		Time     *struct {
			// TimeEnd When the instance will end (UNIX timestamp)
			TimeEnd *int64 `json:"time_end,omitempty"`

			// TimeStart When the instance will start (UNIX timestamp)
			TimeStart *int64 `json:"time_start,omitempty"`
		} `json:"time,omitempty"`
	} `json:"instances"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiJobAllocResp defines model for v0.0.41_openapi_job_alloc_resp.
type V0041OpenapiJobAllocResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// JobId Submitted Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// JobSubmitUserMsg Job submission user message
	JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiJobInfoResp defines model for v0.0.41_openapi_job_info_resp.
type V0041OpenapiJobInfoResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Jobs List of jobs
	Jobs []struct {
		// Account Account associated with the job
		Account *string `json:"account,omitempty"`

		// AccrueTime When the job started accruing age priority (UNIX timestamp)
		AccrueTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"accrue_time,omitempty"`

		// AdminComment Arbitrary comment made by administrator
		AdminComment *string `json:"admin_comment,omitempty"`

		// AllocatingNode Local node making the resource allocation
		AllocatingNode *string `json:"allocating_node,omitempty"`

		// ArrayJobId Job ID of job array, or 0 if N/A
		ArrayJobId *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"array_job_id,omitempty"`

		// ArrayMaxTasks Maximum number of simultaneously running array tasks, 0 if no limit
		ArrayMaxTasks *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"array_max_tasks,omitempty"`

		// ArrayTaskId Task ID of this task in job array
		ArrayTaskId *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"array_task_id,omitempty"`

		// ArrayTaskString String expression of task IDs in this record
		ArrayTaskString *string `json:"array_task_string,omitempty"`

		// AssociationId Unique identifier for the association
		AssociationId *int32 `json:"association_id,omitempty"`

		// BatchFeatures Features required for batch script's node
		BatchFeatures *string `json:"batch_features,omitempty"`

		// BatchFlag True if batch job
		BatchFlag *bool `json:"batch_flag,omitempty"`

		// BatchHost Name of host running batch script
		BatchHost *string `json:"batch_host,omitempty"`

		// BillableTres Billable TRES
		BillableTres *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"billable_tres,omitempty"`

		// BurstBuffer Burst buffer specifications
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// BurstBufferState Burst buffer state details
		BurstBufferState *string `json:"burst_buffer_state,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// ClusterFeatures List of required cluster features
		ClusterFeatures *string `json:"cluster_features,omitempty"`

		// Command Executed command
		Command *string `json:"command,omitempty"`

		// Comment Arbitrary comment
		Comment *string `json:"comment,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// ContainerId OCI container ID
		ContainerId *string `json:"container_id,omitempty"`

		// Contiguous True if job requires contiguous nodes
		Contiguous *bool `json:"contiguous,omitempty"`

		// CoreSpec Specialized core count
		CoreSpec *int32 `json:"core_spec,omitempty"`

		// CoresPerSocket Cores per socket required
		CoresPerSocket *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cores_per_socket,omitempty"`

		// CpuFrequencyGovernor CPU frequency governor
		CpuFrequencyGovernor *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpu_frequency_governor,omitempty"`

		// CpuFrequencyMaximum Maximum CPU frequency
		CpuFrequencyMaximum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpu_frequency_maximum,omitempty"`

		// CpuFrequencyMinimum Minimum CPU frequency
		CpuFrequencyMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpu_frequency_minimum,omitempty"`

		// Cpus Minimum number of CPUs required
		Cpus *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpus,omitempty"`

		// CpusPerTask Number of CPUs required by each task
		CpusPerTask *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpus_per_task,omitempty"`

		// CpusPerTres Semicolon delimited list of TRES=# values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
		CpusPerTres *string `json:"cpus_per_tres,omitempty"`

		// Cron Time specification for scrontab job
		Cron *string `json:"cron,omitempty"`

		// CurrentWorkingDirectory Working directory to use for the job
		CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

		// Deadline Latest time that the job may start (UNIX timestamp)
		Deadline *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"deadline,omitempty"`

		// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
		DelayBoot *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"delay_boot,omitempty"`

		// Dependency Other jobs that must meet certain criteria before this job can start
		Dependency *string `json:"dependency,omitempty"`

		// DerivedExitCode Highest exit code of all job steps
		DerivedExitCode *struct {
			// ReturnCode Process return code (numeric)
			ReturnCode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"return_code,omitempty"`
			Signal *struct {
				// Id Signal sent to process (numeric)
				Id *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"id,omitempty"`

				// Name Signal sent to process
				Name *string `json:"name,omitempty"`
			} `json:"signal,omitempty"`

			// Status Status given by return code
			Status *[]V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus `json:"status,omitempty"`
		} `json:"derived_exit_code,omitempty"`

		// EligibleTime Time when the job became eligible to run (UNIX timestamp)
		EligibleTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"eligible_time,omitempty"`

		// EndTime End time, real or expected (UNIX timestamp)
		EndTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"end_time,omitempty"`

		// ExcludedNodes Comma separated list of nodes that may not be used
		ExcludedNodes *string `json:"excluded_nodes,omitempty"`
		// Deprecated:
		Exclusive *[]V0041OpenapiJobInfoRespJobsExclusive `json:"exclusive,omitempty"`

		// ExitCode Exit code of the job
		ExitCode *struct {
			// ReturnCode Process return code (numeric)
			ReturnCode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"return_code,omitempty"`
			Signal *struct {
				// Id Signal sent to process (numeric)
				Id *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"id,omitempty"`

				// Name Signal sent to process
				Name *string `json:"name,omitempty"`
			} `json:"signal,omitempty"`

			// Status Status given by return code
			Status *[]V0041OpenapiJobInfoRespJobsExitCodeStatus `json:"status,omitempty"`
		} `json:"exit_code,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// FailedNode Name of node that caused job failure
		FailedNode *string `json:"failed_node,omitempty"`

		// Features Comma separated list of features that are required
		Features *string `json:"features,omitempty"`

		// FederationOrigin Origin cluster's name (when using federation)
		FederationOrigin *string `json:"federation_origin,omitempty"`

		// FederationSiblingsActive Active sibling job names
		FederationSiblingsActive *string `json:"federation_siblings_active,omitempty"`

		// FederationSiblingsViable Viable sibling job names
		FederationSiblingsViable *string `json:"federation_siblings_viable,omitempty"`

		// Flags Job flags
		Flags *[]V0041OpenapiJobInfoRespJobsFlags `json:"flags,omitempty"`

		// GresDetail List of GRES index and counts allocated per node
		GresDetail *[]string `json:"gres_detail,omitempty"`

		// GroupId Group ID of the user that owns the job
		GroupId *int32 `json:"group_id,omitempty"`

		// GroupName Group name of the user that owns the job
		GroupName *string `json:"group_name,omitempty"`

		// HetJobId Heterogeneous job ID, if applicable
		HetJobId *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"het_job_id,omitempty"`

		// HetJobIdSet Job ID range for all heterogeneous job components
		HetJobIdSet *string `json:"het_job_id_set,omitempty"`

		// HetJobOffset Unique sequence number applied to this component of the heterogeneous job
		HetJobOffset *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"het_job_offset,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// JobResources Resources used by the job
		JobResources *struct {
			// Cpus Number of allocated CPUs
			Cpus  int32 `json:"cpus"`
			Nodes *struct {
				// Allocation Allocated node resources
				Allocation *[]struct {
					Cpus *struct {
						// Count Total number of CPUs assigned to job
						Count *int32 `json:"count,omitempty"`

						// Used Total number of CPUs used by job
						Used *int32 `json:"used,omitempty"`
					} `json:"cpus,omitempty"`

					// Index Node index
					Index  int32 `json:"index"`
					Memory *struct {
						// Allocated Total memory (MiB) allocated to job
						Allocated *int64 `json:"allocated,omitempty"`

						// Used Total memory (MiB) used by job
						Used *int64 `json:"used,omitempty"`
					} `json:"memory,omitempty"`

					// Name Node name
					Name string `json:"name"`

					// Sockets Socket allocations in node
					Sockets []struct {
						// Cores Core in socket
						Cores []struct {
							// Index Core index
							Index int32 `json:"index"`

							// Status Core status
							Status []V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus `json:"status"`
						} `json:"cores"`

						// Index Core index
						Index int32 `json:"index"`
					} `json:"sockets"`
				} `json:"allocation,omitempty"`

				// Count Number of allocated nodes
				Count *int32 `json:"count,omitempty"`

				// List Node(s) allocated to the job
				List *string `json:"list,omitempty"`

				// SelectType Node scheduling selection method
				SelectType *[]V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType `json:"select_type,omitempty"`

				// Whole Whether whole nodes were allocated
				Whole *bool `json:"whole,omitempty"`
			} `json:"nodes,omitempty"`

			// SelectType Scheduler consumable resource selection type
			SelectType []V0041OpenapiJobInfoRespJobsJobResourcesSelectType `json:"select_type"`

			// ThreadsPerCore Number of processor threads per CPU core
			ThreadsPerCore struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"threads_per_core"`
		} `json:"job_resources,omitempty"`

		// JobSizeStr Number of nodes (in a range) required for this job
		JobSizeStr *[]string `json:"job_size_str,omitempty"`

		// JobState Current state
		JobState *[]V0041OpenapiJobInfoRespJobsJobState `json:"job_state,omitempty"`

		// LastSchedEvaluation Last time job was evaluated for scheduling (UNIX timestamp)
		LastSchedEvaluation *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"last_sched_evaluation,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`

		// MailType Mail event type(s)
		MailType *[]V0041OpenapiJobInfoRespJobsMailType `json:"mail_type,omitempty"`

		// MailUser User to receive email notifications
		MailUser *string `json:"mail_user,omitempty"`

		// MaxCpus Maximum number of CPUs usable by the job
		MaxCpus *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"max_cpus,omitempty"`

		// MaxNodes Maximum number of nodes usable by the job
		MaxNodes *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"max_nodes,omitempty"`

		// MaximumSwitchWaitTime Maximum time to wait for switches in seconds
		MaximumSwitchWaitTime *int32 `json:"maximum_switch_wait_time,omitempty"`

		// McsLabel Multi-Category Security label on the job
		McsLabel *string `json:"mcs_label,omitempty"`

		// MemoryPerCpu Minimum memory in megabytes per allocated CPU
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Minimum memory in megabytes per allocated node
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`

		// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
		MemoryPerTres *string `json:"memory_per_tres,omitempty"`

		// MinimumCpusPerNode Minimum number of CPUs per node
		MinimumCpusPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"minimum_cpus_per_node,omitempty"`

		// MinimumSwitches Maximum number of switches (the 'minimum' in the key is incorrect)
		MinimumSwitches *int32 `json:"minimum_switches,omitempty"`

		// MinimumTmpDiskPerNode Minimum tmp disk space required per node
		MinimumTmpDiskPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"minimum_tmp_disk_per_node,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Network Network specs for the job
		Network *string `json:"network,omitempty"`

		// Nice Requested job priority change
		Nice *int32 `json:"nice,omitempty"`

		// NodeCount Minimum number of nodes required
		NodeCount *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"node_count,omitempty"`

		// Nodes Node(s) allocated to the job
		Nodes *string `json:"nodes,omitempty"`
		// Deprecated:
		Oversubscribe *bool `json:"oversubscribe,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`
		Power     *struct {
			// Deprecated:
			Flags *[]interface{} `json:"flags,omitempty"`
		} `json:"power,omitempty"`

		// PreSusTime Total run time prior to last suspend in seconds
		PreSusTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"pre_sus_time,omitempty"`

		// PreemptTime Time job received preemption signal (UNIX timestamp)
		PreemptTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"preempt_time,omitempty"`

		// PreemptableTime Time job becomes eligible for preemption (UNIX timestamp)
		PreemptableTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"preemptable_time,omitempty"`

		// Prefer Feature(s) the job requested but that are not required
		Prefer *string `json:"prefer,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Profile Profile used by the acct_gather_profile plugin
		Profile *[]V0041OpenapiJobInfoRespJobsProfile `json:"profile,omitempty"`

		// Qos Quality of Service assigned to the job, if pending the QOS requested
		Qos *string `json:"qos,omitempty"`

		// Reboot Node reboot requested before start
		Reboot *bool `json:"reboot,omitempty"`

		// Requeue Determines whether the job may be requeued
		Requeue *bool `json:"requeue,omitempty"`

		// RequiredNodes Comma separated list of required nodes
		RequiredNodes *string `json:"required_nodes,omitempty"`

		// ResizeTime Time of last size change (UNIX timestamp)
		ResizeTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"resize_time,omitempty"`

		// RestartCnt Number of job restarts
		RestartCnt *int32 `json:"restart_cnt,omitempty"`

		// ResvName Name of reservation to use
		ResvName *string `json:"resv_name,omitempty"`

		// ScheduledNodes List of nodes scheduled to be used for the job
		ScheduledNodes *string `json:"scheduled_nodes,omitempty"`

		// SelinuxContext SELinux context
		SelinuxContext *string `json:"selinux_context,omitempty"`

		// Shared How the job can share resources with other jobs, if at all
		Shared *[]V0041OpenapiJobInfoRespJobsShared `json:"shared,omitempty"`
		// Deprecated:
		ShowFlags *[]V0041OpenapiJobInfoRespJobsShowFlags `json:"show_flags,omitempty"`

		// SocketsPerBoard Number of sockets per board required
		SocketsPerBoard *int32 `json:"sockets_per_board,omitempty"`

		// SocketsPerNode Number of sockets per node required
		SocketsPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"sockets_per_node,omitempty"`

		// StandardError Path to stderr file
		StandardError *string `json:"standard_error,omitempty"`

		// StandardInput Path to stdin file
		StandardInput *string `json:"standard_input,omitempty"`

		// StandardOutput Path to stdout file
		StandardOutput *string `json:"standard_output,omitempty"`

		// StartTime Time execution began, or is expected to begin (UNIX timestamp)
		StartTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"start_time,omitempty"`

		// StateDescription Optional details for state_reason
		StateDescription *string `json:"state_description,omitempty"`

		// StateReason Reason for current Pending or Failed state
		StateReason *string `json:"state_reason,omitempty"`

		// SubmitTime Time when the job was submitted (UNIX timestamp)
		SubmitTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"submit_time,omitempty"`

		// SuspendTime Time the job was last suspended or resumed (UNIX timestamp)
		SuspendTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"suspend_time,omitempty"`

		// SystemComment Arbitrary comment from slurmctld
		SystemComment *string `json:"system_comment,omitempty"`

		// Tasks Number of tasks
		Tasks *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks,omitempty"`

		// TasksPerBoard Number of tasks invoked on each board
		TasksPerBoard *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_board,omitempty"`

		// TasksPerCore Number of tasks invoked on each core
		TasksPerCore *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_core,omitempty"`

		// TasksPerNode Number of tasks invoked on each node
		TasksPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_node,omitempty"`

		// TasksPerSocket Number of tasks invoked on each socket
		TasksPerSocket *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_socket,omitempty"`

		// TasksPerTres Number of tasks that can assess each GPU
		TasksPerTres *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_tres,omitempty"`

		// ThreadSpec Specialized thread count
		ThreadSpec *int32 `json:"thread_spec,omitempty"`

		// ThreadsPerCore Number of processor threads per CPU core required
		ThreadsPerCore *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"threads_per_core,omitempty"`

		// TimeLimit Maximum run time in minutes
		TimeLimit *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Minimum run time in minutes
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`

		// TresAllocStr TRES used by the job
		TresAllocStr *string `json:"tres_alloc_str,omitempty"`

		// TresBind Task to TRES binding directives
		TresBind *string `json:"tres_bind,omitempty"`

		// TresFreq TRES frequency directives
		TresFreq *string `json:"tres_freq,omitempty"`

		// TresPerJob Comma separated list of TRES=# values to be allocated per job
		TresPerJob *string `json:"tres_per_job,omitempty"`

		// TresPerNode Comma separated list of TRES=# values to be allocated per node
		TresPerNode *string `json:"tres_per_node,omitempty"`

		// TresPerSocket Comma separated list of TRES=# values to be allocated per socket
		TresPerSocket *string `json:"tres_per_socket,omitempty"`

		// TresPerTask Comma separated list of TRES=# values to be allocated per task
		TresPerTask *string `json:"tres_per_task,omitempty"`

		// TresReqStr TRES requested by the job
		TresReqStr *string `json:"tres_req_str,omitempty"`

		// UserId User ID that owns the job
		UserId *int32 `json:"user_id,omitempty"`

		// UserName User name that owns the job
		UserName *string `json:"user_name,omitempty"`

		// Wckey Workload characterization key
		Wckey *string `json:"wckey,omitempty"`
	} `json:"jobs"`

	// LastBackfill Time of last backfill scheduler run (UNIX timestamp)
	LastBackfill struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_backfill"`

	// LastUpdate Time of last job change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus defines model for V0041OpenapiJobInfoResp.Jobs.DerivedExitCode.Status.
type V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus string

// V0041OpenapiJobInfoRespJobsExclusive defines model for V0041OpenapiJobInfoResp.Jobs.Exclusive.
type V0041OpenapiJobInfoRespJobsExclusive string

// V0041OpenapiJobInfoRespJobsExitCodeStatus defines model for V0041OpenapiJobInfoResp.Jobs.ExitCode.Status.
type V0041OpenapiJobInfoRespJobsExitCodeStatus string

// V0041OpenapiJobInfoRespJobsFlags defines model for V0041OpenapiJobInfoResp.Jobs.Flags.
type V0041OpenapiJobInfoRespJobsFlags string

// V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus defines model for V0041OpenapiJobInfoResp.Jobs.JobResources.Nodes.Allocation.Sockets.Cores.Status.
type V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus string

// V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType defines model for V0041OpenapiJobInfoResp.Jobs.JobResources.Nodes.SelectType.
type V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType string

// V0041OpenapiJobInfoRespJobsJobResourcesSelectType defines model for V0041OpenapiJobInfoResp.Jobs.JobResources.SelectType.
type V0041OpenapiJobInfoRespJobsJobResourcesSelectType string

// V0041OpenapiJobInfoRespJobsJobState defines model for V0041OpenapiJobInfoResp.Jobs.JobState.
type V0041OpenapiJobInfoRespJobsJobState string

// V0041OpenapiJobInfoRespJobsMailType defines model for V0041OpenapiJobInfoResp.Jobs.MailType.
type V0041OpenapiJobInfoRespJobsMailType string

// V0041OpenapiJobInfoRespJobsProfile defines model for V0041OpenapiJobInfoResp.Jobs.Profile.
type V0041OpenapiJobInfoRespJobsProfile string

// V0041OpenapiJobInfoRespJobsShared defines model for V0041OpenapiJobInfoResp.Jobs.Shared.
type V0041OpenapiJobInfoRespJobsShared string

// V0041OpenapiJobInfoRespJobsShowFlags defines model for V0041OpenapiJobInfoResp.Jobs.ShowFlags.
type V0041OpenapiJobInfoRespJobsShowFlags string

// V0041OpenapiJobPostResponse defines model for v0.0.41_openapi_job_post_response.
type V0041OpenapiJobPostResponse struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// JobId First updated Job ID - Use results instead
	// Deprecated:
	JobId *string `json:"job_id,omitempty"`

	// JobSubmitUserMsg First updated Job submission user message - Use results instead
	// Deprecated:
	JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Results Job update results
	Results *[]struct {
		// Error Verbose update status or error
		Error *string `json:"error,omitempty"`

		// ErrorCode Verbose update status or error
		ErrorCode *int32 `json:"error_code,omitempty"`

		// JobId Job ID for updated job
		JobId *int32 `json:"job_id,omitempty"`

		// StepId Step ID for updated job
		StepId *string `json:"step_id,omitempty"`

		// Why Update response message
		Why *string `json:"why,omitempty"`
	} `json:"results,omitempty"`

	// StepId First updated Step ID - Use results instead
	// Deprecated:
	StepId *string `json:"step_id,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiJobSubmitResponse defines model for v0.0.41_openapi_job_submit_response.
type V0041OpenapiJobSubmitResponse struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// JobId Submitted Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// JobSubmitUserMsg Job submission user message
	JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Result Job submission
	// Deprecated:
	Result *struct {
		// Error Error message
		Error *string `json:"error,omitempty"`

		// ErrorCode Error code
		ErrorCode *int32 `json:"error_code,omitempty"`

		// JobId New job ID
		JobId *int32 `json:"job_id,omitempty"`

		// JobSubmitUserMsg Message to user from job_submit plugin
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// StepId New job step ID
		StepId *string `json:"step_id,omitempty"`
	} `json:"result,omitempty"`

	// StepId Submitted Step ID
	StepId *string `json:"step_id,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiKillJobsResp defines model for v0.0.41_openapi_kill_jobs_resp.
type V0041OpenapiKillJobsResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Status resultant status of signal request
	Status []struct {
		Error *struct {
			// Code Numeric error encountered signaling job
			Code *int32 `json:"code,omitempty"`

			// Message Error message why signaling job failed
			Message *string `json:"message,omitempty"`

			// String String error encountered signaling job
			String *string `json:"string,omitempty"`
		} `json:"error,omitempty"`
		Federation *struct {
			// Sibling Name of federation sibling (may be empty for non-federation)
			Sibling *string `json:"sibling,omitempty"`
		} `json:"federation,omitempty"`

		// JobId Job ID that signaling failed
		JobId struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"job_id"`

		// StepId Job or Step ID that signaling failed
		StepId string `json:"step_id"`
	} `json:"status"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiLicensesResp defines model for v0.0.41_openapi_licenses_resp.
type V0041OpenapiLicensesResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// LastUpdate Time of last licenses change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Licenses List of licenses
	Licenses []struct {
		// Free Number of licenses currently available
		Free *int32 `json:"Free,omitempty"`

		// LastConsumed Last known number of licenses that were consumed in the license manager (Remote Only)
		LastConsumed *int32 `json:"LastConsumed,omitempty"`

		// LastDeficit Number of "missing licenses" from the cluster's perspective
		LastDeficit *int32 `json:"LastDeficit,omitempty"`

		// LastUpdate When the license information was last updated (UNIX Timestamp)
		LastUpdate *int64 `json:"LastUpdate,omitempty"`

		// LicenseName Name of the license
		LicenseName *string `json:"LicenseName,omitempty"`

		// Remote Indicates whether licenses are served by the database
		Remote *bool `json:"Remote,omitempty"`

		// Reserved Number of licenses reserved
		Reserved *int32 `json:"Reserved,omitempty"`

		// Total Total number of licenses present
		Total *int32 `json:"Total,omitempty"`

		// Used Number of licenses in use
		Used *int32 `json:"Used,omitempty"`
	} `json:"licenses"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiNodesResp defines model for v0.0.41_openapi_nodes_resp.
type V0041OpenapiNodesResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// LastUpdate Time of last node change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Nodes List of nodes
	Nodes []struct {
		// ActiveFeatures Currently active features
		ActiveFeatures *[]string `json:"active_features,omitempty"`

		// Address NodeAddr, used to establish a communication path
		Address *string `json:"address,omitempty"`

		// AllocCpus Total number of CPUs currently allocated for jobs
		AllocCpus *int32 `json:"alloc_cpus,omitempty"`

		// AllocIdleCpus Total number of idle CPUs
		AllocIdleCpus *int32 `json:"alloc_idle_cpus,omitempty"`

		// AllocMemory Total memory in MB currently allocated for jobs
		AllocMemory *int64 `json:"alloc_memory,omitempty"`

		// Architecture Computer architecture
		Architecture *string `json:"architecture,omitempty"`

		// Boards Number of Baseboards in nodes with a baseboard controller
		Boards *int32 `json:"boards,omitempty"`

		// BootTime Time when the node booted (UNIX timestamp)
		BootTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"boot_time,omitempty"`

		// BurstbufferNetworkAddress Alternate network path to be used for sbcast network traffic
		BurstbufferNetworkAddress *string `json:"burstbuffer_network_address,omitempty"`

		// ClusterName Cluster name (only set in federated environments)
		ClusterName *string `json:"cluster_name,omitempty"`

		// Comment Arbitrary comment
		Comment *string `json:"comment,omitempty"`

		// Cores Number of cores in a single physical processor socket
		Cores *int32 `json:"cores,omitempty"`

		// CpuBinding Default method for binding tasks to allocated CPUs
		CpuBinding *int32 `json:"cpu_binding,omitempty"`

		// CpuLoad CPU load as reported by the OS
		CpuLoad *int32 `json:"cpu_load,omitempty"`

		// Cpus Total CPUs, including cores and threads
		Cpus *int32 `json:"cpus,omitempty"`

		// EffectiveCpus Number of effective CPUs (excluding specialized CPUs)
		EffectiveCpus *int32 `json:"effective_cpus,omitempty"`

		// Energy Energy usage data
		Energy *struct {
			// AverageWatts Average power consumption, in watts
			AverageWatts *int32 `json:"average_watts,omitempty"`

			// BaseConsumedEnergy The energy consumed between when the node was powered on and the last time it was registered by slurmd, in joules
			BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`

			// ConsumedEnergy The energy consumed between the last time the node was registered by the slurmd daemon and the last node energy accounting sample, in joules
			ConsumedEnergy *int64 `json:"consumed_energy,omitempty"`

			// CurrentWatts The instantaneous power consumption at the time of the last node energy accounting sample, in watts
			CurrentWatts *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"current_watts,omitempty"`

			// LastCollected Time when energy data was last retrieved (UNIX timestamp)
			LastCollected *int64 `json:"last_collected,omitempty"`

			// PreviousConsumedEnergy Previous value of consumed_energy
			PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
		} `json:"energy,omitempty"`
		// Deprecated:
		ExternalSensors *map[string]interface{} `json:"external_sensors,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// Features Available features
		Features *[]string `json:"features,omitempty"`

		// FreeMem Total memory in MB currently free as reported by the OS
		FreeMem *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"free_mem,omitempty"`

		// GpuSpec CPU cores reserved for jobs that also use a GPU
		GpuSpec *string `json:"gpu_spec,omitempty"`

		// Gres Generic resources
		Gres *string `json:"gres,omitempty"`

		// GresDrained Drained generic resources
		GresDrained *string `json:"gres_drained,omitempty"`

		// GresUsed Generic resources currently in use
		GresUsed *string `json:"gres_used,omitempty"`

		// Hostname NodeHostname
		Hostname *string `json:"hostname,omitempty"`

		// InstanceId Cloud instance ID
		InstanceId *string `json:"instance_id,omitempty"`

		// InstanceType Cloud instance type
		InstanceType *string `json:"instance_type,omitempty"`

		// LastBusy Time when the node was last busy (UNIX timestamp)
		LastBusy *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"last_busy,omitempty"`

		// McsLabel Multi-Category Security label
		McsLabel *string `json:"mcs_label,omitempty"`

		// Name NodeName
		Name *string `json:"name,omitempty"`

		// NextStateAfterReboot The state the node will be assigned after rebooting
		NextStateAfterReboot *[]V0041OpenapiNodesRespNodesNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`

		// OperatingSystem Operating system reported by the node
		OperatingSystem *string `json:"operating_system,omitempty"`

		// Owner User allowed to run jobs on this node (unset if no restriction)
		Owner *string `json:"owner,omitempty"`

		// Partitions Partitions containing this node
		Partitions *[]string `json:"partitions,omitempty"`

		// Port TCP port number of the slurmd
		Port *int32 `json:"port,omitempty"`
		// Deprecated:
		Power *map[string]interface{} `json:"power,omitempty"`

		// RealMemory Total memory in MB on the node
		RealMemory *int64 `json:"real_memory,omitempty"`

		// Reason Describes why the node is in a "DOWN", "DRAINED", "DRAINING", "FAILING" or "FAIL" state
		Reason *string `json:"reason,omitempty"`

		// ReasonChangedAt When the reason changed (UNIX timestamp)
		ReasonChangedAt *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"reason_changed_at,omitempty"`

		// ReasonSetByUser User who set the reason
		ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`

		// ResCoresPerGpu Number of CPU cores per GPU restricted to GPU jobs
		ResCoresPerGpu *int32 `json:"res_cores_per_gpu,omitempty"`

		// Reservation Name of reservation containing this node
		Reservation *string `json:"reservation,omitempty"`

		// ResumeAfter Number of seconds after the node's state is updated to "DOWN" or "DRAIN" before scheduling a node state resume
		ResumeAfter *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"resume_after,omitempty"`

		// SlurmdStartTime Time when the slurmd started (UNIX timestamp)
		SlurmdStartTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"slurmd_start_time,omitempty"`

		// Sockets Number of physical processor sockets/chips on the node
		Sockets *int32 `json:"sockets,omitempty"`

		// SpecializedCores Number of cores reserved for system use
		SpecializedCores *int32 `json:"specialized_cores,omitempty"`

		// SpecializedCpus Abstract CPU IDs on this node reserved for exclusive use by slurmd and slurmstepd
		SpecializedCpus *string `json:"specialized_cpus,omitempty"`

		// SpecializedMemory Combined memory limit, in MB, for Slurm compute node daemons
		SpecializedMemory *int64 `json:"specialized_memory,omitempty"`

		// State Node state(s) applicable to this node
		State *[]V0041OpenapiNodesRespNodesState `json:"state,omitempty"`

		// TemporaryDisk Total size in MB of temporary disk storage in TmpFS
		TemporaryDisk *int32 `json:"temporary_disk,omitempty"`

		// Threads Number of logical threads in a single physical core
		Threads *int32 `json:"threads,omitempty"`

		// Tres Configured trackable resources
		Tres *string `json:"tres,omitempty"`

		// TresUsed Trackable resources currently allocated for jobs
		TresUsed *string `json:"tres_used,omitempty"`

		// TresWeighted Ignored. Was weighted number of billable trackable resources allocated
		// Deprecated:
		TresWeighted *float64 `json:"tres_weighted,omitempty"`

		// Version Slurmd version
		Version *string `json:"version,omitempty"`

		// Weight Weight of the node for scheduling purposes
		Weight *int32 `json:"weight,omitempty"`
	} `json:"nodes"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiNodesRespNodesNextStateAfterReboot defines model for V0041OpenapiNodesResp.Nodes.NextStateAfterReboot.
type V0041OpenapiNodesRespNodesNextStateAfterReboot string

// V0041OpenapiNodesRespNodesState defines model for V0041OpenapiNodesResp.Nodes.State.
type V0041OpenapiNodesRespNodesState string

// V0041OpenapiPartitionResp defines model for v0.0.41_openapi_partition_resp.
type V0041OpenapiPartitionResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// LastUpdate Time of last partition change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Partitions List of partitions
	Partitions []struct {
		Accounts *struct {
			// Allowed AllowAccounts
			Allowed *string `json:"allowed,omitempty"`

			// Deny DenyAccounts
			Deny *string `json:"deny,omitempty"`
		} `json:"accounts,omitempty"`

		// Alternate Alternate
		Alternate *string `json:"alternate,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`
		Cpus    *struct {
			// TaskBinding CpuBind
			TaskBinding *int32 `json:"task_binding,omitempty"`

			// Total TotalCPUs
			Total *int32 `json:"total,omitempty"`
		} `json:"cpus,omitempty"`
		Defaults *struct {
			// Job JobDefaults
			Job *string `json:"job,omitempty"`

			// MemoryPerCpu DefMemPerCPU or DefMemPerNode
			MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

			// PartitionMemoryPerCpu DefMemPerCPU
			PartitionMemoryPerCpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"partition_memory_per_cpu,omitempty"`

			// PartitionMemoryPerNode DefMemPerNode
			PartitionMemoryPerNode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"partition_memory_per_node,omitempty"`

			// Time DefaultTime in minutes
			Time *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time,omitempty"`
		} `json:"defaults,omitempty"`

		// GraceTime GraceTime
		GraceTime *int32 `json:"grace_time,omitempty"`
		Groups    *struct {
			// Allowed AllowGroups
			Allowed *string `json:"allowed,omitempty"`
		} `json:"groups,omitempty"`
		Maximums *struct {
			// CpusPerNode MaxCPUsPerNode
			CpusPerNode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus_per_node,omitempty"`

			// CpusPerSocket MaxCPUsPerSocket
			CpusPerSocket *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus_per_socket,omitempty"`

			// MemoryPerCpu MaxMemPerCPU or MaxMemPerNode
			MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

			// Nodes MaxNodes
			Nodes *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nodes,omitempty"`

			// OverTimeLimit OverTimeLimit
			OverTimeLimit *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"over_time_limit,omitempty"`
			Oversubscribe *struct {
				// Flags Flags applicable to the OverSubscribe setting
				Flags *[]V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags `json:"flags,omitempty"`

				// Jobs Maximum number of jobs allowed to oversubscribe resources
				Jobs *int32 `json:"jobs,omitempty"`
			} `json:"oversubscribe,omitempty"`

			// PartitionMemoryPerCpu MaxMemPerCPU
			PartitionMemoryPerCpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"partition_memory_per_cpu,omitempty"`

			// PartitionMemoryPerNode MaxMemPerNode
			PartitionMemoryPerNode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"partition_memory_per_node,omitempty"`

			// Shares OverSubscribe
			Shares *int32 `json:"shares,omitempty"`

			// Time MaxTime
			Time *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time,omitempty"`
		} `json:"maximums,omitempty"`
		Minimums *struct {
			// Nodes MinNodes
			Nodes *int32 `json:"nodes,omitempty"`
		} `json:"minimums,omitempty"`

		// Name PartitionName
		Name *string `json:"name,omitempty"`

		// NodeSets NodeSets
		NodeSets *string `json:"node_sets,omitempty"`
		Nodes    *struct {
			// AllowedAllocation AllocNodes
			AllowedAllocation *string `json:"allowed_allocation,omitempty"`

			// Configured Nodes
			Configured *string `json:"configured,omitempty"`

			// Total TotalNodes
			Total *int32 `json:"total,omitempty"`
		} `json:"nodes,omitempty"`
		Partition *struct {
			// State Current state(s)
			State *[]V0041OpenapiPartitionRespPartitionsPartitionState `json:"state,omitempty"`
		} `json:"partition,omitempty"`
		Priority *struct {
			// JobFactor PriorityJobFactor
			JobFactor *int32 `json:"job_factor,omitempty"`

			// Tier PriorityTier
			Tier *int32 `json:"tier,omitempty"`
		} `json:"priority,omitempty"`
		Qos *struct {
			// Allowed AllowQOS
			Allowed *string `json:"allowed,omitempty"`

			// Assigned QOS
			Assigned *string `json:"assigned,omitempty"`

			// Deny DenyQOS
			Deny *string `json:"deny,omitempty"`
		} `json:"qos,omitempty"`

		// SelectType Scheduler consumable resource selection type
		SelectType *[]V0041OpenapiPartitionRespPartitionsSelectType `json:"select_type,omitempty"`

		// SuspendTime SuspendTime (GLOBAL if both set and infinite are false)
		SuspendTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"suspend_time,omitempty"`
		Timeouts *struct {
			// Resume ResumeTimeout (GLOBAL if both set and infinite are false)
			Resume *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"resume,omitempty"`

			// Suspend SuspendTimeout (GLOBAL if both set and infinite are false)
			Suspend *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"suspend,omitempty"`
		} `json:"timeouts,omitempty"`
		Tres *struct {
			// BillingWeights TRESBillingWeights
			BillingWeights *string `json:"billing_weights,omitempty"`

			// Configured TRES
			Configured *string `json:"configured,omitempty"`
		} `json:"tres,omitempty"`
	} `json:"partitions"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags defines model for V0041OpenapiPartitionResp.Partitions.Maximums.Oversubscribe.Flags.
type V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags string

// V0041OpenapiPartitionRespPartitionsPartitionState defines model for V0041OpenapiPartitionResp.Partitions.Partition.State.
type V0041OpenapiPartitionRespPartitionsPartitionState string

// V0041OpenapiPartitionRespPartitionsSelectType defines model for V0041OpenapiPartitionResp.Partitions.SelectType.
type V0041OpenapiPartitionRespPartitionsSelectType string

// V0041OpenapiPingArrayResp defines model for v0.0.41_openapi_ping_array_resp.
type V0041OpenapiPingArrayResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Pings pings
	Pings []struct {
		// Hostname Target for ping
		Hostname *string `json:"hostname,omitempty"`

		// Latency Number of microseconds it took to successfully ping or timeout
		Latency *int64 `json:"latency,omitempty"`

		// Mode The operating mode of the responding slurmctld
		Mode *string `json:"mode,omitempty"`

		// Pinged Ping result
		Pinged *string `json:"pinged,omitempty"`
	} `json:"pings"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiReservationResp defines model for v0.0.41_openapi_reservation_resp.
type V0041OpenapiReservationResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// LastUpdate Time of last reservation change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Reservations List of reservations
	Reservations []struct {
		// Accounts Comma separated list of permitted accounts
		Accounts *string `json:"accounts,omitempty"`

		// BurstBuffer BurstBuffer
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// CoreCount CoreCnt
		CoreCount *int32 `json:"core_count,omitempty"`

		// CoreSpecializations Reserved cores specification
		CoreSpecializations *[]struct {
			// Core IDs of reserved cores
			Core *string `json:"core,omitempty"`

			// Node Name of reserved node
			Node *string `json:"node,omitempty"`
		} `json:"core_specializations,omitempty"`

		// EndTime EndTime (UNIX timestamp)
		EndTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"end_time,omitempty"`

		// Features Features
		Features *string `json:"features,omitempty"`

		// Flags Flags associated with the reservation
		Flags *[]V0041OpenapiReservationRespReservationsFlags `json:"flags,omitempty"`

		// Groups Groups
		Groups *string `json:"groups,omitempty"`

		// Licenses Licenses
		Licenses *string `json:"licenses,omitempty"`

		// MaxStartDelay MaxStartDelay in seconds
		MaxStartDelay *int32 `json:"max_start_delay,omitempty"`

		// Name ReservationName
		Name *string `json:"name,omitempty"`

		// NodeCount NodeCnt
		NodeCount *int32 `json:"node_count,omitempty"`

		// NodeList Nodes
		NodeList *string `json:"node_list,omitempty"`

		// Partition PartitionName
		Partition      *string `json:"partition,omitempty"`
		PurgeCompleted *struct {
			// Time If PURGE_COMP flag is set, the number of seconds this reservation will sit idle until it is revoked
			Time *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time,omitempty"`
		} `json:"purge_completed,omitempty"`

		// StartTime StartTime (UNIX timestamp)
		StartTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"start_time,omitempty"`

		// Tres Comma separated list of required TRES
		Tres *string `json:"tres,omitempty"`

		// Users Comma separated list of permitted users
		Users *string `json:"users,omitempty"`

		// Watts 32 bit integer number with flags
		// Deprecated:
		Watts *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"watts,omitempty"`
	} `json:"reservations"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiReservationRespReservationsFlags defines model for V0041OpenapiReservationResp.Reservations.Flags.
type V0041OpenapiReservationRespReservationsFlags string

// V0041OpenapiResp defines model for v0.0.41_openapi_resp.
type V0041OpenapiResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSharesResp defines model for v0.0.41_openapi_shares_resp.
type V0041OpenapiSharesResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Shares fairshare info
	Shares struct {
		// Shares Association shares
		Shares *[]struct {
			// Cluster Cluster name
			Cluster *string `json:"cluster,omitempty"`

			// EffectiveUsage Effective, normalized usage
			EffectiveUsage *float64 `json:"effective_usage,omitempty"`
			Fairshare      *struct {
				// Factor Fairshare factor
				Factor *float64 `json:"factor,omitempty"`

				// Level Fairshare factor at this level; stored on an assoc as a long double, but that is not needed for display in sshare
				Level *float64 `json:"level,omitempty"`
			} `json:"fairshare,omitempty"`

			// Id Association ID
			Id *int32 `json:"id,omitempty"`

			// Name Share name
			Name *string `json:"name,omitempty"`

			// Parent Parent name
			Parent *string `json:"parent,omitempty"`

			// Partition Partition name
			Partition *string `json:"partition,omitempty"`

			// Shares Number of shares allocated
			Shares *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"shares,omitempty"`

			// SharesNormalized Normalized shares
			SharesNormalized *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"shares_normalized,omitempty"`
			Tres *struct {
				// GroupMinutes TRES-minute limit
				GroupMinutes *[]struct {
					// Name TRES name
					Name *string `json:"name,omitempty"`

					// Value TRES value
					Value *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"value,omitempty"`
				} `json:"group_minutes,omitempty"`

				// RunSeconds Currently running tres-secs = grp_used_tres_run_secs
				RunSeconds *[]struct {
					// Name TRES name
					Name *string `json:"name,omitempty"`

					// Value TRES value
					Value *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"value,omitempty"`
				} `json:"run_seconds,omitempty"`

				// Usage Measure of each TRES usage
				Usage *[]struct {
					// Name TRES name
					Name *string `json:"name,omitempty"`

					// Value TRES value
					Value *float32 `json:"value,omitempty"`
				} `json:"usage,omitempty"`
			} `json:"tres,omitempty"`

			// Type User or account association
			Type *[]V0041OpenapiSharesRespSharesSharesType `json:"type,omitempty"`

			// Usage Measure of tresbillableunits usage
			Usage *int64 `json:"usage,omitempty"`

			// UsageNormalized Normalized usage
			UsageNormalized *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"usage_normalized,omitempty"`
		} `json:"shares,omitempty"`

		// TotalShares Total number of shares
		TotalShares *int64 `json:"total_shares,omitempty"`
	} `json:"shares"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSharesRespSharesSharesType defines model for V0041OpenapiSharesResp.Shares.Shares.Type.
type V0041OpenapiSharesRespSharesSharesType string

// V0041OpenapiSlurmdbdConfigResp defines model for v0.0.41_openapi_slurmdbd_config_resp.
type V0041OpenapiSlurmdbdConfigResp struct {
	// Accounts Accounts
	Accounts *[]struct {
		// Associations Associations involving this account (only populated if requested)
		Associations *[]struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"associations,omitempty"`

		// Coordinators List of users that are a coordinator of this account (only populated if requested)
		Coordinators *[]struct {
			// Direct Indicates whether the coordinator was directly assigned to this account
			Direct *bool `json:"direct,omitempty"`

			// Name User name
			Name string `json:"name"`
		} `json:"coordinators,omitempty"`

		// Description Arbitrary string describing the account
		Description string `json:"description"`

		// Flags Flags associated with the account
		Flags *[]V0041OpenapiSlurmdbdConfigRespAccountsFlags `json:"flags,omitempty"`

		// Name Account name
		Name string `json:"name"`

		// Organization Organization to which the account belongs
		Organization string `json:"organization"`
	} `json:"accounts,omitempty"`

	// Associations Associations
	Associations *[]struct {
		// Account Account
		Account *string `json:"account,omitempty"`

		// Accounting Accounting records containing related resource usage
		Accounting *[]struct {
			// TRES Trackable resources
			TRES *struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"TRES,omitempty"`
			Allocated *struct {
				// Seconds Number of cpu seconds allocated
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"allocated,omitempty"`

			// Id Association ID or Workload characterization key ID
			Id *int32 `json:"id,omitempty"`

			// Start When the record was started
			Start *int64 `json:"start,omitempty"`
		} `json:"accounting,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Comment Arbitrary comment
		Comment *string `json:"comment,omitempty"`
		Default *struct {
			// Qos Default QOS
			Qos *string `json:"qos,omitempty"`
		} `json:"default,omitempty"`

		// Flags Flags on the association
		Flags *[]V0041OpenapiSlurmdbdConfigRespAssociationsFlags `json:"flags,omitempty"`

		// Id Unique ID
		Id *int32 `json:"id,omitempty"`

		// IsDefault Is default association for user
		IsDefault *bool `json:"is_default,omitempty"`

		// Lineage Complete path up the hierarchy to the root association
		Lineage *string `json:"lineage,omitempty"`
		Max     *struct {
			Jobs *struct {
				// Accruing MaxJobsAccrue
				Accruing *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"accruing,omitempty"`

				// Active MaxJobs
				Active *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"active,omitempty"`
				Per *struct {
					// Accruing GrpJobsAccrue
					Accruing *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"accruing,omitempty"`

					// Count GrpJobs
					Count *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"count,omitempty"`

					// Submitted GrpSubmitJobs
					Submitted *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"submitted,omitempty"`

					// WallClock MaxWallDurationPerJob
					WallClock *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"wall_clock,omitempty"`
				} `json:"per,omitempty"`

				// Total MaxSubmitJobs
				Total *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"total,omitempty"`
			} `json:"jobs,omitempty"`
			Per *struct {
				Account *struct {
					// WallClock GrpWall
					WallClock *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"wall_clock,omitempty"`
				} `json:"account,omitempty"`
			} `json:"per,omitempty"`
			Tres *struct {
				Group *struct {
					// Active GrpTRESRunMins
					Active *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"active,omitempty"`

					// Minutes GrpTRESMins
					Minutes *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"minutes,omitempty"`
				} `json:"group,omitempty"`
				Minutes *struct {
					Per *struct {
						// Job MaxTRESMinsPerJob
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`
					} `json:"per,omitempty"`

					// Total MaxTRESMinsPerJob
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"minutes,omitempty"`
				Per *struct {
					// Job MaxTRESPerJob
					Job *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"job,omitempty"`

					// Node MaxTRESPerNode
					Node *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"node,omitempty"`
				} `json:"per,omitempty"`

				// Total GrpTRES
				Total *[]struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"total,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"max,omitempty"`
		Min *struct {
			// PriorityThreshold MinPrioThreshold
			PriorityThreshold *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority_threshold,omitempty"`
		} `json:"min,omitempty"`

		// ParentAccount Name of parent account
		ParentAccount *string `json:"parent_account,omitempty"`

		// Partition Partition name
		Partition *string `json:"partition,omitempty"`

		// Priority Association priority factor
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Qos List of available QOS names
		Qos *[]string `json:"qos,omitempty"`

		// SharesRaw Allocated shares used for fairshare calculation
		SharesRaw *int32 `json:"shares_raw,omitempty"`

		// User User name
		User string `json:"user"`
	} `json:"associations,omitempty"`

	// Clusters Clusters
	Clusters *[]struct {
		Associations *struct {
			// Root Root association information
			Root *struct {
				// Account Account
				Account *string `json:"account,omitempty"`

				// Cluster Cluster
				Cluster *string `json:"cluster,omitempty"`

				// Id Numeric association ID
				Id *int32 `json:"id,omitempty"`

				// Partition Partition
				Partition *string `json:"partition,omitempty"`

				// User User name
				User string `json:"user"`
			} `json:"root,omitempty"`
		} `json:"associations,omitempty"`
		Controller *struct {
			// Host ControlHost
			Host *string `json:"host,omitempty"`

			// Port ControlPort
			Port *int32 `json:"port,omitempty"`
		} `json:"controller,omitempty"`

		// Flags Flags
		Flags *[]V0041OpenapiSlurmdbdConfigRespClustersFlags `json:"flags,omitempty"`

		// Name ClusterName
		Name *string `json:"name,omitempty"`

		// Nodes Node names
		Nodes *string `json:"nodes,omitempty"`

		// RpcVersion RPC version used in the cluster
		RpcVersion *int32 `json:"rpc_version,omitempty"`
		// Deprecated:
		SelectPlugin *string `json:"select_plugin,omitempty"`

		// Tres Trackable resources
		Tres *[]struct {
			// Count TRES count (0 if listed generically)
			Count *int64 `json:"count,omitempty"`

			// Id ID used in database
			Id *int32 `json:"id,omitempty"`

			// Name TRES name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type TRES type (CPU, MEM, etc)
			Type string `json:"type"`
		} `json:"tres,omitempty"`
	} `json:"clusters,omitempty"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Instances Instances
	Instances *[]struct {
		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// InstanceId Cloud instance ID
		InstanceId *string `json:"instance_id,omitempty"`

		// InstanceType Cloud instance type
		InstanceType *string `json:"instance_type,omitempty"`

		// NodeName NodeName
		NodeName *string `json:"node_name,omitempty"`
		Time     *struct {
			// TimeEnd When the instance will end (UNIX timestamp)
			TimeEnd *int64 `json:"time_end,omitempty"`

			// TimeStart When the instance will start (UNIX timestamp)
			TimeStart *int64 `json:"time_start,omitempty"`
		} `json:"time,omitempty"`
	} `json:"instances,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Qos QOS
	Qos *[]struct {
		// Description Arbitrary description
		Description *string `json:"description,omitempty"`

		// Flags Flags, to avoid modifying current values specify NOT_SET
		Flags *[]V0041OpenapiSlurmdbdConfigRespQosFlags `json:"flags,omitempty"`

		// Id Unique ID
		Id     *int32 `json:"id,omitempty"`
		Limits *struct {
			// Factor LimitFactor
			Factor *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"factor,omitempty"`

			// GraceTime GraceTime
			GraceTime *int32 `json:"grace_time,omitempty"`
			Max       *struct {
				Accruing *struct {
					Per *struct {
						// Account MaxJobsAccruePerAccount
						Account *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"account,omitempty"`

						// User MaxJobsAccruePerUser
						User *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"accruing,omitempty"`
				ActiveJobs *struct {
					// Accruing GrpJobsAccrue
					Accruing *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"accruing,omitempty"`

					// Count GrpJobs
					Count *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"count,omitempty"`
				} `json:"active_jobs,omitempty"`
				Jobs *struct {
					ActiveJobs *struct {
						Per *struct {
							// Account MaxJobsPerAccount
							Account *struct {
								// Infinite True if number has been set to infinite; "set" and "number" will be ignored
								Infinite *bool `json:"infinite,omitempty"`

								// Number If "set" is True the number will be set with value; otherwise ignore number contents
								Number *int32 `json:"number,omitempty"`

								// Set True if number has been set; False if number is unset
								Set *bool `json:"set,omitempty"`
							} `json:"account,omitempty"`

							// User MaxJobsPerUser
							User *struct {
								// Infinite True if number has been set to infinite; "set" and "number" will be ignored
								Infinite *bool `json:"infinite,omitempty"`

								// Number If "set" is True the number will be set with value; otherwise ignore number contents
								Number *int32 `json:"number,omitempty"`

								// Set True if number has been set; False if number is unset
								Set *bool `json:"set,omitempty"`
							} `json:"user,omitempty"`
						} `json:"per,omitempty"`
					} `json:"active_jobs,omitempty"`
					Per *struct {
						// Account MaxSubmitJobsPerAccount
						Account *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"account,omitempty"`

						// User MaxSubmitJobsPerUser
						User *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"jobs,omitempty"`
				Tres *struct {
					Minutes *struct {
						Per *struct {
							// Account MaxTRESRunMinsPerAccount
							Account *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"account,omitempty"`

							// Job MaxTRESMinsPerJob
							Job *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"job,omitempty"`

							// Qos GrpTRESRunMins
							Qos *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"qos,omitempty"`

							// User MaxTRESRunMinsPerUser
							User *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"user,omitempty"`
						} `json:"per,omitempty"`
					} `json:"minutes,omitempty"`
					Per *struct {
						// Account MaxTRESPerAccount
						Account *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"account,omitempty"`

						// Job MaxTRESPerJob
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`

						// Node MaxTRESPerNode
						Node *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"node,omitempty"`

						// User MaxTRESPerUser
						User *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`

					// Total GrpTRES
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"tres,omitempty"`
				WallClock *struct {
					Per *struct {
						// Job MaxWallDurationPerJob
						Job *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"job,omitempty"`

						// Qos GrpWall
						Qos *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"qos,omitempty"`
					} `json:"per,omitempty"`
				} `json:"wall_clock,omitempty"`
			} `json:"max,omitempty"`
			Min *struct {
				// PriorityThreshold MinPrioThreshold
				PriorityThreshold *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"priority_threshold,omitempty"`
				Tres *struct {
					Per *struct {
						// Job MinTRES
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`
					} `json:"per,omitempty"`
				} `json:"tres,omitempty"`
			} `json:"min,omitempty"`
		} `json:"limits,omitempty"`

		// Name Name
		Name    *string `json:"name,omitempty"`
		Preempt *struct {
			// ExemptTime PreemptExemptTime
			ExemptTime *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"exempt_time,omitempty"`

			// List Other QOS's this QOS can preempt
			List *[]string `json:"list,omitempty"`

			// Mode PreemptMode
			Mode *[]V0041OpenapiSlurmdbdConfigRespQosPreemptMode `json:"mode,omitempty"`
		} `json:"preempt,omitempty"`

		// Priority Priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// UsageFactor UsageFactor
		UsageFactor *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"usage_factor,omitempty"`

		// UsageThreshold UsageThreshold
		UsageThreshold *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"usage_threshold,omitempty"`
	} `json:"qos,omitempty"`

	// Tres TRES
	Tres *[]struct {
		// Count TRES count (0 if listed generically)
		Count *int64 `json:"count,omitempty"`

		// Id ID used in database
		Id *int32 `json:"id,omitempty"`

		// Name TRES name (if applicable)
		Name *string `json:"name,omitempty"`

		// Type TRES type (CPU, MEM, etc)
		Type string `json:"type"`
	} `json:"tres,omitempty"`

	// Users Users
	Users *[]struct {
		// AdministratorLevel AdminLevel granted to the user
		AdministratorLevel *[]V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel `json:"administrator_level,omitempty"`

		// Associations Associations created for this user
		Associations *[]struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"associations,omitempty"`

		// Coordinators Accounts this user is a coordinator for
		Coordinators *[]struct {
			// Direct Indicates whether the coordinator was directly assigned to this account
			Direct *bool `json:"direct,omitempty"`

			// Name User name
			Name string `json:"name"`
		} `json:"coordinators,omitempty"`
		Default *struct {
			// Account Default Account
			Account *string `json:"account,omitempty"`

			// Wckey Default WCKey
			Wckey *string `json:"wckey,omitempty"`
		} `json:"default,omitempty"`

		// Flags Flags associated with user
		Flags *[]V0041OpenapiSlurmdbdConfigRespUsersFlags `json:"flags,omitempty"`

		// Name User name
		Name string `json:"name"`

		// OldName Previous user name
		OldName *string `json:"old_name,omitempty"`

		// Wckeys List of available WCKeys
		Wckeys *[]struct {
			// Accounting Accounting records containing related resource usage
			Accounting *[]struct {
				// TRES Trackable resources
				TRES *struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"TRES,omitempty"`
				Allocated *struct {
					// Seconds Number of cpu seconds allocated
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"allocated,omitempty"`

				// Id Association ID or Workload characterization key ID
				Id *int32 `json:"id,omitempty"`

				// Start When the record was started
				Start *int64 `json:"start,omitempty"`
			} `json:"accounting,omitempty"`

			// Cluster Cluster name
			Cluster string `json:"cluster"`

			// Flags Flags associated with the WCKey
			Flags *[]V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags `json:"flags,omitempty"`

			// Id Unique ID for this user-cluster-wckey combination
			Id *int32 `json:"id,omitempty"`

			// Name WCKey name
			Name string `json:"name"`

			// User User name
			User string `json:"user"`
		} `json:"wckeys,omitempty"`
	} `json:"users,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`

	// Wckeys WCKeys
	Wckeys *[]struct {
		// Accounting Accounting records containing related resource usage
		Accounting *[]struct {
			// TRES Trackable resources
			TRES *struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"TRES,omitempty"`
			Allocated *struct {
				// Seconds Number of cpu seconds allocated
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"allocated,omitempty"`

			// Id Association ID or Workload characterization key ID
			Id *int32 `json:"id,omitempty"`

			// Start When the record was started
			Start *int64 `json:"start,omitempty"`
		} `json:"accounting,omitempty"`

		// Cluster Cluster name
		Cluster string `json:"cluster"`

		// Flags Flags associated with the WCKey
		Flags *[]V0041OpenapiSlurmdbdConfigRespWckeysFlags `json:"flags,omitempty"`

		// Id Unique ID for this user-cluster-wckey combination
		Id *int32 `json:"id,omitempty"`

		// Name WCKey name
		Name string `json:"name"`

		// User User name
		User string `json:"user"`
	} `json:"wckeys,omitempty"`
}

// V0041OpenapiSlurmdbdConfigRespAccountsFlags defines model for V0041OpenapiSlurmdbdConfigResp.Accounts.Flags.
type V0041OpenapiSlurmdbdConfigRespAccountsFlags string

// V0041OpenapiSlurmdbdConfigRespAssociationsFlags defines model for V0041OpenapiSlurmdbdConfigResp.Associations.Flags.
type V0041OpenapiSlurmdbdConfigRespAssociationsFlags string

// V0041OpenapiSlurmdbdConfigRespClustersFlags defines model for V0041OpenapiSlurmdbdConfigResp.Clusters.Flags.
type V0041OpenapiSlurmdbdConfigRespClustersFlags string

// V0041OpenapiSlurmdbdConfigRespQosFlags defines model for V0041OpenapiSlurmdbdConfigResp.Qos.Flags.
type V0041OpenapiSlurmdbdConfigRespQosFlags string

// V0041OpenapiSlurmdbdConfigRespQosPreemptMode defines model for V0041OpenapiSlurmdbdConfigResp.Qos.Preempt.Mode.
type V0041OpenapiSlurmdbdConfigRespQosPreemptMode string

// V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel defines model for V0041OpenapiSlurmdbdConfigResp.Users.AdministratorLevel.
type V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel string

// V0041OpenapiSlurmdbdConfigRespUsersFlags defines model for V0041OpenapiSlurmdbdConfigResp.Users.Flags.
type V0041OpenapiSlurmdbdConfigRespUsersFlags string

// V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags defines model for V0041OpenapiSlurmdbdConfigResp.Users.Wckeys.Flags.
type V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags string

// V0041OpenapiSlurmdbdConfigRespWckeysFlags defines model for V0041OpenapiSlurmdbdConfigResp.Wckeys.Flags.
type V0041OpenapiSlurmdbdConfigRespWckeysFlags string

// V0041OpenapiSlurmdbdJobsResp defines model for v0.0.41_openapi_slurmdbd_jobs_resp.
type V0041OpenapiSlurmdbdJobsResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Jobs jobs
	Jobs []struct {
		// Account Account the job ran under
		Account *string `json:"account,omitempty"`

		// AllocationNodes List of nodes allocated to the job
		AllocationNodes *int32 `json:"allocation_nodes,omitempty"`
		Array           *struct {
			// JobId Job ID of job array, or 0 if N/A
			JobId  *int32 `json:"job_id,omitempty"`
			Limits *struct {
				Max *struct {
					Running *struct {
						// Tasks Maximum number of simultaneously running tasks, 0 if no limit
						Tasks *int32 `json:"tasks,omitempty"`
					} `json:"running,omitempty"`
				} `json:"max,omitempty"`
			} `json:"limits,omitempty"`

			// Task String expression of task IDs in this record
			Task *string `json:"task,omitempty"`

			// TaskId Task ID of this task in job array
			TaskId *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"task_id,omitempty"`
		} `json:"array,omitempty"`

		// Association Unique identifier for the association
		Association *struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"association,omitempty"`

		// Block The name of the block to be used (used with Blue Gene systems)
		Block *string `json:"block,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`
		Comment *struct {
			// Administrator Arbitrary comment made by administrator
			Administrator *string `json:"administrator,omitempty"`

			// Job Arbitrary comment made by user
			Job *string `json:"job,omitempty"`

			// System Arbitrary comment from slurmctld
			System *string `json:"system,omitempty"`
		} `json:"comment,omitempty"`

		// Constraints Feature(s) the job requested as a constraint
		Constraints *string `json:"constraints,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// DerivedExitCode Highest exit code of all job steps
		DerivedExitCode *struct {
			// ReturnCode Process return code (numeric)
			ReturnCode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"return_code,omitempty"`
			Signal *struct {
				// Id Signal sent to process (numeric)
				Id *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"id,omitempty"`

				// Name Signal sent to process
				Name *string `json:"name,omitempty"`
			} `json:"signal,omitempty"`

			// Status Status given by return code
			Status *[]V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus `json:"status,omitempty"`
		} `json:"derived_exit_code,omitempty"`

		// ExitCode Exit code
		ExitCode *struct {
			// ReturnCode Process return code (numeric)
			ReturnCode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"return_code,omitempty"`
			Signal *struct {
				// Id Signal sent to process (numeric)
				Id *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"id,omitempty"`

				// Name Signal sent to process
				Name *string `json:"name,omitempty"`
			} `json:"signal,omitempty"`

			// Status Status given by return code
			Status *[]V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus `json:"status,omitempty"`
		} `json:"exit_code,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// FailedNode Name of node that caused job failure
		FailedNode *string `json:"failed_node,omitempty"`

		// Flags Flags associated with the job
		Flags *[]V0041OpenapiSlurmdbdJobsRespJobsFlags `json:"flags,omitempty"`

		// Group Group ID of the user that owns the job
		Group *string `json:"group,omitempty"`
		Het   *struct {
			// JobId Heterogeneous job ID, if applicable
			JobId *int32 `json:"job_id,omitempty"`

			// JobOffset Unique sequence number applied to this component of the heterogeneous job
			JobOffset *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"job_offset,omitempty"`
		} `json:"het,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// KillRequestUser User ID that requested termination of the job
		KillRequestUser *string `json:"kill_request_user,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`
		Mcs      *struct {
			// Label Multi-Category Security label on the job
			Label *string `json:"label,omitempty"`
		} `json:"mcs,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Nodes Node(s) allocated to the job
		Nodes *string `json:"nodes,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Qos Quality of Service assigned to the job
		Qos      *string `json:"qos,omitempty"`
		Required *struct {
			// CPUs Minimum number of CPUs required
			CPUs *int32 `json:"CPUs,omitempty"`

			// MemoryPerCpu Minimum memory in megabytes per allocated CPU
			MemoryPerCpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_cpu,omitempty"`

			// MemoryPerNode Minimum memory in megabytes per allocated node
			MemoryPerNode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_node,omitempty"`
		} `json:"required,omitempty"`
		Reservation *struct {
			// Id Unique identifier of requested reservation
			Id *int32 `json:"id,omitempty"`

			// Name Name of reservation to use
			Name *string `json:"name,omitempty"`
		} `json:"reservation,omitempty"`

		// Script Job batch script; only the first component in a HetJob is populated or honored
		Script *string `json:"script,omitempty"`
		State  *struct {
			// Current Current state
			Current *[]V0041OpenapiSlurmdbdJobsRespJobsStateCurrent `json:"current,omitempty"`

			// Reason Reason for previous Pending or Failed state
			Reason *string `json:"reason,omitempty"`
		} `json:"state,omitempty"`

		// Stderr Path to stderr file
		Stderr *string `json:"stderr,omitempty"`

		// StderrExpanded Job stderr with expanded fields
		StderrExpanded *string `json:"stderr_expanded,omitempty"`

		// Stdin Path to stdin file
		Stdin *string `json:"stdin,omitempty"`

		// StdinExpanded Job stdin with expanded fields
		StdinExpanded *string `json:"stdin_expanded,omitempty"`

		// Stdout Path to stdout file
		Stdout *string `json:"stdout,omitempty"`

		// StdoutExpanded Job stdout with expanded fields
		StdoutExpanded *string `json:"stdout_expanded,omitempty"`

		// Steps Individual steps in the job
		Steps *[]struct {
			CPU *struct {
				// Governor Requested CPU frequency governor in kHz
				Governor           *string `json:"governor,omitempty"`
				RequestedFrequency *struct {
					// Max Maximum requested CPU frequency in kHz
					Max *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"max,omitempty"`

					// Min Minimum requested CPU frequency in kHz
					Min *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"min,omitempty"`
				} `json:"requested_frequency,omitempty"`
			} `json:"CPU,omitempty"`

			// ExitCode Exit code
			ExitCode *struct {
				// ReturnCode Process return code (numeric)
				ReturnCode *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"return_code,omitempty"`
				Signal *struct {
					// Id Signal sent to process (numeric)
					Id *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"id,omitempty"`

					// Name Signal sent to process
					Name *string `json:"name,omitempty"`
				} `json:"signal,omitempty"`

				// Status Status given by return code
				Status *[]V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus `json:"status,omitempty"`
			} `json:"exit_code,omitempty"`

			// KillRequestUser User ID that requested termination of the step
			KillRequestUser *string `json:"kill_request_user,omitempty"`
			Nodes           *struct {
				// Count Number of nodes in the job step
				Count *int32 `json:"count,omitempty"`

				// List List of nodes used by the step
				List *[]string `json:"list,omitempty"`

				// Range Node(s) allocated to the job step
				Range *string `json:"range,omitempty"`
			} `json:"nodes,omitempty"`

			// Pid Process ID
			Pid *string `json:"pid,omitempty"`

			// State Current state
			State      *[]V0041OpenapiSlurmdbdJobsRespJobsStepsState `json:"state,omitempty"`
			Statistics *struct {
				CPU *struct {
					// ActualFrequency Average weighted CPU frequency of all tasks in kHz
					ActualFrequency *int64 `json:"actual_frequency,omitempty"`
				} `json:"CPU,omitempty"`
				Energy *struct {
					// Consumed Total energy consumed by all tasks in a job in joules
					Consumed *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"consumed,omitempty"`
				} `json:"energy,omitempty"`
			} `json:"statistics,omitempty"`
			Step *struct {
				// Id Step ID
				Id *string `json:"id,omitempty"`

				// Name Step name
				Name *string `json:"name,omitempty"`
			} `json:"step,omitempty"`
			Task *struct {
				// Distribution The layout of the step was when it was running
				Distribution *string `json:"distribution,omitempty"`
			} `json:"task,omitempty"`
			Tasks *struct {
				// Count Total number of tasks
				Count *int32 `json:"count,omitempty"`
			} `json:"tasks,omitempty"`
			Time *struct {
				// Elapsed Elapsed time in seconds
				Elapsed *int32 `json:"elapsed,omitempty"`

				// End End time (UNIX timestamp)
				End *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"end,omitempty"`

				// Start Time execution began (UNIX timestamp)
				Start *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"start,omitempty"`

				// Suspended Time in suspended state in seconds
				Suspended *int32 `json:"suspended,omitempty"`
				System    *struct {
					// Microseconds System CPU time used by the step in microseconds
					Microseconds *int32 `json:"microseconds,omitempty"`

					// Seconds System CPU time used by the step in seconds
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"system,omitempty"`
				Total *struct {
					// Microseconds Total CPU time used by the step in microseconds
					Microseconds *int32 `json:"microseconds,omitempty"`

					// Seconds Total CPU time used by the step in seconds
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"total,omitempty"`
				User *struct {
					// Microseconds User CPU time used by the step in microseconds
					Microseconds *int32 `json:"microseconds,omitempty"`

					// Seconds User CPU time used by the step in seconds
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"user,omitempty"`
			} `json:"time,omitempty"`
			Tres *struct {
				// Allocated Trackable resources allocated to the step
				Allocated *[]struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"allocated,omitempty"`
				Consumed *struct {
					// Average Average TRES usage consumed among all tasks
					Average *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"average,omitempty"`

					// Max Maximum TRES usage consumed among all tasks
					Max *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"max,omitempty"`

					// Min Minimum TRES usage consumed among all tasks
					Min *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"min,omitempty"`

					// Total Total TRES usage consumed among all tasks
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"consumed,omitempty"`
				Requested *struct {
					// Average Average TRES usage requested among all tasks
					Average *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"average,omitempty"`

					// Max Maximum TRES usage requested among all tasks
					Max *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"max,omitempty"`

					// Min Minimum TRES usage requested among all tasks
					Min *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"min,omitempty"`

					// Total Total TRES usage requested among all tasks
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"requested,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"steps,omitempty"`

		// SubmitLine Command used to submit the job
		SubmitLine *string `json:"submit_line,omitempty"`
		Time       *struct {
			// Elapsed Elapsed time in seconds
			Elapsed *int32 `json:"elapsed,omitempty"`

			// Eligible Time when the job became eligible to run (UNIX timestamp)
			Eligible *int64 `json:"eligible,omitempty"`

			// End End time (UNIX timestamp)
			End *int64 `json:"end,omitempty"`

			// Limit Maximum run time in minutes
			Limit *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"limit,omitempty"`

			// Planned Time required to start job after becoming eligible to run in seconds
			Planned *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"planned,omitempty"`

			// Start Time execution began (UNIX timestamp)
			Start *int64 `json:"start,omitempty"`

			// Submission Time when the job was submitted (UNIX timestamp)
			Submission *int64 `json:"submission,omitempty"`

			// Suspended Total time in suspended state in seconds
			Suspended *int32 `json:"suspended,omitempty"`
			System    *struct {
				// Microseconds System CPU time used by the job in microseconds
				Microseconds *int64 `json:"microseconds,omitempty"`

				// Seconds System CPU time used by the job in seconds
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"system,omitempty"`
			Total *struct {
				// Microseconds Sum of System and User CPU time used by the job in microseconds
				Microseconds *int64 `json:"microseconds,omitempty"`

				// Seconds Sum of System and User CPU time used by the job in seconds
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"total,omitempty"`
			User *struct {
				// Microseconds User CPU time used by the job in microseconds
				Microseconds *int64 `json:"microseconds,omitempty"`

				// Seconds User CPU time used by the job in seconds
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"user,omitempty"`
		} `json:"time,omitempty"`
		Tres *struct {
			// Allocated Trackable resources allocated to the job
			Allocated *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"allocated,omitempty"`

			// Requested Trackable resources requested by job
			Requested *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"requested,omitempty"`
		} `json:"tres,omitempty"`

		// UsedGres Generic resources used by job
		UsedGres *string `json:"used_gres,omitempty"`

		// User User that owns the job
		User *string `json:"user,omitempty"`

		// Wckey Workload characterization key
		Wckey *struct {
			// Flags Active flags
			Flags []V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags `json:"flags"`

			// Wckey WCKey name
			Wckey string `json:"wckey"`
		} `json:"wckey,omitempty"`

		// WorkingDirectory Path to current working directory
		WorkingDirectory *string `json:"working_directory,omitempty"`
	} `json:"jobs"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.DerivedExitCode.Status.
type V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus string

// V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.ExitCode.Status.
type V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus string

// V0041OpenapiSlurmdbdJobsRespJobsFlags defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.Flags.
type V0041OpenapiSlurmdbdJobsRespJobsFlags string

// V0041OpenapiSlurmdbdJobsRespJobsStateCurrent defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.State.Current.
type V0041OpenapiSlurmdbdJobsRespJobsStateCurrent string

// V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.Steps.ExitCode.Status.
type V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus string

// V0041OpenapiSlurmdbdJobsRespJobsStepsState defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.Steps.State.
type V0041OpenapiSlurmdbdJobsRespJobsStepsState string

// V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.Wckey.Flags.
type V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags string

// V0041OpenapiSlurmdbdQosRemovedResp defines model for v0.0.41_openapi_slurmdbd_qos_removed_resp.
type V0041OpenapiSlurmdbdQosRemovedResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// RemovedQos removed QOS
	RemovedQos []string `json:"removed_qos"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSlurmdbdQosResp defines model for v0.0.41_openapi_slurmdbd_qos_resp.
type V0041OpenapiSlurmdbdQosResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Qos List of QOS
	Qos []struct {
		// Description Arbitrary description
		Description *string `json:"description,omitempty"`

		// Flags Flags, to avoid modifying current values specify NOT_SET
		Flags *[]V0041OpenapiSlurmdbdQosRespQosFlags `json:"flags,omitempty"`

		// Id Unique ID
		Id     *int32 `json:"id,omitempty"`
		Limits *struct {
			// Factor LimitFactor
			Factor *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"factor,omitempty"`

			// GraceTime GraceTime
			GraceTime *int32 `json:"grace_time,omitempty"`
			Max       *struct {
				Accruing *struct {
					Per *struct {
						// Account MaxJobsAccruePerAccount
						Account *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"account,omitempty"`

						// User MaxJobsAccruePerUser
						User *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"accruing,omitempty"`
				ActiveJobs *struct {
					// Accruing GrpJobsAccrue
					Accruing *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"accruing,omitempty"`

					// Count GrpJobs
					Count *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"count,omitempty"`
				} `json:"active_jobs,omitempty"`
				Jobs *struct {
					ActiveJobs *struct {
						Per *struct {
							// Account MaxJobsPerAccount
							Account *struct {
								// Infinite True if number has been set to infinite; "set" and "number" will be ignored
								Infinite *bool `json:"infinite,omitempty"`

								// Number If "set" is True the number will be set with value; otherwise ignore number contents
								Number *int32 `json:"number,omitempty"`

								// Set True if number has been set; False if number is unset
								Set *bool `json:"set,omitempty"`
							} `json:"account,omitempty"`

							// User MaxJobsPerUser
							User *struct {
								// Infinite True if number has been set to infinite; "set" and "number" will be ignored
								Infinite *bool `json:"infinite,omitempty"`

								// Number If "set" is True the number will be set with value; otherwise ignore number contents
								Number *int32 `json:"number,omitempty"`

								// Set True if number has been set; False if number is unset
								Set *bool `json:"set,omitempty"`
							} `json:"user,omitempty"`
						} `json:"per,omitempty"`
					} `json:"active_jobs,omitempty"`
					Per *struct {
						// Account MaxSubmitJobsPerAccount
						Account *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"account,omitempty"`

						// User MaxSubmitJobsPerUser
						User *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"jobs,omitempty"`
				Tres *struct {
					Minutes *struct {
						Per *struct {
							// Account MaxTRESRunMinsPerAccount
							Account *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"account,omitempty"`

							// Job MaxTRESMinsPerJob
							Job *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"job,omitempty"`

							// Qos GrpTRESRunMins
							Qos *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"qos,omitempty"`

							// User MaxTRESRunMinsPerUser
							User *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"user,omitempty"`
						} `json:"per,omitempty"`
					} `json:"minutes,omitempty"`
					Per *struct {
						// Account MaxTRESPerAccount
						Account *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"account,omitempty"`

						// Job MaxTRESPerJob
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`

						// Node MaxTRESPerNode
						Node *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"node,omitempty"`

						// User MaxTRESPerUser
						User *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`

					// Total GrpTRES
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"tres,omitempty"`
				WallClock *struct {
					Per *struct {
						// Job MaxWallDurationPerJob
						Job *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"job,omitempty"`

						// Qos GrpWall
						Qos *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"qos,omitempty"`
					} `json:"per,omitempty"`
				} `json:"wall_clock,omitempty"`
			} `json:"max,omitempty"`
			Min *struct {
				// PriorityThreshold MinPrioThreshold
				PriorityThreshold *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"priority_threshold,omitempty"`
				Tres *struct {
					Per *struct {
						// Job MinTRES
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`
					} `json:"per,omitempty"`
				} `json:"tres,omitempty"`
			} `json:"min,omitempty"`
		} `json:"limits,omitempty"`

		// Name Name
		Name    *string `json:"name,omitempty"`
		Preempt *struct {
			// ExemptTime PreemptExemptTime
			ExemptTime *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"exempt_time,omitempty"`

			// List Other QOS's this QOS can preempt
			List *[]string `json:"list,omitempty"`

			// Mode PreemptMode
			Mode *[]V0041OpenapiSlurmdbdQosRespQosPreemptMode `json:"mode,omitempty"`
		} `json:"preempt,omitempty"`

		// Priority Priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// UsageFactor UsageFactor
		UsageFactor *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"usage_factor,omitempty"`

		// UsageThreshold UsageThreshold
		UsageThreshold *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"usage_threshold,omitempty"`
	} `json:"qos"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSlurmdbdQosRespQosFlags defines model for V0041OpenapiSlurmdbdQosResp.Qos.Flags.
type V0041OpenapiSlurmdbdQosRespQosFlags string

// V0041OpenapiSlurmdbdQosRespQosPreemptMode defines model for V0041OpenapiSlurmdbdQosResp.Qos.Preempt.Mode.
type V0041OpenapiSlurmdbdQosRespQosPreemptMode string

// V0041OpenapiSlurmdbdStatsResp defines model for v0.0.41_openapi_slurmdbd_stats_resp.
type V0041OpenapiSlurmdbdStatsResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Statistics statistics
	Statistics struct {
		// RPCs List of RPCs sent to the slurmdbd
		RPCs *[]struct {
			// Count Number of RPCs processed
			Count *int32 `json:"count,omitempty"`

			// Rpc RPC type
			Rpc  *string `json:"rpc,omitempty"`
			Time *struct {
				// Average Average RPC processing time in microseconds
				Average *int64 `json:"average,omitempty"`

				// Total Total RPC processing time in microseconds
				Total *int64 `json:"total,omitempty"`
			} `json:"time,omitempty"`
		} `json:"RPCs,omitempty"`

		// Rollups Rollup statistics
		Rollups *struct {
			Daily *struct {
				// Count Number of daily rollups since last_run
				Count    *int32 `json:"count,omitempty"`
				Duration *struct {
					// Last Total time spent doing daily daily rollup (seconds)
					Last *int64 `json:"last,omitempty"`

					// Max Longest daily rollup time (seconds)
					Max *int64 `json:"max,omitempty"`

					// Time Total time spent doing daily rollups (seconds)
					Time *int64 `json:"time,omitempty"`
				} `json:"duration,omitempty"`

				// LastRun Last time daily rollup ran (UNIX timestamp)
				LastRun *int64 `json:"last_run,omitempty"`
			} `json:"daily,omitempty"`
			Hourly *struct {
				// Count Number of hourly rollups since last_run
				Count    *int32 `json:"count,omitempty"`
				Duration *struct {
					// Last Total time spent doing last daily rollup (seconds)
					Last *int64 `json:"last,omitempty"`

					// Max Longest hourly rollup time (seconds)
					Max *int64 `json:"max,omitempty"`

					// Time Total time spent doing hourly rollups (seconds)
					Time *int64 `json:"time,omitempty"`
				} `json:"duration,omitempty"`

				// LastRun Last time hourly rollup ran (UNIX timestamp)
				LastRun *int64 `json:"last_run,omitempty"`
			} `json:"hourly,omitempty"`
			Monthly *struct {
				// Count Number of monthly rollups since last_run
				Count    *int32 `json:"count,omitempty"`
				Duration *struct {
					// Last Total time spent doing monthly daily rollup (seconds)
					Last *int64 `json:"last,omitempty"`

					// Max Longest monthly rollup time (seconds)
					Max *int64 `json:"max,omitempty"`

					// Time Total time spent doing monthly rollups (seconds)
					Time *int64 `json:"time,omitempty"`
				} `json:"duration,omitempty"`

				// LastRun Last time monthly rollup ran (UNIX timestamp)
				LastRun *int64 `json:"last_run,omitempty"`
			} `json:"monthly,omitempty"`
		} `json:"rollups,omitempty"`

		// TimeStart When data collection started (UNIX timestamp)
		TimeStart *int64 `json:"time_start,omitempty"`

		// Users List of users that issued RPCs
		Users *[]struct {
			// Count Number of RPCs processed
			Count *int32 `json:"count,omitempty"`
			Time  *struct {
				// Average Average RPC processing time in microseconds
				Average *int64 `json:"average,omitempty"`

				// Total Total RPC processing time in microseconds
				Total *int64 `json:"total,omitempty"`
			} `json:"time,omitempty"`

			// User User ID
			User *string `json:"user,omitempty"`
		} `json:"users,omitempty"`
	} `json:"statistics"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiTresResp defines model for v0.0.41_openapi_tres_resp.
type V0041OpenapiTresResp struct {
	// TRES TRES
	TRES []struct {
		// Count TRES count (0 if listed generically)
		Count *int64 `json:"count,omitempty"`

		// Id ID used in database
		Id *int32 `json:"id,omitempty"`

		// Name TRES name (if applicable)
		Name *string `json:"name,omitempty"`

		// Type TRES type (CPU, MEM, etc)
		Type string `json:"type"`
	} `json:"TRES"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiUsersAddCondResp defines model for v0.0.41_openapi_users_add_cond_resp.
type V0041OpenapiUsersAddCondResp struct {
	// AssociationCondition Filters to select associations for users
	AssociationCondition struct {
		// Accounts CSV accounts list
		Accounts *[]string `json:"accounts,omitempty"`

		// Association Association limits and options
		Association *struct {
			// Comment Arbitrary comment
			Comment *string `json:"comment,omitempty"`

			// Defaultqos Default QOS
			Defaultqos *string `json:"defaultqos,omitempty"`

			// Fairshare Allocated shares used for fairshare calculation
			Fairshare *int32 `json:"fairshare,omitempty"`

			// Grpjobs Maximum number of running jobs in this association and its children
			Grpjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpjobs,omitempty"`

			// Grpjobsaccrue Maximum number of pending jobs able to accrue age priority in this association and its children
			Grpjobsaccrue *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpjobsaccrue,omitempty"`

			// Grpsubmitjobs Maximum number of jobs which can be in a pending or running state at any time in this association and its children
			Grpsubmitjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpsubmitjobs,omitempty"`

			// Grptres Maximum number of TRES able to be allocated by running jobs in this association and its children
			Grptres *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptres,omitempty"`

			// Grptresmins Total number of TRES minutes that can possibly be used by past, present and future jobs in this association and its children
			Grptresmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptresmins,omitempty"`

			// Grptresrunmins Maximum number of TRES minutes able to be allocated by running jobs in this association and its children
			Grptresrunmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptresrunmins,omitempty"`

			// Grpwall Maximum wall clock time in minutes able to be allocated by running jobs in this association and its children
			Grpwall *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpwall,omitempty"`

			// Maxjobs Maximum number of running jobs per user in this association
			Maxjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxjobs,omitempty"`

			// Maxjobsaccrue Maximum number of pending jobs able to accrue age priority at any given time in this association
			Maxjobsaccrue *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxjobsaccrue,omitempty"`

			// Maxsubmitjobs Maximum number of jobs which can be in a pending or running state at any time in this association
			Maxsubmitjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxsubmitjobs,omitempty"`

			// Maxtresminsperjob Maximum number of TRES minutes each job is able to use in this association
			Maxtresminsperjob *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresminsperjob,omitempty"`

			// Maxtresperjob Maximum number of TRES each job is able to use in this association
			Maxtresperjob *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresperjob,omitempty"`

			// Maxtrespernode Maximum number of TRES each node is able to use
			Maxtrespernode *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtrespernode,omitempty"`

			// Maxtresrunmins Maximum number of TRES minutes able to be allocated by running jobs in this association
			Maxtresrunmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresrunmins,omitempty"`

			// Maxwalldurationperjob Maximum wall clock time each job is able to use in this association
			Maxwalldurationperjob *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxwalldurationperjob,omitempty"`

			// Minpriothresh Minimum priority required to reserve resources when scheduling
			Minpriothresh *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minpriothresh,omitempty"`

			// Parent Name of parent account
			Parent *string `json:"parent,omitempty"`

			// Priority Association priority factor
			Priority *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority,omitempty"`

			// Qoslevel List of available QOS names
			Qoslevel *[]string `json:"qoslevel,omitempty"`
		} `json:"association,omitempty"`

		// Clusters CSV clusters list
		Clusters *[]string `json:"clusters,omitempty"`

		// Partitions CSV partitions list
		Partitions *[]string `json:"partitions,omitempty"`

		// Users CSV users list
		Users []string `json:"users"`

		// Wckeys CSV WCKeys list
		Wckeys *[]string `json:"wckeys,omitempty"`
	} `json:"association_condition"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// User Admin level of user, DefaultAccount, DefaultWCKey
	User struct {
		// Adminlevel AdminLevel granted to the user
		Adminlevel *[]V0041OpenapiUsersAddCondRespUserAdminlevel `json:"adminlevel,omitempty"`

		// Defaultaccount Default account
		Defaultaccount *string `json:"defaultaccount,omitempty"`

		// Defaultwckey Default WCKey
		Defaultwckey *string `json:"defaultwckey,omitempty"`
	} `json:"user"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiUsersAddCondRespUserAdminlevel defines model for V0041OpenapiUsersAddCondResp.User.Adminlevel.
type V0041OpenapiUsersAddCondRespUserAdminlevel string

// V0041OpenapiUsersAddCondRespStr defines model for v0.0.41_openapi_users_add_cond_resp_str.
type V0041OpenapiUsersAddCondRespStr struct {
	// AddedUsers added_users
	AddedUsers string `json:"added_users"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiUsersResp defines model for v0.0.41_openapi_users_resp.
type V0041OpenapiUsersResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Users users
	Users []struct {
		// AdministratorLevel AdminLevel granted to the user
		AdministratorLevel *[]V0041OpenapiUsersRespUsersAdministratorLevel `json:"administrator_level,omitempty"`

		// Associations Associations created for this user
		Associations *[]struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"associations,omitempty"`

		// Coordinators Accounts this user is a coordinator for
		Coordinators *[]struct {
			// Direct Indicates whether the coordinator was directly assigned to this account
			Direct *bool `json:"direct,omitempty"`

			// Name User name
			Name string `json:"name"`
		} `json:"coordinators,omitempty"`
		Default *struct {
			// Account Default Account
			Account *string `json:"account,omitempty"`

			// Wckey Default WCKey
			Wckey *string `json:"wckey,omitempty"`
		} `json:"default,omitempty"`

		// Flags Flags associated with user
		Flags *[]V0041OpenapiUsersRespUsersFlags `json:"flags,omitempty"`

		// Name User name
		Name string `json:"name"`

		// OldName Previous user name
		OldName *string `json:"old_name,omitempty"`

		// Wckeys List of available WCKeys
		Wckeys *[]struct {
			// Accounting Accounting records containing related resource usage
			Accounting *[]struct {
				// TRES Trackable resources
				TRES *struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"TRES,omitempty"`
				Allocated *struct {
					// Seconds Number of cpu seconds allocated
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"allocated,omitempty"`

				// Id Association ID or Workload characterization key ID
				Id *int32 `json:"id,omitempty"`

				// Start When the record was started
				Start *int64 `json:"start,omitempty"`
			} `json:"accounting,omitempty"`

			// Cluster Cluster name
			Cluster string `json:"cluster"`

			// Flags Flags associated with the WCKey
			Flags *[]V0041OpenapiUsersRespUsersWckeysFlags `json:"flags,omitempty"`

			// Id Unique ID for this user-cluster-wckey combination
			Id *int32 `json:"id,omitempty"`

			// Name WCKey name
			Name string `json:"name"`

			// User User name
			User string `json:"user"`
		} `json:"wckeys,omitempty"`
	} `json:"users"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiUsersRespUsersAdministratorLevel defines model for V0041OpenapiUsersResp.Users.AdministratorLevel.
type V0041OpenapiUsersRespUsersAdministratorLevel string

// V0041OpenapiUsersRespUsersFlags defines model for V0041OpenapiUsersResp.Users.Flags.
type V0041OpenapiUsersRespUsersFlags string

// V0041OpenapiUsersRespUsersWckeysFlags defines model for V0041OpenapiUsersResp.Users.Wckeys.Flags.
type V0041OpenapiUsersRespUsersWckeysFlags string

// V0041OpenapiWckeyRemovedResp defines model for v0.0.41_openapi_wckey_removed_resp.
type V0041OpenapiWckeyRemovedResp struct {
	// DeletedWckeys deleted wckeys
	DeletedWckeys []string `json:"deleted_wckeys"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiWckeyResp defines model for v0.0.41_openapi_wckey_resp.
type V0041OpenapiWckeyResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`

	// Wckeys wckeys
	Wckeys []struct {
		// Accounting Accounting records containing related resource usage
		Accounting *[]struct {
			// TRES Trackable resources
			TRES *struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"TRES,omitempty"`
			Allocated *struct {
				// Seconds Number of cpu seconds allocated
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"allocated,omitempty"`

			// Id Association ID or Workload characterization key ID
			Id *int32 `json:"id,omitempty"`

			// Start When the record was started
			Start *int64 `json:"start,omitempty"`
		} `json:"accounting,omitempty"`

		// Cluster Cluster name
		Cluster string `json:"cluster"`

		// Flags Flags associated with the WCKey
		Flags *[]V0041OpenapiWckeyRespWckeysFlags `json:"flags,omitempty"`

		// Id Unique ID for this user-cluster-wckey combination
		Id *int32 `json:"id,omitempty"`

		// Name WCKey name
		Name string `json:"name"`

		// User User name
		User string `json:"user"`
	} `json:"wckeys"`
}

// V0041OpenapiWckeyRespWckeysFlags defines model for V0041OpenapiWckeyResp.Wckeys.Flags.
type V0041OpenapiWckeyRespWckeysFlags string

// V0041UpdateNodeMsg defines model for v0.0.41_update_node_msg.
type V0041UpdateNodeMsg struct {
	// Address NodeAddr, used to establish a communication path
	Address *[]string `json:"address,omitempty"`

	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// CpuBind Default method for binding tasks to allocated CPUs
	CpuBind *int32 `json:"cpu_bind,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// Features Available features
	Features *[]string `json:"features,omitempty"`

	// FeaturesAct Currently active features
	FeaturesAct *[]string `json:"features_act,omitempty"`

	// Gres Generic resources
	Gres *string `json:"gres,omitempty"`

	// Hostname NodeHostname
	Hostname *[]string `json:"hostname,omitempty"`

	// Name NodeName
	Name *[]string `json:"name,omitempty"`

	// Reason Reason for node being DOWN or DRAINING
	Reason *string `json:"reason,omitempty"`

	// ReasonUid User ID to associate with the reason (needed if user root is sending message)
	ReasonUid *string `json:"reason_uid,omitempty"`

	// ResumeAfter Number of seconds after which to automatically resume DOWN or DRAINED node
	ResumeAfter *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"resume_after,omitempty"`

	// State New state to assign to the node
	State *[]V0041UpdateNodeMsgState `json:"state,omitempty"`

	// Weight Weight of the node for scheduling purposes
	Weight *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"weight,omitempty"`
}

// V0041UpdateNodeMsgState defines model for V0041UpdateNodeMsg.State.
type V0041UpdateNodeMsgState string

// SlurmV0041DeleteJobParams defines parameters for SlurmV0041DeleteJob.
type SlurmV0041DeleteJobParams struct {
	// Signal Signal to send to Job
	Signal *string `form:"signal,omitempty" json:"signal,omitempty"`

	// Flags Signalling flags
	Flags *SlurmV0041DeleteJobParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041DeleteJobParamsFlags defines parameters for SlurmV0041DeleteJob.
type SlurmV0041DeleteJobParamsFlags string

// SlurmV0041GetJobParams defines parameters for SlurmV0041GetJob.
type SlurmV0041GetJobParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetJobParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetJobParamsFlags defines parameters for SlurmV0041GetJob.
type SlurmV0041GetJobParamsFlags string

// SlurmV0041GetJobsParams defines parameters for SlurmV0041GetJobs.
type SlurmV0041GetJobsParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetJobsParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetJobsParamsFlags defines parameters for SlurmV0041GetJobs.
type SlurmV0041GetJobsParamsFlags string

// SlurmV0041GetJobsStateParams defines parameters for SlurmV0041GetJobsState.
type SlurmV0041GetJobsStateParams struct {
	// JobId Search for CSV list of Job IDs
	JobId *string `form:"job_id,omitempty" json:"job_id,omitempty"`
}

// SlurmV0041GetNodeParams defines parameters for SlurmV0041GetNode.
type SlurmV0041GetNodeParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetNodeParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetNodeParamsFlags defines parameters for SlurmV0041GetNode.
type SlurmV0041GetNodeParamsFlags string

// SlurmV0041GetNodesParams defines parameters for SlurmV0041GetNodes.
type SlurmV0041GetNodesParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetNodesParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetNodesParamsFlags defines parameters for SlurmV0041GetNodes.
type SlurmV0041GetNodesParamsFlags string

// SlurmV0041GetPartitionParams defines parameters for SlurmV0041GetPartition.
type SlurmV0041GetPartitionParams struct {
	// UpdateTime Filter partitions since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetPartitionParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetPartitionParamsFlags defines parameters for SlurmV0041GetPartition.
type SlurmV0041GetPartitionParamsFlags string

// SlurmV0041GetPartitionsParams defines parameters for SlurmV0041GetPartitions.
type SlurmV0041GetPartitionsParams struct {
	// UpdateTime Filter partitions since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetPartitionsParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetPartitionsParamsFlags defines parameters for SlurmV0041GetPartitions.
type SlurmV0041GetPartitionsParamsFlags string

// SlurmV0041GetReservationParams defines parameters for SlurmV0041GetReservation.
type SlurmV0041GetReservationParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0041GetReservationsParams defines parameters for SlurmV0041GetReservations.
type SlurmV0041GetReservationsParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0041GetSharesParams defines parameters for SlurmV0041GetShares.
type SlurmV0041GetSharesParams struct {
	// Accounts Accounts to query
	Accounts *string `form:"accounts,omitempty" json:"accounts,omitempty"`

	// Users Users to query
	Users *string `form:"users,omitempty" json:"users,omitempty"`
}

// SlurmdbV0041GetAccountParams defines parameters for SlurmdbV0041GetAccount.
type SlurmdbV0041GetAccountParams struct {
	// WithAssocs Include associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords Include coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithDeleted Include deleted
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041GetAccountsParams defines parameters for SlurmdbV0041GetAccounts.
type SlurmdbV0041GetAccountsParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// DELETED include deleted associations
	DELETED *string `form:"DELETED,omitempty" json:"DELETED,omitempty"`

	// WithAssociations query includes associations
	WithAssociations *string `form:"WithAssociations,omitempty" json:"WithAssociations,omitempty"`

	// WithCoordinators query includes coordinators
	WithCoordinators *string `form:"WithCoordinators,omitempty" json:"WithCoordinators,omitempty"`

	// NoUsersAreCoords remove users as coordinators
	NoUsersAreCoords *string `form:"NoUsersAreCoords,omitempty" json:"NoUsersAreCoords,omitempty"`

	// UsersAreCoords users are coordinators
	UsersAreCoords *string `form:"UsersAreCoords,omitempty" json:"UsersAreCoords,omitempty"`
}

// SlurmdbV0041DeleteAssociationParams defines parameters for SlurmdbV0041DeleteAssociation.
type SlurmdbV0041DeleteAssociationParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041GetAssociationParams defines parameters for SlurmdbV0041GetAssociation.
type SlurmdbV0041GetAssociationParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041DeleteAssociationsParams defines parameters for SlurmdbV0041DeleteAssociations.
type SlurmdbV0041DeleteAssociationsParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041GetAssociationsParams defines parameters for SlurmdbV0041GetAssociations.
type SlurmdbV0041GetAssociationsParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041DeleteClusterParams defines parameters for SlurmdbV0041DeleteCluster.
type SlurmdbV0041DeleteClusterParams struct {
	// Classification Type of machine
	Classification *SlurmdbV0041DeleteClusterParamsClassification `form:"classification,omitempty" json:"classification,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Federation CSV federation list
	Federation *string `form:"federation,omitempty" json:"federation,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0041DeleteClusterParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// RpcVersion CSV RPC version list
	RpcVersion *string `form:"rpc_version,omitempty" json:"rpc_version,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// WithDeleted Include deleted clusters
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`
}

// SlurmdbV0041DeleteClusterParamsClassification defines parameters for SlurmdbV0041DeleteCluster.
type SlurmdbV0041DeleteClusterParamsClassification string

// SlurmdbV0041DeleteClusterParamsFlags defines parameters for SlurmdbV0041DeleteCluster.
type SlurmdbV0041DeleteClusterParamsFlags string

// SlurmdbV0041GetClusterParams defines parameters for SlurmdbV0041GetCluster.
type SlurmdbV0041GetClusterParams struct {
	// Classification Type of machine
	Classification *SlurmdbV0041GetClusterParamsClassification `form:"classification,omitempty" json:"classification,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Federation CSV federation list
	Federation *string `form:"federation,omitempty" json:"federation,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0041GetClusterParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// RpcVersion CSV RPC version list
	RpcVersion *string `form:"rpc_version,omitempty" json:"rpc_version,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// WithDeleted Include deleted clusters
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`
}

// SlurmdbV0041GetClusterParamsClassification defines parameters for SlurmdbV0041GetCluster.
type SlurmdbV0041GetClusterParamsClassification string

// SlurmdbV0041GetClusterParamsFlags defines parameters for SlurmdbV0041GetCluster.
type SlurmdbV0041GetClusterParamsFlags string

// SlurmdbV0041GetClustersParams defines parameters for SlurmdbV0041GetClusters.
type SlurmdbV0041GetClustersParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmdbV0041PostClustersParams defines parameters for SlurmdbV0041PostClusters.
type SlurmdbV0041PostClustersParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmdbV0041GetInstanceParams defines parameters for SlurmdbV0041GetInstance.
type SlurmdbV0041GetInstanceParams struct {
	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Extra CSV extra list
	Extra *string `form:"extra,omitempty" json:"extra,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// InstanceId CSV instance_id list
	InstanceId *string `form:"instance_id,omitempty" json:"instance_id,omitempty"`

	// InstanceType CSV instance_type list
	InstanceType *string `form:"instance_type,omitempty" json:"instance_type,omitempty"`

	// NodeList Ranged node string
	NodeList *string `form:"node_list,omitempty" json:"node_list,omitempty"`

	// TimeEnd Time end (UNIX timestamp)
	TimeEnd *string `form:"time_end,omitempty" json:"time_end,omitempty"`

	// TimeStart Time start (UNIX timestamp)
	TimeStart *string `form:"time_start,omitempty" json:"time_start,omitempty"`
}

// SlurmdbV0041GetInstancesParams defines parameters for SlurmdbV0041GetInstances.
type SlurmdbV0041GetInstancesParams struct {
	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Extra CSV extra list
	Extra *string `form:"extra,omitempty" json:"extra,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// InstanceId CSV instance_id list
	InstanceId *string `form:"instance_id,omitempty" json:"instance_id,omitempty"`

	// InstanceType CSV instance_type list
	InstanceType *string `form:"instance_type,omitempty" json:"instance_type,omitempty"`

	// NodeList Ranged node string
	NodeList *string `form:"node_list,omitempty" json:"node_list,omitempty"`

	// TimeEnd Time end (UNIX timestamp)
	TimeEnd *string `form:"time_end,omitempty" json:"time_end,omitempty"`

	// TimeStart Time start (UNIX timestamp)
	TimeStart *string `form:"time_start,omitempty" json:"time_start,omitempty"`
}

// SlurmdbV0041GetJobsParams defines parameters for SlurmdbV0041GetJobs.
type SlurmdbV0041GetJobsParams struct {
	// Account CSV account list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Association CSV association list
	Association *string `form:"association,omitempty" json:"association,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Constraints CSV constraint list
	Constraints *string `form:"constraints,omitempty" json:"constraints,omitempty"`

	// SchedulerUnset Schedule bits not set
	SchedulerUnset *string `form:"scheduler_unset,omitempty" json:"scheduler_unset,omitempty"`

	// ScheduledOnSubmit Job was started on submit
	ScheduledOnSubmit *string `form:"scheduled_on_submit,omitempty" json:"scheduled_on_submit,omitempty"`

	// ScheduledByMain Job was started from main scheduler
	ScheduledByMain *string `form:"scheduled_by_main,omitempty" json:"scheduled_by_main,omitempty"`

	// ScheduledByBackfill Job was started from backfill
	ScheduledByBackfill *string `form:"scheduled_by_backfill,omitempty" json:"scheduled_by_backfill,omitempty"`

	// JobStarted Job start RPC was received
	JobStarted *string `form:"job_started,omitempty" json:"job_started,omitempty"`

	// ExitCode Job exit code (numeric)
	ExitCode *string `form:"exit_code,omitempty" json:"exit_code,omitempty"`

	// ShowDuplicates Include duplicate job entries
	ShowDuplicates *string `form:"show_duplicates,omitempty" json:"show_duplicates,omitempty"`

	// SkipSteps Exclude job step details
	SkipSteps *string `form:"skip_steps,omitempty" json:"skip_steps,omitempty"`

	// DisableTruncateUsageTime Do not truncate the time to usage_start and usage_end
	DisableTruncateUsageTime *string `form:"disable_truncate_usage_time,omitempty" json:"disable_truncate_usage_time,omitempty"`

	// WholeHetjob Include details on all hetjob components
	WholeHetjob *string `form:"whole_hetjob,omitempty" json:"whole_hetjob,omitempty"`

	// DisableWholeHetjob Only show details on specified hetjob components
	DisableWholeHetjob *string `form:"disable_whole_hetjob,omitempty" json:"disable_whole_hetjob,omitempty"`

	// DisableWaitForResult Tell dbd not to wait for the result
	DisableWaitForResult *string `form:"disable_wait_for_result,omitempty" json:"disable_wait_for_result,omitempty"`

	// UsageTimeAsSubmitTime Use usage_time as the submit_time of the job
	UsageTimeAsSubmitTime *string `form:"usage_time_as_submit_time,omitempty" json:"usage_time_as_submit_time,omitempty"`

	// ShowBatchScript Include job script
	ShowBatchScript *string `form:"show_batch_script,omitempty" json:"show_batch_script,omitempty"`

	// ShowJobEnvironment Include job environment
	ShowJobEnvironment *string `form:"show_job_environment,omitempty" json:"show_job_environment,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Groups CSV group list
	Groups *string `form:"groups,omitempty" json:"groups,omitempty"`

	// JobName CSV job name list
	JobName *string `form:"job_name,omitempty" json:"job_name,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS name list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// Reason CSV reason list
	Reason *string `form:"reason,omitempty" json:"reason,omitempty"`

	// Reservation CSV reservation name list
	Reservation *string `form:"reservation,omitempty" json:"reservation,omitempty"`

	// ReservationId CSV reservation ID list
	ReservationId *string `form:"reservation_id,omitempty" json:"reservation_id,omitempty"`

	// State CSV state list
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Step CSV step id list
	Step *string `form:"step,omitempty" json:"step,omitempty"`

	// EndTime Usage end (UNIX timestamp)
	EndTime *string `form:"end_time,omitempty" json:"end_time,omitempty"`

	// StartTime Usage start (UNIX timestamp)
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty"`

	// Node Ranged node string where jobs ran
	Node *string `form:"node,omitempty" json:"node,omitempty"`

	// Users CSV user name list
	Users *string `form:"users,omitempty" json:"users,omitempty"`

	// Wckey CSV wckey list
	Wckey *string `form:"wckey,omitempty" json:"wckey,omitempty"`
}

// SlurmdbV0041GetQosParams defines parameters for SlurmdbV0041GetQos.
type SlurmdbV0041GetQosParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Id CSV QOS id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Name CSV QOS name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PreemptMode PreemptMode used when jobs in this QOS are preempted
	PreemptMode *SlurmdbV0041GetQosParamsPreemptMode `form:"preempt_mode,omitempty" json:"preempt_mode,omitempty"`

	// WithDeleted Include deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041GetQosParamsPreemptMode defines parameters for SlurmdbV0041GetQos.
type SlurmdbV0041GetQosParamsPreemptMode string

// SlurmdbV0041PostQosParams defines parameters for SlurmdbV0041PostQos.
type SlurmdbV0041PostQosParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Id CSV QOS id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Name CSV QOS name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PreemptMode PreemptMode used when jobs in this QOS are preempted
	PreemptMode *SlurmdbV0041PostQosParamsPreemptMode `form:"preempt_mode,omitempty" json:"preempt_mode,omitempty"`

	// WithDeleted Include deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041PostQosParamsPreemptMode defines parameters for SlurmdbV0041PostQos.
type SlurmdbV0041PostQosParamsPreemptMode string

// SlurmdbV0041GetSingleQosParams defines parameters for SlurmdbV0041GetSingleQos.
type SlurmdbV0041GetSingleQosParams struct {
	// WithDeleted Query includes deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041GetUserParams defines parameters for SlurmdbV0041GetUser.
type SlurmdbV0041GetUserParams struct {
	// WithDeleted Include deleted users
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithAssocs Include associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords Include coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithWckeys Include wckeys
	WithWckeys *string `form:"with_wckeys,omitempty" json:"with_wckeys,omitempty"`
}

// SlurmdbV0041GetUsersParams defines parameters for SlurmdbV0041GetUsers.
type SlurmdbV0041GetUsersParams struct {
	// AdminLevel Administrator level
	AdminLevel *SlurmdbV0041GetUsersParamsAdminLevel `form:"admin_level,omitempty" json:"admin_level,omitempty"`

	// DefaultAccount CSV default account list
	DefaultAccount *string `form:"default_account,omitempty" json:"default_account,omitempty"`

	// DefaultWckey CSV default wckey list
	DefaultWckey *string `form:"default_wckey,omitempty" json:"default_wckey,omitempty"`

	// WithAssocs With associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords With coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithDeleted With deleted
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithWckeys With wckeys
	WithWckeys *string `form:"with_wckeys,omitempty" json:"with_wckeys,omitempty"`

	// WithoutDefaults Exclude defaults
	WithoutDefaults *string `form:"without_defaults,omitempty" json:"without_defaults,omitempty"`
}

// SlurmdbV0041GetUsersParamsAdminLevel defines parameters for SlurmdbV0041GetUsers.
type SlurmdbV0041GetUsersParamsAdminLevel string

// SlurmdbV0041PostUsersAssociationParams defines parameters for SlurmdbV0041PostUsersAssociation.
type SlurmdbV0041PostUsersAssociationParams struct {
	// UpdateTime Filter partitions since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0041PostUsersAssociationParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmdbV0041PostUsersAssociationParamsFlags defines parameters for SlurmdbV0041PostUsersAssociation.
type SlurmdbV0041PostUsersAssociationParamsFlags string

// SlurmdbV0041GetWckeysParams defines parameters for SlurmdbV0041GetWckeys.
type SlurmdbV0041GetWckeysParams struct {
	// Cluster CSV cluster name list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name CSV name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// OnlyDefaults Only query defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted wckeys
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041PostWckeysParams defines parameters for SlurmdbV0041PostWckeys.
type SlurmdbV0041PostWckeysParams struct {
	// Cluster CSV cluster name list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name CSV name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// OnlyDefaults Only query defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted wckeys
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmV0041PostJobAllocateJSONRequestBody defines body for SlurmV0041PostJobAllocate for application/json ContentType.
type SlurmV0041PostJobAllocateJSONRequestBody = V0041JobAllocReq

// SlurmV0041PostJobSubmitJSONRequestBody defines body for SlurmV0041PostJobSubmit for application/json ContentType.
type SlurmV0041PostJobSubmitJSONRequestBody = V0041JobSubmitReq

// SlurmV0041PostJobJSONRequestBody defines body for SlurmV0041PostJob for application/json ContentType.
type SlurmV0041PostJobJSONRequestBody = V0041JobDescMsg

// SlurmV0041DeleteJobsJSONRequestBody defines body for SlurmV0041DeleteJobs for application/json ContentType.
type SlurmV0041DeleteJobsJSONRequestBody = V0041KillJobsMsg

// SlurmV0041PostNodeJSONRequestBody defines body for SlurmV0041PostNode for application/json ContentType.
type SlurmV0041PostNodeJSONRequestBody = V0041UpdateNodeMsg

// SlurmV0041PostNodesJSONRequestBody defines body for SlurmV0041PostNodes for application/json ContentType.
type SlurmV0041PostNodesJSONRequestBody = V0041UpdateNodeMsg

// SlurmdbV0041PostAccountsJSONRequestBody defines body for SlurmdbV0041PostAccounts for application/json ContentType.
type SlurmdbV0041PostAccountsJSONRequestBody = V0041OpenapiAccountsResp

// SlurmdbV0041PostAccountsAssociationJSONRequestBody defines body for SlurmdbV0041PostAccountsAssociation for application/json ContentType.
type SlurmdbV0041PostAccountsAssociationJSONRequestBody = V0041OpenapiAccountsAddCondResp

// SlurmdbV0041PostAssociationsJSONRequestBody defines body for SlurmdbV0041PostAssociations for application/json ContentType.
type SlurmdbV0041PostAssociationsJSONRequestBody = V0041OpenapiAssocsResp

// SlurmdbV0041PostClustersJSONRequestBody defines body for SlurmdbV0041PostClusters for application/json ContentType.
type SlurmdbV0041PostClustersJSONRequestBody = V0041OpenapiClustersResp

// SlurmdbV0041PostConfigJSONRequestBody defines body for SlurmdbV0041PostConfig for application/json ContentType.
type SlurmdbV0041PostConfigJSONRequestBody = V0041OpenapiSlurmdbdConfigResp

// SlurmdbV0041PostQosJSONRequestBody defines body for SlurmdbV0041PostQos for application/json ContentType.
type SlurmdbV0041PostQosJSONRequestBody = V0041OpenapiSlurmdbdQosResp

// SlurmdbV0041PostTresJSONRequestBody defines body for SlurmdbV0041PostTres for application/json ContentType.
type SlurmdbV0041PostTresJSONRequestBody = V0041OpenapiTresResp

// SlurmdbV0041PostUsersJSONRequestBody defines body for SlurmdbV0041PostUsers for application/json ContentType.
type SlurmdbV0041PostUsersJSONRequestBody = V0041OpenapiUsersResp

// SlurmdbV0041PostUsersAssociationJSONRequestBody defines body for SlurmdbV0041PostUsersAssociation for application/json ContentType.
type SlurmdbV0041PostUsersAssociationJSONRequestBody = V0041OpenapiUsersAddCondResp

// SlurmdbV0041PostWckeysJSONRequestBody defines body for SlurmdbV0041PostWckeys for application/json ContentType.
type SlurmdbV0041PostWckeysJSONRequestBody = V0041OpenapiWckeyResp

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SlurmV0041GetDiag request
	SlurmV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostJobAllocateWithBody request with any body
	SlurmV0041PostJobAllocateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostJobAllocate(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostJobSubmitWithBody request with any body
	SlurmV0041PostJobSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostJobSubmit(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteJob request
	SlurmV0041DeleteJob(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetJob request
	SlurmV0041GetJob(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostJobWithBody request with any body
	SlurmV0041PostJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostJob(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteJobsWithBody request with any body
	SlurmV0041DeleteJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041DeleteJobs(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetJobs request
	SlurmV0041GetJobs(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetJobsState request
	SlurmV0041GetJobsState(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetLicenses request
	SlurmV0041GetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteNode request
	SlurmV0041DeleteNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetNode request
	SlurmV0041GetNode(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostNodeWithBody request with any body
	SlurmV0041PostNodeWithBody(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostNode(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetNodes request
	SlurmV0041GetNodes(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostNodesWithBody request with any body
	SlurmV0041PostNodesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostNodes(ctx context.Context, body SlurmV0041PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetPartition request
	SlurmV0041GetPartition(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetPartitions request
	SlurmV0041GetPartitions(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetPing request
	SlurmV0041GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetReconfigure request
	SlurmV0041GetReconfigure(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteReservation request
	SlurmV0041DeleteReservation(ctx context.Context, reservationName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetReservation request
	SlurmV0041GetReservation(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetReservations request
	SlurmV0041GetReservations(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetShares request
	SlurmV0041GetShares(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteAccount request
	SlurmdbV0041DeleteAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAccount request
	SlurmdbV0041GetAccount(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAccounts request
	SlurmdbV0041GetAccounts(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostAccountsWithBody request with any body
	SlurmdbV0041PostAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostAccounts(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostAccountsAssociationWithBody request with any body
	SlurmdbV0041PostAccountsAssociationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostAccountsAssociation(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteAssociation request
	SlurmdbV0041DeleteAssociation(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAssociation request
	SlurmdbV0041GetAssociation(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteAssociations request
	SlurmdbV0041DeleteAssociations(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAssociations request
	SlurmdbV0041GetAssociations(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostAssociationsWithBody request with any body
	SlurmdbV0041PostAssociationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostAssociations(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteCluster request
	SlurmdbV0041DeleteCluster(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetCluster request
	SlurmdbV0041GetCluster(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetClusters request
	SlurmdbV0041GetClusters(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostClustersWithBody request with any body
	SlurmdbV0041PostClustersWithBody(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostClusters(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetConfig request
	SlurmdbV0041GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostConfigWithBody request with any body
	SlurmdbV0041PostConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostConfig(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetDiag request
	SlurmdbV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetInstance request
	SlurmdbV0041GetInstance(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetInstances request
	SlurmdbV0041GetInstances(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetJob request
	SlurmdbV0041GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetJobs request
	SlurmdbV0041GetJobs(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetQos request
	SlurmdbV0041GetQos(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostQosWithBody request with any body
	SlurmdbV0041PostQosWithBody(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostQos(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteSingleQos request
	SlurmdbV0041DeleteSingleQos(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetSingleQos request
	SlurmdbV0041GetSingleQos(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetTres request
	SlurmdbV0041GetTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostTresWithBody request with any body
	SlurmdbV0041PostTresWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostTres(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteUser request
	SlurmdbV0041DeleteUser(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetUser request
	SlurmdbV0041GetUser(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetUsers request
	SlurmdbV0041GetUsers(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostUsersWithBody request with any body
	SlurmdbV0041PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostUsers(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostUsersAssociationWithBody request with any body
	SlurmdbV0041PostUsersAssociationWithBody(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostUsersAssociation(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteWckey request
	SlurmdbV0041DeleteWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetWckey request
	SlurmdbV0041GetWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetWckeys request
	SlurmdbV0041GetWckeys(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostWckeysWithBody request with any body
	SlurmdbV0041PostWckeysWithBody(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostWckeys(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SlurmV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobAllocateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobAllocateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobAllocate(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobAllocateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobSubmitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobSubmit(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobSubmitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteJob(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetJob(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJob(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteJobs(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetJobs(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetJobsState(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetJobsStateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetLicensesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteNodeRequest(c.Server, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetNode(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetNodeRequest(c.Server, nodeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNodeWithBody(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodeRequestWithBody(c.Server, nodeName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNode(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodeRequest(c.Server, nodeName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetNodes(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetNodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNodesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNodes(ctx context.Context, body SlurmV0041PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetPartition(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetPartitionRequest(c.Server, partitionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetPartitions(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetPartitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetReconfigure(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetReconfigureRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteReservation(ctx context.Context, reservationName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteReservationRequest(c.Server, reservationName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetReservation(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetReservationRequest(c.Server, reservationName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetReservations(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetReservationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetShares(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetSharesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteAccountRequest(c.Server, accountName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAccount(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAccountRequest(c.Server, accountName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAccounts(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccounts(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccountsAssociationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsAssociationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccountsAssociation(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsAssociationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteAssociation(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteAssociationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAssociation(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAssociationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteAssociations(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAssociations(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAssociationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAssociationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAssociations(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAssociationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteCluster(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteClusterRequest(c.Server, clusterName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetCluster(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetClusterRequest(c.Server, clusterName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetClusters(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostClustersWithBody(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostClustersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostClusters(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostClustersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostConfig(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetInstance(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetInstanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetInstances(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetInstancesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetJobs(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetQos(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetQosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostQosWithBody(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostQosRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostQos(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostQosRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteSingleQos(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteSingleQosRequest(c.Server, qos)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetSingleQos(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetSingleQosRequest(c.Server, qos, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetTresRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostTresWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostTresRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostTres(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostTresRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteUser(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteUserRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetUser(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetUserRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetUsers(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsers(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsersAssociationWithBody(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersAssociationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsersAssociation(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersAssociationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteWckeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetWckeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetWckeys(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetWckeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostWckeysWithBody(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostWckeysRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostWckeys(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostWckeysRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSlurmV0041GetDiagRequest generates requests for SlurmV0041GetDiag
func NewSlurmV0041GetDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/diag/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostJobAllocateRequest calls the generic SlurmV0041PostJobAllocate builder with application/json body
func NewSlurmV0041PostJobAllocateRequest(server string, body SlurmV0041PostJobAllocateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostJobAllocateRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041PostJobAllocateRequestWithBody generates requests for SlurmV0041PostJobAllocate with any type of body
func NewSlurmV0041PostJobAllocateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/allocate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041PostJobSubmitRequest calls the generic SlurmV0041PostJobSubmit builder with application/json body
func NewSlurmV0041PostJobSubmitRequest(server string, body SlurmV0041PostJobSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostJobSubmitRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041PostJobSubmitRequestWithBody generates requests for SlurmV0041PostJobSubmit with any type of body
func NewSlurmV0041PostJobSubmitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041DeleteJobRequest generates requests for SlurmV0041DeleteJob
func NewSlurmV0041DeleteJobRequest(server string, jobId string, params *SlurmV0041DeleteJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Signal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "signal", runtime.ParamLocationQuery, *params.Signal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetJobRequest generates requests for SlurmV0041GetJob
func NewSlurmV0041GetJobRequest(server string, jobId string, params *SlurmV0041GetJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostJobRequest calls the generic SlurmV0041PostJob builder with application/json body
func NewSlurmV0041PostJobRequest(server string, jobId string, body SlurmV0041PostJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostJobRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewSlurmV0041PostJobRequestWithBody generates requests for SlurmV0041PostJob with any type of body
func NewSlurmV0041PostJobRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041DeleteJobsRequest calls the generic SlurmV0041DeleteJobs builder with application/json body
func NewSlurmV0041DeleteJobsRequest(server string, body SlurmV0041DeleteJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041DeleteJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041DeleteJobsRequestWithBody generates requests for SlurmV0041DeleteJobs with any type of body
func NewSlurmV0041DeleteJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041GetJobsRequest generates requests for SlurmV0041GetJobs
func NewSlurmV0041GetJobsRequest(server string, params *SlurmV0041GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetJobsStateRequest generates requests for SlurmV0041GetJobsState
func NewSlurmV0041GetJobsStateRequest(server string, params *SlurmV0041GetJobsStateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/jobs/state/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetLicensesRequest generates requests for SlurmV0041GetLicenses
func NewSlurmV0041GetLicensesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/licenses/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041DeleteNodeRequest generates requests for SlurmV0041DeleteNode
func NewSlurmV0041DeleteNodeRequest(server string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetNodeRequest generates requests for SlurmV0041GetNode
func NewSlurmV0041GetNodeRequest(server string, nodeName string, params *SlurmV0041GetNodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostNodeRequest calls the generic SlurmV0041PostNode builder with application/json body
func NewSlurmV0041PostNodeRequest(server string, nodeName string, body SlurmV0041PostNodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostNodeRequestWithBody(server, nodeName, "application/json", bodyReader)
}

// NewSlurmV0041PostNodeRequestWithBody generates requests for SlurmV0041PostNode with any type of body
func NewSlurmV0041PostNodeRequestWithBody(server string, nodeName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041GetNodesRequest generates requests for SlurmV0041GetNodes
func NewSlurmV0041GetNodesRequest(server string, params *SlurmV0041GetNodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/nodes/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostNodesRequest calls the generic SlurmV0041PostNodes builder with application/json body
func NewSlurmV0041PostNodesRequest(server string, body SlurmV0041PostNodesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostNodesRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041PostNodesRequestWithBody generates requests for SlurmV0041PostNodes with any type of body
func NewSlurmV0041PostNodesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/nodes/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041GetPartitionRequest generates requests for SlurmV0041GetPartition
func NewSlurmV0041GetPartitionRequest(server string, partitionName string, params *SlurmV0041GetPartitionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "partition_name", runtime.ParamLocationPath, partitionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/partition/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetPartitionsRequest generates requests for SlurmV0041GetPartitions
func NewSlurmV0041GetPartitionsRequest(server string, params *SlurmV0041GetPartitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/partitions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetPingRequest generates requests for SlurmV0041GetPing
func NewSlurmV0041GetPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/ping/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetReconfigureRequest generates requests for SlurmV0041GetReconfigure
func NewSlurmV0041GetReconfigureRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reconfigure/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041DeleteReservationRequest generates requests for SlurmV0041DeleteReservation
func NewSlurmV0041DeleteReservationRequest(server string, reservationName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservation_name", runtime.ParamLocationPath, reservationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetReservationRequest generates requests for SlurmV0041GetReservation
func NewSlurmV0041GetReservationRequest(server string, reservationName string, params *SlurmV0041GetReservationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservation_name", runtime.ParamLocationPath, reservationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetReservationsRequest generates requests for SlurmV0041GetReservations
func NewSlurmV0041GetReservationsRequest(server string, params *SlurmV0041GetReservationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reservations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetSharesRequest generates requests for SlurmV0041GetShares
func NewSlurmV0041GetSharesRequest(server string, params *SlurmV0041GetSharesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/shares")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "accounts", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Users != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "users", runtime.ParamLocationQuery, *params.Users); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041DeleteAccountRequest generates requests for SlurmdbV0041DeleteAccount
func NewSlurmdbV0041DeleteAccountRequest(server string, accountName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_name", runtime.ParamLocationPath, accountName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAccountRequest generates requests for SlurmdbV0041GetAccount
func NewSlurmdbV0041GetAccountRequest(server string, accountName string, params *SlurmdbV0041GetAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_name", runtime.ParamLocationPath, accountName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAccountsRequest generates requests for SlurmdbV0041GetAccounts
func NewSlurmdbV0041GetAccountsRequest(server string, params *SlurmdbV0041GetAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/accounts/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DELETED != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "DELETED", runtime.ParamLocationQuery, *params.DELETED); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssociations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "WithAssociations", runtime.ParamLocationQuery, *params.WithAssociations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoordinators != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "WithCoordinators", runtime.ParamLocationQuery, *params.WithCoordinators); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoUsersAreCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "NoUsersAreCoords", runtime.ParamLocationQuery, *params.NoUsersAreCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsersAreCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "UsersAreCoords", runtime.ParamLocationQuery, *params.UsersAreCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostAccountsRequest calls the generic SlurmdbV0041PostAccounts builder with application/json body
func NewSlurmdbV0041PostAccountsRequest(server string, body SlurmdbV0041PostAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostAccountsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostAccountsRequestWithBody generates requests for SlurmdbV0041PostAccounts with any type of body
func NewSlurmdbV0041PostAccountsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/accounts/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041PostAccountsAssociationRequest calls the generic SlurmdbV0041PostAccountsAssociation builder with application/json body
func NewSlurmdbV0041PostAccountsAssociationRequest(server string, body SlurmdbV0041PostAccountsAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostAccountsAssociationRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostAccountsAssociationRequestWithBody generates requests for SlurmdbV0041PostAccountsAssociation with any type of body
func NewSlurmdbV0041PostAccountsAssociationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/accounts_association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteAssociationRequest generates requests for SlurmdbV0041DeleteAssociation
func NewSlurmdbV0041DeleteAssociationRequest(server string, params *SlurmdbV0041DeleteAssociationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAssociationRequest generates requests for SlurmdbV0041GetAssociation
func NewSlurmdbV0041GetAssociationRequest(server string, params *SlurmdbV0041GetAssociationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041DeleteAssociationsRequest generates requests for SlurmdbV0041DeleteAssociations
func NewSlurmdbV0041DeleteAssociationsRequest(server string, params *SlurmdbV0041DeleteAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAssociationsRequest generates requests for SlurmdbV0041GetAssociations
func NewSlurmdbV0041GetAssociationsRequest(server string, params *SlurmdbV0041GetAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostAssociationsRequest calls the generic SlurmdbV0041PostAssociations builder with application/json body
func NewSlurmdbV0041PostAssociationsRequest(server string, body SlurmdbV0041PostAssociationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostAssociationsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostAssociationsRequestWithBody generates requests for SlurmdbV0041PostAssociations with any type of body
func NewSlurmdbV0041PostAssociationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteClusterRequest generates requests for SlurmdbV0041DeleteCluster
func NewSlurmdbV0041DeleteClusterRequest(server string, clusterName string, params *SlurmdbV0041DeleteClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_name", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Classification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "classification", runtime.ParamLocationQuery, *params.Classification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Federation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "federation", runtime.ParamLocationQuery, *params.Federation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RpcVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rpc_version", runtime.ParamLocationQuery, *params.RpcVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetClusterRequest generates requests for SlurmdbV0041GetCluster
func NewSlurmdbV0041GetClusterRequest(server string, clusterName string, params *SlurmdbV0041GetClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_name", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Classification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "classification", runtime.ParamLocationQuery, *params.Classification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Federation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "federation", runtime.ParamLocationQuery, *params.Federation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RpcVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rpc_version", runtime.ParamLocationQuery, *params.RpcVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetClustersRequest generates requests for SlurmdbV0041GetClusters
func NewSlurmdbV0041GetClustersRequest(server string, params *SlurmdbV0041GetClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/clusters/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostClustersRequest calls the generic SlurmdbV0041PostClusters builder with application/json body
func NewSlurmdbV0041PostClustersRequest(server string, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostClustersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostClustersRequestWithBody generates requests for SlurmdbV0041PostClusters with any type of body
func NewSlurmdbV0041PostClustersRequestWithBody(server string, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/clusters/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041GetConfigRequest generates requests for SlurmdbV0041GetConfig
func NewSlurmdbV0041GetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostConfigRequest calls the generic SlurmdbV0041PostConfig builder with application/json body
func NewSlurmdbV0041PostConfigRequest(server string, body SlurmdbV0041PostConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostConfigRequestWithBody generates requests for SlurmdbV0041PostConfig with any type of body
func NewSlurmdbV0041PostConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041GetDiagRequest generates requests for SlurmdbV0041GetDiag
func NewSlurmdbV0041GetDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/diag/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetInstanceRequest generates requests for SlurmdbV0041GetInstance
func NewSlurmdbV0041GetInstanceRequest(server string, params *SlurmdbV0041GetInstanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/instance/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Extra != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "extra", runtime.ParamLocationQuery, *params.Extra); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_id", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_type", runtime.ParamLocationQuery, *params.InstanceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodeList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node_list", runtime.ParamLocationQuery, *params.NodeList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_end", runtime.ParamLocationQuery, *params.TimeEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_start", runtime.ParamLocationQuery, *params.TimeStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetInstancesRequest generates requests for SlurmdbV0041GetInstances
func NewSlurmdbV0041GetInstancesRequest(server string, params *SlurmdbV0041GetInstancesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/instances/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Extra != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "extra", runtime.ParamLocationQuery, *params.Extra); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_id", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_type", runtime.ParamLocationQuery, *params.InstanceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodeList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node_list", runtime.ParamLocationQuery, *params.NodeList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_end", runtime.ParamLocationQuery, *params.TimeEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_start", runtime.ParamLocationQuery, *params.TimeStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetJobRequest generates requests for SlurmdbV0041GetJob
func NewSlurmdbV0041GetJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetJobsRequest generates requests for SlurmdbV0041GetJobs
func NewSlurmdbV0041GetJobsRequest(server string, params *SlurmdbV0041GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Association != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "association", runtime.ParamLocationQuery, *params.Association); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Constraints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "constraints", runtime.ParamLocationQuery, *params.Constraints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchedulerUnset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduler_unset", runtime.ParamLocationQuery, *params.SchedulerUnset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledOnSubmit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_on_submit", runtime.ParamLocationQuery, *params.ScheduledOnSubmit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledByMain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_by_main", runtime.ParamLocationQuery, *params.ScheduledByMain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledByBackfill != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_by_backfill", runtime.ParamLocationQuery, *params.ScheduledByBackfill); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobStarted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_started", runtime.ParamLocationQuery, *params.JobStarted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExitCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exit_code", runtime.ParamLocationQuery, *params.ExitCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowDuplicates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_duplicates", runtime.ParamLocationQuery, *params.ShowDuplicates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipSteps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "skip_steps", runtime.ParamLocationQuery, *params.SkipSteps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableTruncateUsageTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_truncate_usage_time", runtime.ParamLocationQuery, *params.DisableTruncateUsageTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WholeHetjob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "whole_hetjob", runtime.ParamLocationQuery, *params.WholeHetjob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableWholeHetjob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_whole_hetjob", runtime.ParamLocationQuery, *params.DisableWholeHetjob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableWaitForResult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_wait_for_result", runtime.ParamLocationQuery, *params.DisableWaitForResult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageTimeAsSubmitTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_time_as_submit_time", runtime.ParamLocationQuery, *params.UsageTimeAsSubmitTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowBatchScript != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_batch_script", runtime.ParamLocationQuery, *params.ShowBatchScript); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowJobEnvironment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_job_environment", runtime.ParamLocationQuery, *params.ShowJobEnvironment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Groups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "groups", runtime.ParamLocationQuery, *params.Groups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_name", runtime.ParamLocationQuery, *params.JobName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reason", runtime.ParamLocationQuery, *params.Reason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reservation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reservation", runtime.ParamLocationQuery, *params.Reservation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReservationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reservation_id", runtime.ParamLocationQuery, *params.ReservationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Step != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "step", runtime.ParamLocationQuery, *params.Step); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Node != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node", runtime.ParamLocationQuery, *params.Node); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Users != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "users", runtime.ParamLocationQuery, *params.Users); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Wckey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "wckey", runtime.ParamLocationQuery, *params.Wckey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetQosRequest generates requests for SlurmdbV0041GetQos
func NewSlurmdbV0041GetQosRequest(server string, params *SlurmdbV0041GetQosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreemptMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "preempt_mode", runtime.ParamLocationQuery, *params.PreemptMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostQosRequest calls the generic SlurmdbV0041PostQos builder with application/json body
func NewSlurmdbV0041PostQosRequest(server string, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostQosRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostQosRequestWithBody generates requests for SlurmdbV0041PostQos with any type of body
func NewSlurmdbV0041PostQosRequestWithBody(server string, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreemptMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "preempt_mode", runtime.ParamLocationQuery, *params.PreemptMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteSingleQosRequest generates requests for SlurmdbV0041DeleteSingleQos
func NewSlurmdbV0041DeleteSingleQosRequest(server string, qos string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "qos", runtime.ParamLocationPath, qos)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetSingleQosRequest generates requests for SlurmdbV0041GetSingleQos
func NewSlurmdbV0041GetSingleQosRequest(server string, qos string, params *SlurmdbV0041GetSingleQosParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "qos", runtime.ParamLocationPath, qos)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetTresRequest generates requests for SlurmdbV0041GetTres
func NewSlurmdbV0041GetTresRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/tres/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostTresRequest calls the generic SlurmdbV0041PostTres builder with application/json body
func NewSlurmdbV0041PostTresRequest(server string, body SlurmdbV0041PostTresJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostTresRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostTresRequestWithBody generates requests for SlurmdbV0041PostTres with any type of body
func NewSlurmdbV0041PostTresRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/tres/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteUserRequest generates requests for SlurmdbV0041DeleteUser
func NewSlurmdbV0041DeleteUserRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetUserRequest generates requests for SlurmdbV0041GetUser
func NewSlurmdbV0041GetUserRequest(server string, name string, params *SlurmdbV0041GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWckeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_wckeys", runtime.ParamLocationQuery, *params.WithWckeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetUsersRequest generates requests for SlurmdbV0041GetUsers
func NewSlurmdbV0041GetUsersRequest(server string, params *SlurmdbV0041GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/users/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AdminLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "admin_level", runtime.ParamLocationQuery, *params.AdminLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_account", runtime.ParamLocationQuery, *params.DefaultAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultWckey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_wckey", runtime.ParamLocationQuery, *params.DefaultWckey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWckeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_wckeys", runtime.ParamLocationQuery, *params.WithWckeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_defaults", runtime.ParamLocationQuery, *params.WithoutDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostUsersRequest calls the generic SlurmdbV0041PostUsers builder with application/json body
func NewSlurmdbV0041PostUsersRequest(server string, body SlurmdbV0041PostUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostUsersRequestWithBody generates requests for SlurmdbV0041PostUsers with any type of body
func NewSlurmdbV0041PostUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/users/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041PostUsersAssociationRequest calls the generic SlurmdbV0041PostUsersAssociation builder with application/json body
func NewSlurmdbV0041PostUsersAssociationRequest(server string, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostUsersAssociationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostUsersAssociationRequestWithBody generates requests for SlurmdbV0041PostUsersAssociation with any type of body
func NewSlurmdbV0041PostUsersAssociationRequestWithBody(server string, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/users_association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteWckeyRequest generates requests for SlurmdbV0041DeleteWckey
func NewSlurmdbV0041DeleteWckeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetWckeyRequest generates requests for SlurmdbV0041GetWckey
func NewSlurmdbV0041GetWckeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetWckeysRequest generates requests for SlurmdbV0041GetWckeys
func NewSlurmdbV0041GetWckeysRequest(server string, params *SlurmdbV0041GetWckeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckeys/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostWckeysRequest calls the generic SlurmdbV0041PostWckeys builder with application/json body
func NewSlurmdbV0041PostWckeysRequest(server string, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostWckeysRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostWckeysRequestWithBody generates requests for SlurmdbV0041PostWckeys with any type of body
func NewSlurmdbV0041PostWckeysRequestWithBody(server string, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckeys/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SlurmV0041GetDiagWithResponse request
	SlurmV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetDiagResponse, error)

	// SlurmV0041PostJobAllocateWithBodyWithResponse request with any body
	SlurmV0041PostJobAllocateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error)

	SlurmV0041PostJobAllocateWithResponse(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error)

	// SlurmV0041PostJobSubmitWithBodyWithResponse request with any body
	SlurmV0041PostJobSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error)

	SlurmV0041PostJobSubmitWithResponse(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error)

	// SlurmV0041DeleteJobWithResponse request
	SlurmV0041DeleteJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobResponse, error)

	// SlurmV0041GetJobWithResponse request
	SlurmV0041GetJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobResponse, error)

	// SlurmV0041PostJobWithBodyWithResponse request with any body
	SlurmV0041PostJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error)

	SlurmV0041PostJobWithResponse(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error)

	// SlurmV0041DeleteJobsWithBodyWithResponse request with any body
	SlurmV0041DeleteJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error)

	SlurmV0041DeleteJobsWithResponse(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error)

	// SlurmV0041GetJobsWithResponse request
	SlurmV0041GetJobsWithResponse(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsResponse, error)

	// SlurmV0041GetJobsStateWithResponse request
	SlurmV0041GetJobsStateWithResponse(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsStateResponse, error)

	// SlurmV0041GetLicensesWithResponse request
	SlurmV0041GetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetLicensesResponse, error)

	// SlurmV0041DeleteNodeWithResponse request
	SlurmV0041DeleteNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteNodeResponse, error)

	// SlurmV0041GetNodeWithResponse request
	SlurmV0041GetNodeWithResponse(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodeResponse, error)

	// SlurmV0041PostNodeWithBodyWithResponse request with any body
	SlurmV0041PostNodeWithBodyWithResponse(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error)

	SlurmV0041PostNodeWithResponse(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error)

	// SlurmV0041GetNodesWithResponse request
	SlurmV0041GetNodesWithResponse(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodesResponse, error)

	// SlurmV0041PostNodesWithBodyWithResponse request with any body
	SlurmV0041PostNodesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodesResponse, error)

	SlurmV0041PostNodesWithResponse(ctx context.Context, body SlurmV0041PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodesResponse, error)

	// SlurmV0041GetPartitionWithResponse request
	SlurmV0041GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionResponse, error)

	// SlurmV0041GetPartitionsWithResponse request
	SlurmV0041GetPartitionsWithResponse(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionsResponse, error)

	// SlurmV0041GetPingWithResponse request
	SlurmV0041GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetPingResponse, error)

	// SlurmV0041GetReconfigureWithResponse request
	SlurmV0041GetReconfigureWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetReconfigureResponse, error)

	// SlurmV0041DeleteReservationWithResponse request
	SlurmV0041DeleteReservationWithResponse(ctx context.Context, reservationName string, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteReservationResponse, error)

	// SlurmV0041GetReservationWithResponse request
	SlurmV0041GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationResponse, error)

	// SlurmV0041GetReservationsWithResponse request
	SlurmV0041GetReservationsWithResponse(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationsResponse, error)

	// SlurmV0041GetSharesWithResponse request
	SlurmV0041GetSharesWithResponse(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetSharesResponse, error)

	// SlurmdbV0041DeleteAccountWithResponse request
	SlurmdbV0041DeleteAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAccountResponse, error)

	// SlurmdbV0041GetAccountWithResponse request
	SlurmdbV0041GetAccountWithResponse(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountResponse, error)

	// SlurmdbV0041GetAccountsWithResponse request
	SlurmdbV0041GetAccountsWithResponse(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountsResponse, error)

	// SlurmdbV0041PostAccountsWithBodyWithResponse request with any body
	SlurmdbV0041PostAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error)

	SlurmdbV0041PostAccountsWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error)

	// SlurmdbV0041PostAccountsAssociationWithBodyWithResponse request with any body
	SlurmdbV0041PostAccountsAssociationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error)

	SlurmdbV0041PostAccountsAssociationWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error)

	// SlurmdbV0041DeleteAssociationWithResponse request
	SlurmdbV0041DeleteAssociationWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationResponse, error)

	// SlurmdbV0041GetAssociationWithResponse request
	SlurmdbV0041GetAssociationWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationResponse, error)

	// SlurmdbV0041DeleteAssociationsWithResponse request
	SlurmdbV0041DeleteAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationsResponse, error)

	// SlurmdbV0041GetAssociationsWithResponse request
	SlurmdbV0041GetAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationsResponse, error)

	// SlurmdbV0041PostAssociationsWithBodyWithResponse request with any body
	SlurmdbV0041PostAssociationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error)

	SlurmdbV0041PostAssociationsWithResponse(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error)

	// SlurmdbV0041DeleteClusterWithResponse request
	SlurmdbV0041DeleteClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteClusterResponse, error)

	// SlurmdbV0041GetClusterWithResponse request
	SlurmdbV0041GetClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClusterResponse, error)

	// SlurmdbV0041GetClustersWithResponse request
	SlurmdbV0041GetClustersWithResponse(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClustersResponse, error)

	// SlurmdbV0041PostClustersWithBodyWithResponse request with any body
	SlurmdbV0041PostClustersWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error)

	SlurmdbV0041PostClustersWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error)

	// SlurmdbV0041GetConfigWithResponse request
	SlurmdbV0041GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetConfigResponse, error)

	// SlurmdbV0041PostConfigWithBodyWithResponse request with any body
	SlurmdbV0041PostConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error)

	SlurmdbV0041PostConfigWithResponse(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error)

	// SlurmdbV0041GetDiagWithResponse request
	SlurmdbV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetDiagResponse, error)

	// SlurmdbV0041GetInstanceWithResponse request
	SlurmdbV0041GetInstanceWithResponse(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstanceResponse, error)

	// SlurmdbV0041GetInstancesWithResponse request
	SlurmdbV0041GetInstancesWithResponse(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstancesResponse, error)

	// SlurmdbV0041GetJobWithResponse request
	SlurmdbV0041GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobResponse, error)

	// SlurmdbV0041GetJobsWithResponse request
	SlurmdbV0041GetJobsWithResponse(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobsResponse, error)

	// SlurmdbV0041GetQosWithResponse request
	SlurmdbV0041GetQosWithResponse(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetQosResponse, error)

	// SlurmdbV0041PostQosWithBodyWithResponse request with any body
	SlurmdbV0041PostQosWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error)

	SlurmdbV0041PostQosWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error)

	// SlurmdbV0041DeleteSingleQosWithResponse request
	SlurmdbV0041DeleteSingleQosWithResponse(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteSingleQosResponse, error)

	// SlurmdbV0041GetSingleQosWithResponse request
	SlurmdbV0041GetSingleQosWithResponse(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetSingleQosResponse, error)

	// SlurmdbV0041GetTresWithResponse request
	SlurmdbV0041GetTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetTresResponse, error)

	// SlurmdbV0041PostTresWithBodyWithResponse request with any body
	SlurmdbV0041PostTresWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error)

	SlurmdbV0041PostTresWithResponse(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error)

	// SlurmdbV0041DeleteUserWithResponse request
	SlurmdbV0041DeleteUserWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteUserResponse, error)

	// SlurmdbV0041GetUserWithResponse request
	SlurmdbV0041GetUserWithResponse(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUserResponse, error)

	// SlurmdbV0041GetUsersWithResponse request
	SlurmdbV0041GetUsersWithResponse(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUsersResponse, error)

	// SlurmdbV0041PostUsersWithBodyWithResponse request with any body
	SlurmdbV0041PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error)

	SlurmdbV0041PostUsersWithResponse(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error)

	// SlurmdbV0041PostUsersAssociationWithBodyWithResponse request with any body
	SlurmdbV0041PostUsersAssociationWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error)

	SlurmdbV0041PostUsersAssociationWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error)

	// SlurmdbV0041DeleteWckeyWithResponse request
	SlurmdbV0041DeleteWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteWckeyResponse, error)

	// SlurmdbV0041GetWckeyWithResponse request
	SlurmdbV0041GetWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeyResponse, error)

	// SlurmdbV0041GetWckeysWithResponse request
	SlurmdbV0041GetWckeysWithResponse(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeysResponse, error)

	// SlurmdbV0041PostWckeysWithBodyWithResponse request with any body
	SlurmdbV0041PostWckeysWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error)

	SlurmdbV0041PostWckeysWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error)
}

type SlurmV0041GetDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiDiagResp
	YAML200      *V0041OpenapiDiagResp
	JSONDefault  *V0041OpenapiDiagResp
	YAMLDefault  *V0041OpenapiDiagResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostJobAllocateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobAllocResp
	YAML200      *V0041OpenapiJobAllocResp
	JSONDefault  *V0041OpenapiJobAllocResp
	YAMLDefault  *V0041OpenapiJobAllocResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostJobAllocateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostJobAllocateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostJobSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobSubmitResponse
	YAML200      *V0041OpenapiJobSubmitResponse
	JSONDefault  *V0041OpenapiJobSubmitResponse
	YAMLDefault  *V0041OpenapiJobSubmitResponse
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostJobSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostJobSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobInfoResp
	YAML200      *V0041OpenapiJobInfoResp
	JSONDefault  *V0041OpenapiJobInfoResp
	YAMLDefault  *V0041OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobPostResponse
	YAML200      *V0041OpenapiJobPostResponse
	JSONDefault  *V0041OpenapiJobPostResponse
	YAMLDefault  *V0041OpenapiJobPostResponse
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiKillJobsResp
	YAML200      *V0041OpenapiKillJobsResp
	JSONDefault  *V0041OpenapiKillJobsResp
	YAMLDefault  *V0041OpenapiKillJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobInfoResp
	YAML200      *V0041OpenapiJobInfoResp
	JSONDefault  *V0041OpenapiJobInfoResp
	YAMLDefault  *V0041OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetJobsStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobInfoResp
	YAML200      *V0041OpenapiJobInfoResp
	JSONDefault  *V0041OpenapiJobInfoResp
	YAMLDefault  *V0041OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetJobsStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetJobsStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetLicensesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiLicensesResp
	YAML200      *V0041OpenapiLicensesResp
	JSONDefault  *V0041OpenapiLicensesResp
	YAMLDefault  *V0041OpenapiLicensesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetLicensesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetLicensesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiNodesResp
	YAML200      *V0041OpenapiNodesResp
	JSONDefault  *V0041OpenapiNodesResp
	YAMLDefault  *V0041OpenapiNodesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiNodesResp
	YAML200      *V0041OpenapiNodesResp
	JSONDefault  *V0041OpenapiNodesResp
	YAMLDefault  *V0041OpenapiNodesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetPartitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiPartitionResp
	YAML200      *V0041OpenapiPartitionResp
	JSONDefault  *V0041OpenapiPartitionResp
	YAMLDefault  *V0041OpenapiPartitionResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetPartitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetPartitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiPartitionResp
	YAML200      *V0041OpenapiPartitionResp
	JSONDefault  *V0041OpenapiPartitionResp
	YAMLDefault  *V0041OpenapiPartitionResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiPingArrayResp
	YAML200      *V0041OpenapiPingArrayResp
	JSONDefault  *V0041OpenapiPingArrayResp
	YAMLDefault  *V0041OpenapiPingArrayResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetReconfigureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetReconfigureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetReconfigureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiReservationResp
	YAML200      *V0041OpenapiReservationResp
	JSONDefault  *V0041OpenapiReservationResp
	YAMLDefault  *V0041OpenapiReservationResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiReservationResp
	YAML200      *V0041OpenapiReservationResp
	JSONDefault  *V0041OpenapiReservationResp
	YAMLDefault  *V0041OpenapiReservationResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetSharesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSharesResp
	YAML200      *V0041OpenapiSharesResp
	JSONDefault  *V0041OpenapiSharesResp
	YAMLDefault  *V0041OpenapiSharesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetSharesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetSharesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAccountsRemovedResp
	YAML200      *V0041OpenapiAccountsRemovedResp
	JSONDefault  *V0041OpenapiAccountsRemovedResp
	YAMLDefault  *V0041OpenapiAccountsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAccountsResp
	YAML200      *V0041OpenapiAccountsResp
	JSONDefault  *V0041OpenapiAccountsResp
	YAMLDefault  *V0041OpenapiAccountsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAccountsResp
	YAML200      *V0041OpenapiAccountsResp
	JSONDefault  *V0041OpenapiAccountsResp
	YAMLDefault  *V0041OpenapiAccountsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostAccountsAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAccountsAddCondRespStr
	YAML200      *V0041OpenapiAccountsAddCondRespStr
	JSONDefault  *V0041OpenapiAccountsAddCondRespStr
	YAMLDefault  *V0041OpenapiAccountsAddCondRespStr
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostAccountsAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostAccountsAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsRemovedResp
	YAML200      *V0041OpenapiAssocsRemovedResp
	JSONDefault  *V0041OpenapiAssocsRemovedResp
	YAMLDefault  *V0041OpenapiAssocsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsResp
	YAML200      *V0041OpenapiAssocsResp
	JSONDefault  *V0041OpenapiAssocsResp
	YAMLDefault  *V0041OpenapiAssocsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsRemovedResp
	YAML200      *V0041OpenapiAssocsRemovedResp
	JSONDefault  *V0041OpenapiAssocsRemovedResp
	YAMLDefault  *V0041OpenapiAssocsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsResp
	YAML200      *V0041OpenapiAssocsResp
	JSONDefault  *V0041OpenapiAssocsResp
	YAMLDefault  *V0041OpenapiAssocsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiClustersRemovedResp
	YAML200      *V0041OpenapiClustersRemovedResp
	JSONDefault  *V0041OpenapiClustersRemovedResp
	YAMLDefault  *V0041OpenapiClustersRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiClustersResp
	YAML200      *V0041OpenapiClustersResp
	JSONDefault  *V0041OpenapiClustersResp
	YAMLDefault  *V0041OpenapiClustersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiClustersResp
	YAML200      *V0041OpenapiClustersResp
	JSONDefault  *V0041OpenapiClustersResp
	YAMLDefault  *V0041OpenapiClustersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdConfigResp
	YAML200      *V0041OpenapiSlurmdbdConfigResp
	JSONDefault  *V0041OpenapiSlurmdbdConfigResp
	YAMLDefault  *V0041OpenapiSlurmdbdConfigResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdStatsResp
	YAML200      *V0041OpenapiSlurmdbdStatsResp
	JSONDefault  *V0041OpenapiSlurmdbdStatsResp
	YAMLDefault  *V0041OpenapiSlurmdbdStatsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiInstancesResp
	YAML200      *V0041OpenapiInstancesResp
	JSONDefault  *V0041OpenapiInstancesResp
	YAMLDefault  *V0041OpenapiInstancesResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiInstancesResp
	YAML200      *V0041OpenapiInstancesResp
	JSONDefault  *V0041OpenapiInstancesResp
	YAMLDefault  *V0041OpenapiInstancesResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdJobsResp
	YAML200      *V0041OpenapiSlurmdbdJobsResp
	JSONDefault  *V0041OpenapiSlurmdbdJobsResp
	YAMLDefault  *V0041OpenapiSlurmdbdJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdJobsResp
	YAML200      *V0041OpenapiSlurmdbdJobsResp
	JSONDefault  *V0041OpenapiSlurmdbdJobsResp
	YAMLDefault  *V0041OpenapiSlurmdbdJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdQosResp
	YAML200      *V0041OpenapiSlurmdbdQosResp
	JSONDefault  *V0041OpenapiSlurmdbdQosResp
	YAMLDefault  *V0041OpenapiSlurmdbdQosResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteSingleQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdQosRemovedResp
	YAML200      *V0041OpenapiSlurmdbdQosRemovedResp
	JSONDefault  *V0041OpenapiSlurmdbdQosRemovedResp
	YAMLDefault  *V0041OpenapiSlurmdbdQosRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteSingleQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteSingleQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetSingleQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdQosResp
	YAML200      *V0041OpenapiSlurmdbdQosResp
	JSONDefault  *V0041OpenapiSlurmdbdQosResp
	YAMLDefault  *V0041OpenapiSlurmdbdQosResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetSingleQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetSingleQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetTresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiTresResp
	YAML200      *V0041OpenapiTresResp
	JSONDefault  *V0041OpenapiTresResp
	YAMLDefault  *V0041OpenapiTresResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetTresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetTresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostTresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostTresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostTresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiUsersResp
	YAML200      *V0041OpenapiUsersResp
	JSONDefault  *V0041OpenapiUsersResp
	YAMLDefault  *V0041OpenapiUsersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiUsersResp
	YAML200      *V0041OpenapiUsersResp
	JSONDefault  *V0041OpenapiUsersResp
	YAMLDefault  *V0041OpenapiUsersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostUsersAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiUsersAddCondRespStr
	YAML200      *V0041OpenapiUsersAddCondRespStr
	JSONDefault  *V0041OpenapiUsersAddCondRespStr
	YAMLDefault  *V0041OpenapiUsersAddCondRespStr
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostUsersAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostUsersAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteWckeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiWckeyRemovedResp
	YAML200      *V0041OpenapiWckeyRemovedResp
	JSONDefault  *V0041OpenapiWckeyRemovedResp
	YAMLDefault  *V0041OpenapiWckeyRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteWckeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteWckeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetWckeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiWckeyResp
	YAML200      *V0041OpenapiWckeyResp
	JSONDefault  *V0041OpenapiWckeyResp
	YAMLDefault  *V0041OpenapiWckeyResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetWckeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetWckeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetWckeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiWckeyResp
	YAML200      *V0041OpenapiWckeyResp
	JSONDefault  *V0041OpenapiWckeyResp
	YAMLDefault  *V0041OpenapiWckeyResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetWckeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetWckeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostWckeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	YAML200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
	YAMLDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostWckeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostWckeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SlurmV0041GetDiagWithResponse request returning *SlurmV0041GetDiagResponse
func (c *ClientWithResponses) SlurmV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetDiagResponse, error) {
	rsp, err := c.SlurmV0041GetDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetDiagResponse(rsp)
}

// SlurmV0041PostJobAllocateWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostJobAllocateResponse
func (c *ClientWithResponses) SlurmV0041PostJobAllocateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error) {
	rsp, err := c.SlurmV0041PostJobAllocateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobAllocateResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostJobAllocateWithResponse(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error) {
	rsp, err := c.SlurmV0041PostJobAllocate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobAllocateResponse(rsp)
}

// SlurmV0041PostJobSubmitWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostJobSubmitResponse
func (c *ClientWithResponses) SlurmV0041PostJobSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error) {
	rsp, err := c.SlurmV0041PostJobSubmitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobSubmitResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostJobSubmitWithResponse(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error) {
	rsp, err := c.SlurmV0041PostJobSubmit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobSubmitResponse(rsp)
}

// SlurmV0041DeleteJobWithResponse request returning *SlurmV0041DeleteJobResponse
func (c *ClientWithResponses) SlurmV0041DeleteJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobResponse, error) {
	rsp, err := c.SlurmV0041DeleteJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteJobResponse(rsp)
}

// SlurmV0041GetJobWithResponse request returning *SlurmV0041GetJobResponse
func (c *ClientWithResponses) SlurmV0041GetJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobResponse, error) {
	rsp, err := c.SlurmV0041GetJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetJobResponse(rsp)
}

// SlurmV0041PostJobWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostJobResponse
func (c *ClientWithResponses) SlurmV0041PostJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error) {
	rsp, err := c.SlurmV0041PostJobWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostJobWithResponse(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error) {
	rsp, err := c.SlurmV0041PostJob(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobResponse(rsp)
}

// SlurmV0041DeleteJobsWithBodyWithResponse request with arbitrary body returning *SlurmV0041DeleteJobsResponse
func (c *ClientWithResponses) SlurmV0041DeleteJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error) {
	rsp, err := c.SlurmV0041DeleteJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteJobsResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041DeleteJobsWithResponse(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error) {
	rsp, err := c.SlurmV0041DeleteJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteJobsResponse(rsp)
}

// SlurmV0041GetJobsWithResponse request returning *SlurmV0041GetJobsResponse
func (c *ClientWithResponses) SlurmV0041GetJobsWithResponse(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsResponse, error) {
	rsp, err := c.SlurmV0041GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetJobsResponse(rsp)
}

// SlurmV0041GetJobsStateWithResponse request returning *SlurmV0041GetJobsStateResponse
func (c *ClientWithResponses) SlurmV0041GetJobsStateWithResponse(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsStateResponse, error) {
	rsp, err := c.SlurmV0041GetJobsState(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetJobsStateResponse(rsp)
}

// SlurmV0041GetLicensesWithResponse request returning *SlurmV0041GetLicensesResponse
func (c *ClientWithResponses) SlurmV0041GetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetLicensesResponse, error) {
	rsp, err := c.SlurmV0041GetLicenses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetLicensesResponse(rsp)
}

// SlurmV0041DeleteNodeWithResponse request returning *SlurmV0041DeleteNodeResponse
func (c *ClientWithResponses) SlurmV0041DeleteNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteNodeResponse, error) {
	rsp, err := c.SlurmV0041DeleteNode(ctx, nodeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteNodeResponse(rsp)
}

// SlurmV0041GetNodeWithResponse request returning *SlurmV0041GetNodeResponse
func (c *ClientWithResponses) SlurmV0041GetNodeWithResponse(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodeResponse, error) {
	rsp, err := c.SlurmV0041GetNode(ctx, nodeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetNodeResponse(rsp)
}

// SlurmV0041PostNodeWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostNodeResponse
func (c *ClientWithResponses) SlurmV0041PostNodeWithBodyWithResponse(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error) {
	rsp, err := c.SlurmV0041PostNodeWithBody(ctx, nodeName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodeResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostNodeWithResponse(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error) {
	rsp, err := c.SlurmV0041PostNode(ctx, nodeName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodeResponse(rsp)
}

// SlurmV0041GetNodesWithResponse request returning *SlurmV0041GetNodesResponse
func (c *ClientWithResponses) SlurmV0041GetNodesWithResponse(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodesResponse, error) {
	rsp, err := c.SlurmV0041GetNodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetNodesResponse(rsp)
}

// SlurmV0041PostNodesWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostNodesResponse
func (c *ClientWithResponses) SlurmV0041PostNodesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodesResponse, error) {
	rsp, err := c.SlurmV0041PostNodesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodesResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostNodesWithResponse(ctx context.Context, body SlurmV0041PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodesResponse, error) {
	rsp, err := c.SlurmV0041PostNodes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodesResponse(rsp)
}

// SlurmV0041GetPartitionWithResponse request returning *SlurmV0041GetPartitionResponse
func (c *ClientWithResponses) SlurmV0041GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionResponse, error) {
	rsp, err := c.SlurmV0041GetPartition(ctx, partitionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetPartitionResponse(rsp)
}

// SlurmV0041GetPartitionsWithResponse request returning *SlurmV0041GetPartitionsResponse
func (c *ClientWithResponses) SlurmV0041GetPartitionsWithResponse(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionsResponse, error) {
	rsp, err := c.SlurmV0041GetPartitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetPartitionsResponse(rsp)
}

// SlurmV0041GetPingWithResponse request returning *SlurmV0041GetPingResponse
func (c *ClientWithResponses) SlurmV0041GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetPingResponse, error) {
	rsp, err := c.SlurmV0041GetPing(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetPingResponse(rsp)
}

// SlurmV0041GetReconfigureWithResponse request returning *SlurmV0041GetReconfigureResponse
func (c *ClientWithResponses) SlurmV0041GetReconfigureWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetReconfigureResponse, error) {
	rsp, err := c.SlurmV0041GetReconfigure(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetReconfigureResponse(rsp)
}

// SlurmV0041DeleteReservationWithResponse request returning *SlurmV0041DeleteReservationResponse
func (c *ClientWithResponses) SlurmV0041DeleteReservationWithResponse(ctx context.Context, reservationName string, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteReservationResponse, error) {
	rsp, err := c.SlurmV0041DeleteReservation(ctx, reservationName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteReservationResponse(rsp)
}

// SlurmV0041GetReservationWithResponse request returning *SlurmV0041GetReservationResponse
func (c *ClientWithResponses) SlurmV0041GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationResponse, error) {
	rsp, err := c.SlurmV0041GetReservation(ctx, reservationName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetReservationResponse(rsp)
}

// SlurmV0041GetReservationsWithResponse request returning *SlurmV0041GetReservationsResponse
func (c *ClientWithResponses) SlurmV0041GetReservationsWithResponse(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationsResponse, error) {
	rsp, err := c.SlurmV0041GetReservations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetReservationsResponse(rsp)
}

// SlurmV0041GetSharesWithResponse request returning *SlurmV0041GetSharesResponse
func (c *ClientWithResponses) SlurmV0041GetSharesWithResponse(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetSharesResponse, error) {
	rsp, err := c.SlurmV0041GetShares(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetSharesResponse(rsp)
}

// SlurmdbV0041DeleteAccountWithResponse request returning *SlurmdbV0041DeleteAccountResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAccountResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteAccount(ctx, accountName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteAccountResponse(rsp)
}

// SlurmdbV0041GetAccountWithResponse request returning *SlurmdbV0041GetAccountResponse
func (c *ClientWithResponses) SlurmdbV0041GetAccountWithResponse(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountResponse, error) {
	rsp, err := c.SlurmdbV0041GetAccount(ctx, accountName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAccountResponse(rsp)
}

// SlurmdbV0041GetAccountsWithResponse request returning *SlurmdbV0041GetAccountsResponse
func (c *ClientWithResponses) SlurmdbV0041GetAccountsWithResponse(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountsResponse, error) {
	rsp, err := c.SlurmdbV0041GetAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAccountsResponse(rsp)
}

// SlurmdbV0041PostAccountsWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostAccountsResponse
func (c *ClientWithResponses) SlurmdbV0041PostAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccountsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostAccountsWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccounts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsResponse(rsp)
}

// SlurmdbV0041PostAccountsAssociationWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostAccountsAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041PostAccountsAssociationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccountsAssociationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsAssociationResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostAccountsAssociationWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccountsAssociation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsAssociationResponse(rsp)
}

// SlurmdbV0041DeleteAssociationWithResponse request returning *SlurmdbV0041DeleteAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteAssociationWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteAssociation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteAssociationResponse(rsp)
}

// SlurmdbV0041GetAssociationWithResponse request returning *SlurmdbV0041GetAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041GetAssociationWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041GetAssociation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAssociationResponse(rsp)
}

// SlurmdbV0041DeleteAssociationsWithResponse request returning *SlurmdbV0041DeleteAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteAssociationsResponse(rsp)
}

// SlurmdbV0041GetAssociationsWithResponse request returning *SlurmdbV0041GetAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0041GetAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041GetAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAssociationsResponse(rsp)
}

// SlurmdbV0041PostAssociationsWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0041PostAssociationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAssociationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAssociationsResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostAssociationsWithResponse(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAssociations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAssociationsResponse(rsp)
}

// SlurmdbV0041DeleteClusterWithResponse request returning *SlurmdbV0041DeleteClusterResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteClusterResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteCluster(ctx, clusterName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteClusterResponse(rsp)
}

// SlurmdbV0041GetClusterWithResponse request returning *SlurmdbV0041GetClusterResponse
func (c *ClientWithResponses) SlurmdbV0041GetClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClusterResponse, error) {
	rsp, err := c.SlurmdbV0041GetCluster(ctx, clusterName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetClusterResponse(rsp)
}

// SlurmdbV0041GetClustersWithResponse request returning *SlurmdbV0041GetClustersResponse
func (c *ClientWithResponses) SlurmdbV0041GetClustersWithResponse(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClustersResponse, error) {
	rsp, err := c.SlurmdbV0041GetClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetClustersResponse(rsp)
}

// SlurmdbV0041PostClustersWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostClustersResponse
func (c *ClientWithResponses) SlurmdbV0041PostClustersWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error) {
	rsp, err := c.SlurmdbV0041PostClustersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostClustersResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostClustersWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error) {
	rsp, err := c.SlurmdbV0041PostClusters(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostClustersResponse(rsp)
}

// SlurmdbV0041GetConfigWithResponse request returning *SlurmdbV0041GetConfigResponse
func (c *ClientWithResponses) SlurmdbV0041GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetConfigResponse, error) {
	rsp, err := c.SlurmdbV0041GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetConfigResponse(rsp)
}

// SlurmdbV0041PostConfigWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostConfigResponse
func (c *ClientWithResponses) SlurmdbV0041PostConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error) {
	rsp, err := c.SlurmdbV0041PostConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostConfigResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostConfigWithResponse(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error) {
	rsp, err := c.SlurmdbV0041PostConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostConfigResponse(rsp)
}

// SlurmdbV0041GetDiagWithResponse request returning *SlurmdbV0041GetDiagResponse
func (c *ClientWithResponses) SlurmdbV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetDiagResponse, error) {
	rsp, err := c.SlurmdbV0041GetDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetDiagResponse(rsp)
}

// SlurmdbV0041GetInstanceWithResponse request returning *SlurmdbV0041GetInstanceResponse
func (c *ClientWithResponses) SlurmdbV0041GetInstanceWithResponse(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstanceResponse, error) {
	rsp, err := c.SlurmdbV0041GetInstance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetInstanceResponse(rsp)
}

// SlurmdbV0041GetInstancesWithResponse request returning *SlurmdbV0041GetInstancesResponse
func (c *ClientWithResponses) SlurmdbV0041GetInstancesWithResponse(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstancesResponse, error) {
	rsp, err := c.SlurmdbV0041GetInstances(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetInstancesResponse(rsp)
}

// SlurmdbV0041GetJobWithResponse request returning *SlurmdbV0041GetJobResponse
func (c *ClientWithResponses) SlurmdbV0041GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobResponse, error) {
	rsp, err := c.SlurmdbV0041GetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetJobResponse(rsp)
}

// SlurmdbV0041GetJobsWithResponse request returning *SlurmdbV0041GetJobsResponse
func (c *ClientWithResponses) SlurmdbV0041GetJobsWithResponse(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobsResponse, error) {
	rsp, err := c.SlurmdbV0041GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetJobsResponse(rsp)
}

// SlurmdbV0041GetQosWithResponse request returning *SlurmdbV0041GetQosResponse
func (c *ClientWithResponses) SlurmdbV0041GetQosWithResponse(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetQosResponse, error) {
	rsp, err := c.SlurmdbV0041GetQos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetQosResponse(rsp)
}

// SlurmdbV0041PostQosWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostQosResponse
func (c *ClientWithResponses) SlurmdbV0041PostQosWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error) {
	rsp, err := c.SlurmdbV0041PostQosWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostQosResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostQosWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error) {
	rsp, err := c.SlurmdbV0041PostQos(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostQosResponse(rsp)
}

// SlurmdbV0041DeleteSingleQosWithResponse request returning *SlurmdbV0041DeleteSingleQosResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteSingleQosWithResponse(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteSingleQosResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteSingleQos(ctx, qos, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteSingleQosResponse(rsp)
}

// SlurmdbV0041GetSingleQosWithResponse request returning *SlurmdbV0041GetSingleQosResponse
func (c *ClientWithResponses) SlurmdbV0041GetSingleQosWithResponse(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetSingleQosResponse, error) {
	rsp, err := c.SlurmdbV0041GetSingleQos(ctx, qos, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetSingleQosResponse(rsp)
}

// SlurmdbV0041GetTresWithResponse request returning *SlurmdbV0041GetTresResponse
func (c *ClientWithResponses) SlurmdbV0041GetTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetTresResponse, error) {
	rsp, err := c.SlurmdbV0041GetTres(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetTresResponse(rsp)
}

// SlurmdbV0041PostTresWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostTresResponse
func (c *ClientWithResponses) SlurmdbV0041PostTresWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error) {
	rsp, err := c.SlurmdbV0041PostTresWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostTresResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostTresWithResponse(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error) {
	rsp, err := c.SlurmdbV0041PostTres(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostTresResponse(rsp)
}

// SlurmdbV0041DeleteUserWithResponse request returning *SlurmdbV0041DeleteUserResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteUserWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteUserResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteUser(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteUserResponse(rsp)
}

// SlurmdbV0041GetUserWithResponse request returning *SlurmdbV0041GetUserResponse
func (c *ClientWithResponses) SlurmdbV0041GetUserWithResponse(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUserResponse, error) {
	rsp, err := c.SlurmdbV0041GetUser(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetUserResponse(rsp)
}

// SlurmdbV0041GetUsersWithResponse request returning *SlurmdbV0041GetUsersResponse
func (c *ClientWithResponses) SlurmdbV0041GetUsersWithResponse(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUsersResponse, error) {
	rsp, err := c.SlurmdbV0041GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetUsersResponse(rsp)
}

// SlurmdbV0041PostUsersWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostUsersResponse
func (c *ClientWithResponses) SlurmdbV0041PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostUsersWithResponse(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersResponse(rsp)
}

// SlurmdbV0041PostUsersAssociationWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostUsersAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041PostUsersAssociationWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsersAssociationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersAssociationResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostUsersAssociationWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsersAssociation(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersAssociationResponse(rsp)
}

// SlurmdbV0041DeleteWckeyWithResponse request returning *SlurmdbV0041DeleteWckeyResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteWckeyResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteWckey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteWckeyResponse(rsp)
}

// SlurmdbV0041GetWckeyWithResponse request returning *SlurmdbV0041GetWckeyResponse
func (c *ClientWithResponses) SlurmdbV0041GetWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeyResponse, error) {
	rsp, err := c.SlurmdbV0041GetWckey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetWckeyResponse(rsp)
}

// SlurmdbV0041GetWckeysWithResponse request returning *SlurmdbV0041GetWckeysResponse
func (c *ClientWithResponses) SlurmdbV0041GetWckeysWithResponse(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeysResponse, error) {
	rsp, err := c.SlurmdbV0041GetWckeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetWckeysResponse(rsp)
}

// SlurmdbV0041PostWckeysWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostWckeysResponse
func (c *ClientWithResponses) SlurmdbV0041PostWckeysWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error) {
	rsp, err := c.SlurmdbV0041PostWckeysWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostWckeysResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostWckeysWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error) {
	rsp, err := c.SlurmdbV0041PostWckeys(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostWckeysResponse(rsp)
}

// ParseSlurmV0041GetDiagResponse parses an HTTP response from a SlurmV0041GetDiagWithResponse call
func ParseSlurmV0041GetDiagResponse(rsp *http.Response) (*SlurmV0041GetDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiDiagResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiDiagResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiDiagResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiDiagResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostJobAllocateResponse parses an HTTP response from a SlurmV0041PostJobAllocateWithResponse call
func ParseSlurmV0041PostJobAllocateResponse(rsp *http.Response) (*SlurmV0041PostJobAllocateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostJobAllocateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobAllocResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobAllocResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobAllocResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiJobAllocResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostJobSubmitResponse parses an HTTP response from a SlurmV0041PostJobSubmitWithResponse call
func ParseSlurmV0041PostJobSubmitResponse(rsp *http.Response) (*SlurmV0041PostJobSubmitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostJobSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobSubmitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobSubmitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobSubmitResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiJobSubmitResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteJobResponse parses an HTTP response from a SlurmV0041DeleteJobWithResponse call
func ParseSlurmV0041DeleteJobResponse(rsp *http.Response) (*SlurmV0041DeleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetJobResponse parses an HTTP response from a SlurmV0041GetJobWithResponse call
func ParseSlurmV0041GetJobResponse(rsp *http.Response) (*SlurmV0041GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiJobInfoResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostJobResponse parses an HTTP response from a SlurmV0041PostJobWithResponse call
func ParseSlurmV0041PostJobResponse(rsp *http.Response) (*SlurmV0041PostJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobPostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobPostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobPostResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiJobPostResponse
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteJobsResponse parses an HTTP response from a SlurmV0041DeleteJobsWithResponse call
func ParseSlurmV0041DeleteJobsResponse(rsp *http.Response) (*SlurmV0041DeleteJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiKillJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiKillJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiKillJobsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiKillJobsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetJobsResponse parses an HTTP response from a SlurmV0041GetJobsWithResponse call
func ParseSlurmV0041GetJobsResponse(rsp *http.Response) (*SlurmV0041GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiJobInfoResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetJobsStateResponse parses an HTTP response from a SlurmV0041GetJobsStateWithResponse call
func ParseSlurmV0041GetJobsStateResponse(rsp *http.Response) (*SlurmV0041GetJobsStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetJobsStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiJobInfoResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetLicensesResponse parses an HTTP response from a SlurmV0041GetLicensesWithResponse call
func ParseSlurmV0041GetLicensesResponse(rsp *http.Response) (*SlurmV0041GetLicensesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetLicensesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiLicensesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiLicensesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiLicensesResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiLicensesResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteNodeResponse parses an HTTP response from a SlurmV0041DeleteNodeWithResponse call
func ParseSlurmV0041DeleteNodeResponse(rsp *http.Response) (*SlurmV0041DeleteNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetNodeResponse parses an HTTP response from a SlurmV0041GetNodeWithResponse call
func ParseSlurmV0041GetNodeResponse(rsp *http.Response) (*SlurmV0041GetNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiNodesResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiNodesResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostNodeResponse parses an HTTP response from a SlurmV0041PostNodeWithResponse call
func ParseSlurmV0041PostNodeResponse(rsp *http.Response) (*SlurmV0041PostNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetNodesResponse parses an HTTP response from a SlurmV0041GetNodesWithResponse call
func ParseSlurmV0041GetNodesResponse(rsp *http.Response) (*SlurmV0041GetNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiNodesResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiNodesResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostNodesResponse parses an HTTP response from a SlurmV0041PostNodesWithResponse call
func ParseSlurmV0041PostNodesResponse(rsp *http.Response) (*SlurmV0041PostNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetPartitionResponse parses an HTTP response from a SlurmV0041GetPartitionWithResponse call
func ParseSlurmV0041GetPartitionResponse(rsp *http.Response) (*SlurmV0041GetPartitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetPartitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiPartitionResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiPartitionResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetPartitionsResponse parses an HTTP response from a SlurmV0041GetPartitionsWithResponse call
func ParseSlurmV0041GetPartitionsResponse(rsp *http.Response) (*SlurmV0041GetPartitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiPartitionResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiPartitionResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetPingResponse parses an HTTP response from a SlurmV0041GetPingWithResponse call
func ParseSlurmV0041GetPingResponse(rsp *http.Response) (*SlurmV0041GetPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiPingArrayResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiPingArrayResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiPingArrayResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiPingArrayResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetReconfigureResponse parses an HTTP response from a SlurmV0041GetReconfigureWithResponse call
func ParseSlurmV0041GetReconfigureResponse(rsp *http.Response) (*SlurmV0041GetReconfigureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetReconfigureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteReservationResponse parses an HTTP response from a SlurmV0041DeleteReservationWithResponse call
func ParseSlurmV0041DeleteReservationResponse(rsp *http.Response) (*SlurmV0041DeleteReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetReservationResponse parses an HTTP response from a SlurmV0041GetReservationWithResponse call
func ParseSlurmV0041GetReservationResponse(rsp *http.Response) (*SlurmV0041GetReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiReservationResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiReservationResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetReservationsResponse parses an HTTP response from a SlurmV0041GetReservationsWithResponse call
func ParseSlurmV0041GetReservationsResponse(rsp *http.Response) (*SlurmV0041GetReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiReservationResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiReservationResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetSharesResponse parses an HTTP response from a SlurmV0041GetSharesWithResponse call
func ParseSlurmV0041GetSharesResponse(rsp *http.Response) (*SlurmV0041GetSharesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetSharesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSharesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSharesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiSharesResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiSharesResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteAccountResponse parses an HTTP response from a SlurmdbV0041DeleteAccountWithResponse call
func ParseSlurmdbV0041DeleteAccountResponse(rsp *http.Response) (*SlurmdbV0041DeleteAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAccountsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsRemovedResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiAccountsRemovedResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAccountResponse parses an HTTP response from a SlurmdbV0041GetAccountWithResponse call
func ParseSlurmdbV0041GetAccountResponse(rsp *http.Response) (*SlurmdbV0041GetAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiAccountsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAccountsResponse parses an HTTP response from a SlurmdbV0041GetAccountsWithResponse call
func ParseSlurmdbV0041GetAccountsResponse(rsp *http.Response) (*SlurmdbV0041GetAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiAccountsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostAccountsResponse parses an HTTP response from a SlurmdbV0041PostAccountsWithResponse call
func ParseSlurmdbV0041PostAccountsResponse(rsp *http.Response) (*SlurmdbV0041PostAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostAccountsAssociationResponse parses an HTTP response from a SlurmdbV0041PostAccountsAssociationWithResponse call
func ParseSlurmdbV0041PostAccountsAssociationResponse(rsp *http.Response) (*SlurmdbV0041PostAccountsAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostAccountsAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsAddCondRespStr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAccountsAddCondRespStr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsAddCondRespStr
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiAccountsAddCondRespStr
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteAssociationResponse parses an HTTP response from a SlurmdbV0041DeleteAssociationWithResponse call
func ParseSlurmdbV0041DeleteAssociationResponse(rsp *http.Response) (*SlurmdbV0041DeleteAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsRemovedResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiAssocsRemovedResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAssociationResponse parses an HTTP response from a SlurmdbV0041GetAssociationWithResponse call
func ParseSlurmdbV0041GetAssociationResponse(rsp *http.Response) (*SlurmdbV0041GetAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiAssocsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteAssociationsResponse parses an HTTP response from a SlurmdbV0041DeleteAssociationsWithResponse call
func ParseSlurmdbV0041DeleteAssociationsResponse(rsp *http.Response) (*SlurmdbV0041DeleteAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsRemovedResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiAssocsRemovedResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAssociationsResponse parses an HTTP response from a SlurmdbV0041GetAssociationsWithResponse call
func ParseSlurmdbV0041GetAssociationsResponse(rsp *http.Response) (*SlurmdbV0041GetAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiAssocsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostAssociationsResponse parses an HTTP response from a SlurmdbV0041PostAssociationsWithResponse call
func ParseSlurmdbV0041PostAssociationsResponse(rsp *http.Response) (*SlurmdbV0041PostAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteClusterResponse parses an HTTP response from a SlurmdbV0041DeleteClusterWithResponse call
func ParseSlurmdbV0041DeleteClusterResponse(rsp *http.Response) (*SlurmdbV0041DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiClustersRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersRemovedResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiClustersRemovedResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetClusterResponse parses an HTTP response from a SlurmdbV0041GetClusterWithResponse call
func ParseSlurmdbV0041GetClusterResponse(rsp *http.Response) (*SlurmdbV0041GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiClustersResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetClustersResponse parses an HTTP response from a SlurmdbV0041GetClustersWithResponse call
func ParseSlurmdbV0041GetClustersResponse(rsp *http.Response) (*SlurmdbV0041GetClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiClustersResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostClustersResponse parses an HTTP response from a SlurmdbV0041PostClustersWithResponse call
func ParseSlurmdbV0041PostClustersResponse(rsp *http.Response) (*SlurmdbV0041PostClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetConfigResponse parses an HTTP response from a SlurmdbV0041GetConfigWithResponse call
func ParseSlurmdbV0041GetConfigResponse(rsp *http.Response) (*SlurmdbV0041GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdConfigResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdConfigResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdConfigResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiSlurmdbdConfigResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostConfigResponse parses an HTTP response from a SlurmdbV0041PostConfigWithResponse call
func ParseSlurmdbV0041PostConfigResponse(rsp *http.Response) (*SlurmdbV0041PostConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetDiagResponse parses an HTTP response from a SlurmdbV0041GetDiagWithResponse call
func ParseSlurmdbV0041GetDiagResponse(rsp *http.Response) (*SlurmdbV0041GetDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdStatsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdStatsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdStatsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiSlurmdbdStatsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetInstanceResponse parses an HTTP response from a SlurmdbV0041GetInstanceWithResponse call
func ParseSlurmdbV0041GetInstanceResponse(rsp *http.Response) (*SlurmdbV0041GetInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiInstancesResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiInstancesResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetInstancesResponse parses an HTTP response from a SlurmdbV0041GetInstancesWithResponse call
func ParseSlurmdbV0041GetInstancesResponse(rsp *http.Response) (*SlurmdbV0041GetInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiInstancesResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiInstancesResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetJobResponse parses an HTTP response from a SlurmdbV0041GetJobWithResponse call
func ParseSlurmdbV0041GetJobResponse(rsp *http.Response) (*SlurmdbV0041GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetJobsResponse parses an HTTP response from a SlurmdbV0041GetJobsWithResponse call
func ParseSlurmdbV0041GetJobsResponse(rsp *http.Response) (*SlurmdbV0041GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetQosResponse parses an HTTP response from a SlurmdbV0041GetQosWithResponse call
func ParseSlurmdbV0041GetQosResponse(rsp *http.Response) (*SlurmdbV0041GetQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostQosResponse parses an HTTP response from a SlurmdbV0041PostQosWithResponse call
func ParseSlurmdbV0041PostQosResponse(rsp *http.Response) (*SlurmdbV0041PostQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteSingleQosResponse parses an HTTP response from a SlurmdbV0041DeleteSingleQosWithResponse call
func ParseSlurmdbV0041DeleteSingleQosResponse(rsp *http.Response) (*SlurmdbV0041DeleteSingleQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteSingleQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdQosRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosRemovedResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiSlurmdbdQosRemovedResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetSingleQosResponse parses an HTTP response from a SlurmdbV0041GetSingleQosWithResponse call
func ParseSlurmdbV0041GetSingleQosResponse(rsp *http.Response) (*SlurmdbV0041GetSingleQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetSingleQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetTresResponse parses an HTTP response from a SlurmdbV0041GetTresWithResponse call
func ParseSlurmdbV0041GetTresResponse(rsp *http.Response) (*SlurmdbV0041GetTresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetTresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiTresResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiTresResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiTresResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiTresResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostTresResponse parses an HTTP response from a SlurmdbV0041PostTresWithResponse call
func ParseSlurmdbV0041PostTresResponse(rsp *http.Response) (*SlurmdbV0041PostTresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostTresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteUserResponse parses an HTTP response from a SlurmdbV0041DeleteUserWithResponse call
func ParseSlurmdbV0041DeleteUserResponse(rsp *http.Response) (*SlurmdbV0041DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetUserResponse parses an HTTP response from a SlurmdbV0041GetUserWithResponse call
func ParseSlurmdbV0041GetUserResponse(rsp *http.Response) (*SlurmdbV0041GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiUsersResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetUsersResponse parses an HTTP response from a SlurmdbV0041GetUsersWithResponse call
func ParseSlurmdbV0041GetUsersResponse(rsp *http.Response) (*SlurmdbV0041GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiUsersResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostUsersResponse parses an HTTP response from a SlurmdbV0041PostUsersWithResponse call
func ParseSlurmdbV0041PostUsersResponse(rsp *http.Response) (*SlurmdbV0041PostUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostUsersAssociationResponse parses an HTTP response from a SlurmdbV0041PostUsersAssociationWithResponse call
func ParseSlurmdbV0041PostUsersAssociationResponse(rsp *http.Response) (*SlurmdbV0041PostUsersAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostUsersAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersAddCondRespStr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiUsersAddCondRespStr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersAddCondRespStr
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiUsersAddCondRespStr
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteWckeyResponse parses an HTTP response from a SlurmdbV0041DeleteWckeyWithResponse call
func ParseSlurmdbV0041DeleteWckeyResponse(rsp *http.Response) (*SlurmdbV0041DeleteWckeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteWckeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiWckeyRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyRemovedResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiWckeyRemovedResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetWckeyResponse parses an HTTP response from a SlurmdbV0041GetWckeyWithResponse call
func ParseSlurmdbV0041GetWckeyResponse(rsp *http.Response) (*SlurmdbV0041GetWckeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetWckeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiWckeyResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetWckeysResponse parses an HTTP response from a SlurmdbV0041GetWckeysWithResponse call
func ParseSlurmdbV0041GetWckeysResponse(rsp *http.Response) (*SlurmdbV0041GetWckeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetWckeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiWckeyResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostWckeysResponse parses an HTTP response from a SlurmdbV0041PostWckeysWithResponse call
func ParseSlurmdbV0041PostWckeysResponse(rsp *http.Response) (*SlurmdbV0041PostWckeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostWckeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && true:
		var dest V0041OpenapiResp
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAMLDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
