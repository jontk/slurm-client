// Code generated by tools/codegen/generate.go; DO NOT EDIT.

package v0_0_42

import (
	"context"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/jontk/slurm-client"
)

// JobManager implements slurm.JobManager for API version v0.0.42
type JobManager struct {
	client *Client
}

// NewJobManager creates a new JobManager
func NewJobManager(client *Client) *JobManager {
	return &JobManager{client: client}
}

// List lists jobs with optional filtering
func (j *JobManager) List(ctx context.Context, opts *slurm.ListJobsOptions) (*slurm.JobList, error) {
	// Convert options to API parameters
	params := &ListJobsParams{}
	
	if opts != nil {
		if opts.UserID != "" {
			params.UserId = &opts.UserID
		}
		if opts.State != "" {
			state := string(opts.State)
			params.State = &state
		}
		if opts.Partition != "" {
			params.Partition = &opts.Partition
		}
		if opts.Limit > 0 {
			limit := int32(opts.Limit)
			params.Limit = &limit
		}
		if opts.Offset > 0 {
			offset := int32(opts.Offset)
			params.Offset = &offset
		}
	}
	
	resp, err := j.client.apiClient.ListJobsWithResponse(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to list jobs: %w", err)
	}
	
	if resp.StatusCode() != http.StatusOK {
		return nil, fmt.Errorf("API error: %d", resp.StatusCode())
	}
	
	// Convert API response to common format
	jobs := make([]slurm.Job, 0)
	if resp.JSON200 != nil && resp.JSON200.Jobs != nil {
		for _, apiJob := range *resp.JSON200.Jobs {
			job := convertJobFromAPI(apiJob)
			jobs = append(jobs, job)
		}
	}
	
	return &slurm.JobList{
		Jobs:  jobs,
		Total: len(jobs),
	}, nil
}

// Get retrieves a specific job by ID
func (j *JobManager) Get(ctx context.Context, jobID string) (*slurm.Job, error) {
	resp, err := j.client.apiClient.GetJobWithResponse(ctx, jobID)
	if err != nil {
		return nil, fmt.Errorf("failed to get job %s: %w", jobID, err)
	}
	
	if resp.StatusCode() != http.StatusOK {
		return nil, fmt.Errorf("API error: %d", resp.StatusCode())
	}
	
	if resp.JSON200 == nil {
		return nil, fmt.Errorf("no job data returned")
	}
	
	job := convertJobFromAPI(*resp.JSON200)
	return &job, nil
}

// Submit submits a new job
func (j *JobManager) Submit(ctx context.Context, job *slurm.JobSubmission) (*slurm.JobSubmitResponse, error) {
	// Convert submission to API format
	apiSubmission := convertJobSubmissionToAPI(job)
	
	resp, err := j.client.apiClient.SubmitJobWithResponse(ctx, apiSubmission)
	if err != nil {
		return nil, fmt.Errorf("failed to submit job: %w", err)
	}
	
	if resp.StatusCode() != http.StatusOK {
		return nil, fmt.Errorf("API error: %d", resp.StatusCode())
	}
	
	if resp.JSON200 == nil || resp.JSON200.JobId == nil {
		return nil, fmt.Errorf("no job ID returned")
	}
	
	return &slurm.JobSubmitResponse{
		JobID: *resp.JSON200.JobId,
	}, nil
}

// Cancel cancels a job
func (j *JobManager) Cancel(ctx context.Context, jobID string) error {
	resp, err := j.client.apiClient.CancelJobWithResponse(ctx, jobID)
	if err != nil {
		return fmt.Errorf("failed to cancel job %s: %w", jobID, err)
	}
	
	if resp.StatusCode() != http.StatusOK {
		return fmt.Errorf("API error: %d", resp.StatusCode())
	}
	
	return nil
}

// Update updates job properties (if supported by version)
func (j *JobManager) Update(ctx context.Context, jobID string, update *slurm.JobUpdate) error {
	// v0.0.42 may not support job updates - return appropriate error
	return fmt.Errorf("job updates not supported in API version v0.0.42")
}

// Steps retrieves job steps for a job
func (j *JobManager) Steps(ctx context.Context, jobID string) (*slurm.JobStepList, error) {
	// This would be implemented if the API supports job steps
	return &slurm.JobStepList{
		Steps: []slurm.JobStep{},
	}, nil
}

// Watch provides real-time job updates (if supported by version)
func (j *JobManager) Watch(ctx context.Context, opts *slurm.WatchJobsOptions) (<-chan slurm.JobEvent, error) {
	// v0.0.42 doesn't support real-time updates
	return nil, fmt.Errorf("real-time job watching not supported in API version v0.0.42")
}

// NodeManager implements slurm.NodeManager for API version v0.0.42
type NodeManager struct {
	client *Client
}

// NewNodeManager creates a new NodeManager
func NewNodeManager(client *Client) *NodeManager {
	return &NodeManager{client: client}
}

// List lists nodes with optional filtering
func (n *NodeManager) List(ctx context.Context, opts *slurm.ListNodesOptions) (*slurm.NodeList, error) {
	params := &ListNodesParams{}
	
	if opts != nil {
		if opts.State != "" {
			state := string(opts.State)
			params.State = &state
		}
		if opts.Partition != "" {
			params.Partition = &opts.Partition
		}
		if len(opts.Features) > 0 {
			features := strings.Join(opts.Features, ",")
			params.Features = &features
		}
	}
	
	resp, err := n.client.apiClient.ListNodesWithResponse(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to list nodes: %w", err)
	}
	
	if resp.StatusCode() != http.StatusOK {
		return nil, fmt.Errorf("API error: %d", resp.StatusCode())
	}
	
	// Convert API response to common format
	nodes := make([]slurm.Node, 0)
	if resp.JSON200 != nil && resp.JSON200.Nodes != nil {
		for _, apiNode := range *resp.JSON200.Nodes {
			node := convertNodeFromAPI(apiNode)
			nodes = append(nodes, node)
		}
	}
	
	return &slurm.NodeList{
		Nodes: nodes,
		Total: len(nodes),
	}, nil
}

// Get retrieves a specific node by name
func (n *NodeManager) Get(ctx context.Context, nodeName string) (*slurm.Node, error) {
	// This would need to be implemented based on the actual API
	return nil, fmt.Errorf("get single node not implemented for v0.0.42")
}

// Update updates node properties
func (n *NodeManager) Update(ctx context.Context, nodeName string, update *slurm.NodeUpdate) error {
	// This would need to be implemented based on the actual API
	return fmt.Errorf("node updates not implemented for v0.0.42")
}

// Drain drains a node
func (n *NodeManager) Drain(ctx context.Context, nodeName string, reason string) error {
	// This would need to be implemented based on the actual API
	return fmt.Errorf("node drain not implemented for v0.0.42")
}

// Resume resumes a drained node
func (n *NodeManager) Resume(ctx context.Context, nodeName string) error {
	// This would need to be implemented based on the actual API
	return fmt.Errorf("node resume not implemented for v0.0.42")
}

// PartitionManager implements slurm.PartitionManager for API version v0.0.42
type PartitionManager struct {
	client *Client
}

// NewPartitionManager creates a new PartitionManager
func NewPartitionManager(client *Client) *PartitionManager {
	return &PartitionManager{client: client}
}

// List lists partitions
func (p *PartitionManager) List(ctx context.Context) (*slurm.PartitionList, error) {
	resp, err := p.client.apiClient.ListPartitionsWithResponse(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list partitions: %w", err)
	}
	
	if resp.StatusCode() != http.StatusOK {
		return nil, fmt.Errorf("API error: %d", resp.StatusCode())
	}
	
	// Convert API response to common format
	partitions := make([]slurm.Partition, 0)
	if resp.JSON200 != nil && resp.JSON200.Partitions != nil {
		for _, apiPartition := range *resp.JSON200.Partitions {
			partition := convertPartitionFromAPI(apiPartition)
			partitions = append(partitions, partition)
		}
	}
	
	return &slurm.PartitionList{
		Partitions: partitions,
		Total:      len(partitions),
	}, nil
}

// Get retrieves a specific partition by name
func (p *PartitionManager) Get(ctx context.Context, partitionName string) (*slurm.Partition, error) {
	// This would need to be implemented based on the actual API
	return nil, fmt.Errorf("get single partition not implemented for v0.0.42")
}

// Update updates partition properties (if supported by version)
func (p *PartitionManager) Update(ctx context.Context, partitionName string, update *slurm.PartitionUpdate) error {
	return fmt.Errorf("partition updates not supported in API version v0.0.42")
}

// InfoManager implements slurm.InfoManager for API version v0.0.42
type InfoManager struct {
	client *Client
}

// NewInfoManager creates a new InfoManager
func NewInfoManager(client *Client) *InfoManager {
	return &InfoManager{client: client}
}

// Ping tests connectivity to the Slurm REST API
func (i *InfoManager) Ping(ctx context.Context) error {
	// Try to get a simple endpoint to test connectivity
	_, err := i.client.apiClient.ListPartitionsWithResponse(ctx)
	if err != nil {
		return fmt.Errorf("ping failed: %w", err)
	}
	return nil
}

// Version retrieves Slurm version information
func (i *InfoManager) Version(ctx context.Context) (*slurm.VersionInfo, error) {
	return &slurm.VersionInfo{
		Version:    "Unknown",
		Release:    "Unknown", 
		APIVersion: "v0.0.42",
	}, nil
}

// Configuration retrieves cluster configuration
func (i *InfoManager) Configuration(ctx context.Context) (*slurm.ClusterConfig, error) {
	return &slurm.ClusterConfig{
		ClusterName: "Unknown",
	}, nil
}

// Statistics retrieves cluster statistics
func (i *InfoManager) Statistics(ctx context.Context) (*slurm.ClusterStats, error) {
	return &slurm.ClusterStats{}, nil
}

// Conversion functions between API types and common types

func convertJobFromAPI(apiJob Job) slurm.Job {
	job := slurm.Job{
		Metadata: make(map[string]interface{}),
	}
	
	if apiJob.JobId != nil {
		job.ID = *apiJob.JobId
	}
	if apiJob.Name != nil {
		job.Name = *apiJob.Name
	}
	if apiJob.UserId != nil {
		job.UserID = *apiJob.UserId
	}
	if apiJob.JobState != nil {
		job.State = slurm.JobState(*apiJob.JobState)
	}
	if apiJob.Partition != nil {
		job.Partition = *apiJob.Partition
	}
	if apiJob.Cpus != nil {
		job.CPUs = int(*apiJob.Cpus)
	}
	if apiJob.Memory != nil {
		job.Memory = int(*apiJob.Memory)
	}
	
	// Handle time fields
	if apiJob.SubmitTime != nil {
		if t, err := time.Parse(time.RFC3339, *apiJob.SubmitTime); err == nil {
			job.SubmitTime = t
		}
	}
	if apiJob.StartTime != nil {
		if t, err := time.Parse(time.RFC3339, *apiJob.StartTime); err == nil {
			job.StartTime = &t
		}
	}
	if apiJob.EndTime != nil {
		if t, err := time.Parse(time.RFC3339, *apiJob.EndTime); err == nil {
			job.EndTime = &t
		}
	}
	
	return job
}

func convertJobSubmissionToAPI(submission *slurm.JobSubmission) JobSubmission {
	apiSubmission := JobSubmission{}
	
	if submission.Name != "" {
		apiSubmission.Name = &submission.Name
	}
	if submission.Script != "" {
		apiSubmission.Script = &submission.Script
	}
	if submission.Partition != "" {
		apiSubmission.Partition = &submission.Partition
	}
	if submission.CPUs > 0 {
		cpus := int32(submission.CPUs)
		apiSubmission.Cpus = &cpus
	}
	if submission.Memory > 0 {
		memory := int32(submission.Memory)
		apiSubmission.Memory = &memory
	}
	if submission.TimeLimit > 0 {
		timeLimit := int32(submission.TimeLimit)
		apiSubmission.TimeLimit = &timeLimit
	}
	
	return apiSubmission
}

func convertNodeFromAPI(apiNode Node) slurm.Node {
	node := slurm.Node{
		Metadata: make(map[string]interface{}),
	}
	
	if apiNode.Name != nil {
		node.Name = *apiNode.Name
	}
	if apiNode.State != nil {
		node.State = slurm.NodeState(*apiNode.State)
	}
	if apiNode.Cpus != nil {
		node.CPUs = int(*apiNode.Cpus)
	}
	if apiNode.Memory != nil {
		node.Memory = int(*apiNode.Memory)
	}
	if apiNode.Features != nil {
		node.Features = *apiNode.Features
	}
	
	return node
}

func convertPartitionFromAPI(apiPartition Partition) slurm.Partition {
	partition := slurm.Partition{
		Metadata: make(map[string]interface{}),
	}
	
	if apiPartition.Name != nil {
		partition.Name = *apiPartition.Name
	}
	if apiPartition.State != nil {
		partition.State = *apiPartition.State
	}
	if apiPartition.TotalCpus != nil {
		partition.TotalCPUs = int(*apiPartition.TotalCpus)
	}
	if apiPartition.TotalMemory != nil {
		partition.TotalMemory = int(*apiPartition.TotalMemory)
	}
	if apiPartition.MaxTimeLimit != nil {
		partition.MaxTimeLimit = int(*apiPartition.MaxTimeLimit)
	}
	if apiPartition.DefaultTimeLimit != nil {
		partition.DefaultTimeLimit = int(*apiPartition.DefaultTimeLimit)
	}
	
	return partition
}