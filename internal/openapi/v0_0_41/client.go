// Package v0_0_41 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package v0_0_41

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	TokenScopes      = "token.Scopes"
	UserScopes       = "user.Scopes"
)

// Defines values for V0041OpenapiAccountsRespAccountsFlags.
const (
	V0041OpenapiAccountsRespAccountsFlagsDELETED          V0041OpenapiAccountsRespAccountsFlags = "DELETED"
	V0041OpenapiAccountsRespAccountsFlagsNoUsersAreCoords V0041OpenapiAccountsRespAccountsFlags = "NoUsersAreCoords"
	V0041OpenapiAccountsRespAccountsFlagsUsersAreCoords   V0041OpenapiAccountsRespAccountsFlags = "UsersAreCoords"
	V0041OpenapiAccountsRespAccountsFlagsWithAssociations V0041OpenapiAccountsRespAccountsFlags = "WithAssociations"
	V0041OpenapiAccountsRespAccountsFlagsWithCoordinators V0041OpenapiAccountsRespAccountsFlags = "WithCoordinators"
)

// Defines values for V0041OpenapiAssocsRespAssociationsFlags.
const (
	V0041OpenapiAssocsRespAssociationsFlagsDELETED          V0041OpenapiAssocsRespAssociationsFlags = "DELETED"
	V0041OpenapiAssocsRespAssociationsFlagsExact            V0041OpenapiAssocsRespAssociationsFlags = "Exact"
	V0041OpenapiAssocsRespAssociationsFlagsNoUpdate         V0041OpenapiAssocsRespAssociationsFlags = "NoUpdate"
	V0041OpenapiAssocsRespAssociationsFlagsNoUsersAreCoords V0041OpenapiAssocsRespAssociationsFlags = "NoUsersAreCoords"
	V0041OpenapiAssocsRespAssociationsFlagsUsersAreCoords   V0041OpenapiAssocsRespAssociationsFlags = "UsersAreCoords"
)

// Defines values for V0041OpenapiClustersRespClustersFlags.
const (
	V0041OpenapiClustersRespClustersFlagsEXTERNAL       V0041OpenapiClustersRespClustersFlags = "EXTERNAL"
	V0041OpenapiClustersRespClustersFlagsFEDERATION     V0041OpenapiClustersRespClustersFlags = "FEDERATION"
	V0041OpenapiClustersRespClustersFlagsFRONTEND       V0041OpenapiClustersRespClustersFlags = "FRONT_END"
	V0041OpenapiClustersRespClustersFlagsMULTIPLESLURMD V0041OpenapiClustersRespClustersFlags = "MULTIPLE_SLURMD"
	V0041OpenapiClustersRespClustersFlagsREGISTERING    V0041OpenapiClustersRespClustersFlags = "REGISTERING"
)

// Defines values for V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus.
const (
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusCOREDUMPED V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusERROR      V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "ERROR"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusINVALID    V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "INVALID"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusPENDING    V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "PENDING"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusSIGNALED   V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "SIGNALED"
	V0041OpenapiJobInfoRespJobsDerivedExitCodeStatusSUCCESS    V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiJobInfoRespJobsExclusive.
const (
	V0041OpenapiJobInfoRespJobsExclusiveFalse V0041OpenapiJobInfoRespJobsExclusive = "false"
	V0041OpenapiJobInfoRespJobsExclusiveMcs   V0041OpenapiJobInfoRespJobsExclusive = "mcs"
	V0041OpenapiJobInfoRespJobsExclusiveTopo  V0041OpenapiJobInfoRespJobsExclusive = "topo"
	V0041OpenapiJobInfoRespJobsExclusiveTrue  V0041OpenapiJobInfoRespJobsExclusive = "true"
	V0041OpenapiJobInfoRespJobsExclusiveUser  V0041OpenapiJobInfoRespJobsExclusive = "user"
)

// Defines values for V0041OpenapiJobInfoRespJobsExitCodeStatus.
const (
	V0041OpenapiJobInfoRespJobsExitCodeStatusCOREDUMPED V0041OpenapiJobInfoRespJobsExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiJobInfoRespJobsExitCodeStatusERROR      V0041OpenapiJobInfoRespJobsExitCodeStatus = "ERROR"
	V0041OpenapiJobInfoRespJobsExitCodeStatusINVALID    V0041OpenapiJobInfoRespJobsExitCodeStatus = "INVALID"
	V0041OpenapiJobInfoRespJobsExitCodeStatusPENDING    V0041OpenapiJobInfoRespJobsExitCodeStatus = "PENDING"
	V0041OpenapiJobInfoRespJobsExitCodeStatusSIGNALED   V0041OpenapiJobInfoRespJobsExitCodeStatus = "SIGNALED"
	V0041OpenapiJobInfoRespJobsExitCodeStatusSUCCESS    V0041OpenapiJobInfoRespJobsExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiJobInfoRespJobsFlags.
const (
	V0041OpenapiJobInfoRespJobsFlagsACCRUECOUNTCLEARED       V0041OpenapiJobInfoRespJobsFlags = "ACCRUE_COUNT_CLEARED"
	V0041OpenapiJobInfoRespJobsFlagsBACKFILLATTEMPTED        V0041OpenapiJobInfoRespJobsFlags = "BACKFILL_ATTEMPTED"
	V0041OpenapiJobInfoRespJobsFlagsCRONJOB                  V0041OpenapiJobInfoRespJobsFlags = "CRON_JOB"
	V0041OpenapiJobInfoRespJobsFlagsDEPENDENT                V0041OpenapiJobInfoRespJobsFlags = "DEPENDENT"
	V0041OpenapiJobInfoRespJobsFlagsEXACTCPUCOUNTREQUESTED   V0041OpenapiJobInfoRespJobsFlags = "EXACT_CPU_COUNT_REQUESTED"
	V0041OpenapiJobInfoRespJobsFlagsEXACTMEMORYREQUESTED     V0041OpenapiJobInfoRespJobsFlags = "EXACT_MEMORY_REQUESTED"
	V0041OpenapiJobInfoRespJobsFlagsEXACTTASKCOUNTREQUESTED  V0041OpenapiJobInfoRespJobsFlags = "EXACT_TASK_COUNT_REQUESTED"
	V0041OpenapiJobInfoRespJobsFlagsGRESBINDINGDISABLED      V0041OpenapiJobInfoRespJobsFlags = "GRES_BINDING_DISABLED"
	V0041OpenapiJobInfoRespJobsFlagsGRESBINDINGENFORCED      V0041OpenapiJobInfoRespJobsFlags = "GRES_BINDING_ENFORCED"
	V0041OpenapiJobInfoRespJobsFlagsHASSTATEDIRECTORY        V0041OpenapiJobInfoRespJobsFlags = "HAS_STATE_DIRECTORY"
	V0041OpenapiJobInfoRespJobsFlagsHETEROGENEOUSJOB         V0041OpenapiJobInfoRespJobsFlags = "HETEROGENEOUS_JOB"
	V0041OpenapiJobInfoRespJobsFlagsJOBACCRUETIMERESET       V0041OpenapiJobInfoRespJobsFlags = "JOB_ACCRUE_TIME_RESET"
	V0041OpenapiJobInfoRespJobsFlagsJOBKILLHURRY             V0041OpenapiJobInfoRespJobsFlags = "JOB_KILL_HURRY"
	V0041OpenapiJobInfoRespJobsFlagsJOBWASRUNNING            V0041OpenapiJobInfoRespJobsFlags = "JOB_WAS_RUNNING"
	V0041OpenapiJobInfoRespJobsFlagsKILLINVALIDDEPENDENCY    V0041OpenapiJobInfoRespJobsFlags = "KILL_INVALID_DEPENDENCY"
	V0041OpenapiJobInfoRespJobsFlagsMAGNETIC                 V0041OpenapiJobInfoRespJobsFlags = "MAGNETIC"
	V0041OpenapiJobInfoRespJobsFlagsNOKILLINVALIDDEPENDENCY  V0041OpenapiJobInfoRespJobsFlags = "NO_KILL_INVALID_DEPENDENCY"
	V0041OpenapiJobInfoRespJobsFlagsPARTITIONASSIGNED        V0041OpenapiJobInfoRespJobsFlags = "PARTITION_ASSIGNED"
	V0041OpenapiJobInfoRespJobsFlagsPREFERMINIMUMNODECOUNT   V0041OpenapiJobInfoRespJobsFlags = "PREFER_MINIMUM_NODE_COUNT"
	V0041OpenapiJobInfoRespJobsFlagsSCHEDULINGATTEMPTED      V0041OpenapiJobInfoRespJobsFlags = "SCHEDULING_ATTEMPTED"
	V0041OpenapiJobInfoRespJobsFlagsSENDJOBENVIRONMENT       V0041OpenapiJobInfoRespJobsFlags = "SEND_JOB_ENVIRONMENT"
	V0041OpenapiJobInfoRespJobsFlagsSIBLINGCLUSTERUPDATEONLY V0041OpenapiJobInfoRespJobsFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	V0041OpenapiJobInfoRespJobsFlagsSKIPTRESSTRINGACCOUNTING V0041OpenapiJobInfoRespJobsFlags = "SKIP_TRES_STRING_ACCOUNTING"
	V0041OpenapiJobInfoRespJobsFlagsSPREADJOB                V0041OpenapiJobInfoRespJobsFlags = "SPREAD_JOB"
	V0041OpenapiJobInfoRespJobsFlagsSTEPMGRENABLED           V0041OpenapiJobInfoRespJobsFlags = "STEPMGR_ENABLED"
	V0041OpenapiJobInfoRespJobsFlagsTESTINGBACKFILL          V0041OpenapiJobInfoRespJobsFlags = "TESTING_BACKFILL"
	V0041OpenapiJobInfoRespJobsFlagsTESTINGWHOLENODEBACKFILL V0041OpenapiJobInfoRespJobsFlags = "TESTING_WHOLE_NODE_BACKFILL"
	V0041OpenapiJobInfoRespJobsFlagsTESTNOWONLY              V0041OpenapiJobInfoRespJobsFlags = "TEST_NOW_ONLY"
	V0041OpenapiJobInfoRespJobsFlagsTOPPRIORITYJOB           V0041OpenapiJobInfoRespJobsFlags = "TOP_PRIORITY_JOB"
	V0041OpenapiJobInfoRespJobsFlagsUSINGDEFAULTACCOUNT      V0041OpenapiJobInfoRespJobsFlags = "USING_DEFAULT_ACCOUNT"
	V0041OpenapiJobInfoRespJobsFlagsUSINGDEFAULTPARTITION    V0041OpenapiJobInfoRespJobsFlags = "USING_DEFAULT_PARTITION"
	V0041OpenapiJobInfoRespJobsFlagsUSINGDEFAULTQOS          V0041OpenapiJobInfoRespJobsFlags = "USING_DEFAULT_QOS"
	V0041OpenapiJobInfoRespJobsFlagsUSINGDEFAULTWCKEY        V0041OpenapiJobInfoRespJobsFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus.
const (
	V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatusALLOCATED   V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus = "ALLOCATED"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatusINUSE       V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus = "IN_USE"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatusINVALID     V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus = "INVALID"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatusUNALLOCATED V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus = "UNALLOCATED"
)

// Defines values for V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType.
const (
	V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectTypeAVAILABLE V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType = "AVAILABLE"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectTypeONEROW    V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType = "ONE_ROW"
	V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectTypeRESERVED  V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType = "RESERVED"
)

// Defines values for V0041OpenapiJobInfoRespJobsJobResourcesSelectType.
const (
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeBOARD                V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "BOARD"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeCORE                 V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "CORE"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeCOREDEFAULTDISTBLOCK V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "CORE_DEFAULT_DIST_BLOCK"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeCPU                  V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "CPU"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeLINEAR               V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "LINEAR"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeLLN                  V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "LLN"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeMEMORY               V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "MEMORY"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeONETASKPERCORE       V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "ONE_TASK_PER_CORE"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypePACKNODES            V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "PACK_NODES"
	V0041OpenapiJobInfoRespJobsJobResourcesSelectTypeSOCKET               V0041OpenapiJobInfoRespJobsJobResourcesSelectType = "SOCKET"
)

// Defines values for V0041OpenapiJobInfoRespJobsJobState.
const (
	V0041OpenapiJobInfoRespJobsJobStateBOOTFAIL     V0041OpenapiJobInfoRespJobsJobState = "BOOT_FAIL"
	V0041OpenapiJobInfoRespJobsJobStateCANCELLED    V0041OpenapiJobInfoRespJobsJobState = "CANCELLED"
	V0041OpenapiJobInfoRespJobsJobStateCOMPLETED    V0041OpenapiJobInfoRespJobsJobState = "COMPLETED"
	V0041OpenapiJobInfoRespJobsJobStateCOMPLETING   V0041OpenapiJobInfoRespJobsJobState = "COMPLETING"
	V0041OpenapiJobInfoRespJobsJobStateCONFIGURING  V0041OpenapiJobInfoRespJobsJobState = "CONFIGURING"
	V0041OpenapiJobInfoRespJobsJobStateDEADLINE     V0041OpenapiJobInfoRespJobsJobState = "DEADLINE"
	V0041OpenapiJobInfoRespJobsJobStateFAILED       V0041OpenapiJobInfoRespJobsJobState = "FAILED"
	V0041OpenapiJobInfoRespJobsJobStateLAUNCHFAILED V0041OpenapiJobInfoRespJobsJobState = "LAUNCH_FAILED"
	V0041OpenapiJobInfoRespJobsJobStateNODEFAIL     V0041OpenapiJobInfoRespJobsJobState = "NODE_FAIL"
	V0041OpenapiJobInfoRespJobsJobStateOUTOFMEMORY  V0041OpenapiJobInfoRespJobsJobState = "OUT_OF_MEMORY"
	V0041OpenapiJobInfoRespJobsJobStatePENDING      V0041OpenapiJobInfoRespJobsJobState = "PENDING"
	V0041OpenapiJobInfoRespJobsJobStatePOWERUPNODE  V0041OpenapiJobInfoRespJobsJobState = "POWER_UP_NODE"
	V0041OpenapiJobInfoRespJobsJobStatePREEMPTED    V0041OpenapiJobInfoRespJobsJobState = "PREEMPTED"
	V0041OpenapiJobInfoRespJobsJobStateRECONFIGFAIL V0041OpenapiJobInfoRespJobsJobState = "RECONFIG_FAIL"
	V0041OpenapiJobInfoRespJobsJobStateREQUEUED     V0041OpenapiJobInfoRespJobsJobState = "REQUEUED"
	V0041OpenapiJobInfoRespJobsJobStateREQUEUEFED   V0041OpenapiJobInfoRespJobsJobState = "REQUEUE_FED"
	V0041OpenapiJobInfoRespJobsJobStateREQUEUEHOLD  V0041OpenapiJobInfoRespJobsJobState = "REQUEUE_HOLD"
	V0041OpenapiJobInfoRespJobsJobStateRESIZING     V0041OpenapiJobInfoRespJobsJobState = "RESIZING"
	V0041OpenapiJobInfoRespJobsJobStateRESVDELHOLD  V0041OpenapiJobInfoRespJobsJobState = "RESV_DEL_HOLD"
	V0041OpenapiJobInfoRespJobsJobStateREVOKED      V0041OpenapiJobInfoRespJobsJobState = "REVOKED"
	V0041OpenapiJobInfoRespJobsJobStateRUNNING      V0041OpenapiJobInfoRespJobsJobState = "RUNNING"
	V0041OpenapiJobInfoRespJobsJobStateSIGNALING    V0041OpenapiJobInfoRespJobsJobState = "SIGNALING"
	V0041OpenapiJobInfoRespJobsJobStateSPECIALEXIT  V0041OpenapiJobInfoRespJobsJobState = "SPECIAL_EXIT"
	V0041OpenapiJobInfoRespJobsJobStateSTAGEOUT     V0041OpenapiJobInfoRespJobsJobState = "STAGE_OUT"
	V0041OpenapiJobInfoRespJobsJobStateSTOPPED      V0041OpenapiJobInfoRespJobsJobState = "STOPPED"
	V0041OpenapiJobInfoRespJobsJobStateSUSPENDED    V0041OpenapiJobInfoRespJobsJobState = "SUSPENDED"
	V0041OpenapiJobInfoRespJobsJobStateTIMEOUT      V0041OpenapiJobInfoRespJobsJobState = "TIMEOUT"
)

// Defines values for V0041OpenapiJobInfoRespJobsMailType.
const (
	V0041OpenapiJobInfoRespJobsMailTypeARRAYTASKS        V0041OpenapiJobInfoRespJobsMailType = "ARRAY_TASKS"
	V0041OpenapiJobInfoRespJobsMailTypeBEGIN             V0041OpenapiJobInfoRespJobsMailType = "BEGIN"
	V0041OpenapiJobInfoRespJobsMailTypeEND               V0041OpenapiJobInfoRespJobsMailType = "END"
	V0041OpenapiJobInfoRespJobsMailTypeFAIL              V0041OpenapiJobInfoRespJobsMailType = "FAIL"
	V0041OpenapiJobInfoRespJobsMailTypeINVALIDDEPENDENCY V0041OpenapiJobInfoRespJobsMailType = "INVALID_DEPENDENCY"
	V0041OpenapiJobInfoRespJobsMailTypeREQUEUE           V0041OpenapiJobInfoRespJobsMailType = "REQUEUE"
	V0041OpenapiJobInfoRespJobsMailTypeSTAGEOUT          V0041OpenapiJobInfoRespJobsMailType = "STAGE_OUT"
	V0041OpenapiJobInfoRespJobsMailTypeTIME100           V0041OpenapiJobInfoRespJobsMailType = "TIME=100%"
	V0041OpenapiJobInfoRespJobsMailTypeTIME50            V0041OpenapiJobInfoRespJobsMailType = "TIME=50%"
	V0041OpenapiJobInfoRespJobsMailTypeTIME80            V0041OpenapiJobInfoRespJobsMailType = "TIME=80%"
	V0041OpenapiJobInfoRespJobsMailTypeTIME90            V0041OpenapiJobInfoRespJobsMailType = "TIME=90%"
)

// Defines values for V0041OpenapiJobInfoRespJobsProfile.
const (
	V0041OpenapiJobInfoRespJobsProfileENERGY  V0041OpenapiJobInfoRespJobsProfile = "ENERGY"
	V0041OpenapiJobInfoRespJobsProfileLUSTRE  V0041OpenapiJobInfoRespJobsProfile = "LUSTRE"
	V0041OpenapiJobInfoRespJobsProfileNETWORK V0041OpenapiJobInfoRespJobsProfile = "NETWORK"
	V0041OpenapiJobInfoRespJobsProfileNONE    V0041OpenapiJobInfoRespJobsProfile = "NONE"
	V0041OpenapiJobInfoRespJobsProfileNOTSET  V0041OpenapiJobInfoRespJobsProfile = "NOT_SET"
	V0041OpenapiJobInfoRespJobsProfileTASK    V0041OpenapiJobInfoRespJobsProfile = "TASK"
)

// Defines values for V0041OpenapiJobInfoRespJobsShared.
const (
	V0041OpenapiJobInfoRespJobsSharedMcs           V0041OpenapiJobInfoRespJobsShared = "mcs"
	V0041OpenapiJobInfoRespJobsSharedNone          V0041OpenapiJobInfoRespJobsShared = "none"
	V0041OpenapiJobInfoRespJobsSharedOversubscribe V0041OpenapiJobInfoRespJobsShared = "oversubscribe"
	V0041OpenapiJobInfoRespJobsSharedTopo          V0041OpenapiJobInfoRespJobsShared = "topo"
	V0041OpenapiJobInfoRespJobsSharedUser          V0041OpenapiJobInfoRespJobsShared = "user"
)

// Defines values for V0041OpenapiJobInfoRespJobsShowFlags.
const (
	V0041OpenapiJobInfoRespJobsShowFlagsALL        V0041OpenapiJobInfoRespJobsShowFlags = "ALL"
	V0041OpenapiJobInfoRespJobsShowFlagsDETAIL     V0041OpenapiJobInfoRespJobsShowFlags = "DETAIL"
	V0041OpenapiJobInfoRespJobsShowFlagsFEDERATION V0041OpenapiJobInfoRespJobsShowFlags = "FEDERATION"
	V0041OpenapiJobInfoRespJobsShowFlagsFUTURE     V0041OpenapiJobInfoRespJobsShowFlags = "FUTURE"
	V0041OpenapiJobInfoRespJobsShowFlagsLOCAL      V0041OpenapiJobInfoRespJobsShowFlags = "LOCAL"
	V0041OpenapiJobInfoRespJobsShowFlagsMIXED      V0041OpenapiJobInfoRespJobsShowFlags = "MIXED"
	V0041OpenapiJobInfoRespJobsShowFlagsSIBLING    V0041OpenapiJobInfoRespJobsShowFlags = "SIBLING"
)

// Defines values for V0041OpenapiNodesRespNodesNextStateAfterReboot.
const (
	V0041OpenapiNodesRespNodesNextStateAfterRebootALLOCATED       V0041OpenapiNodesRespNodesNextStateAfterReboot = "ALLOCATED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootCLOUD           V0041OpenapiNodesRespNodesNextStateAfterReboot = "CLOUD"
	V0041OpenapiNodesRespNodesNextStateAfterRebootCOMPLETING      V0041OpenapiNodesRespNodesNextStateAfterReboot = "COMPLETING"
	V0041OpenapiNodesRespNodesNextStateAfterRebootDOWN            V0041OpenapiNodesRespNodesNextStateAfterReboot = "DOWN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootDRAIN           V0041OpenapiNodesRespNodesNextStateAfterReboot = "DRAIN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootDYNAMICFUTURE   V0041OpenapiNodesRespNodesNextStateAfterReboot = "DYNAMIC_FUTURE"
	V0041OpenapiNodesRespNodesNextStateAfterRebootDYNAMICNORM     V0041OpenapiNodesRespNodesNextStateAfterReboot = "DYNAMIC_NORM"
	V0041OpenapiNodesRespNodesNextStateAfterRebootERROR           V0041OpenapiNodesRespNodesNextStateAfterReboot = "ERROR"
	V0041OpenapiNodesRespNodesNextStateAfterRebootFAIL            V0041OpenapiNodesRespNodesNextStateAfterReboot = "FAIL"
	V0041OpenapiNodesRespNodesNextStateAfterRebootFUTURE          V0041OpenapiNodesRespNodesNextStateAfterReboot = "FUTURE"
	V0041OpenapiNodesRespNodesNextStateAfterRebootIDLE            V0041OpenapiNodesRespNodesNextStateAfterReboot = "IDLE"
	V0041OpenapiNodesRespNodesNextStateAfterRebootINVALID         V0041OpenapiNodesRespNodesNextStateAfterReboot = "INVALID"
	V0041OpenapiNodesRespNodesNextStateAfterRebootINVALIDREG      V0041OpenapiNodesRespNodesNextStateAfterReboot = "INVALID_REG"
	V0041OpenapiNodesRespNodesNextStateAfterRebootMAINTENANCE     V0041OpenapiNodesRespNodesNextStateAfterReboot = "MAINTENANCE"
	V0041OpenapiNodesRespNodesNextStateAfterRebootMIXED           V0041OpenapiNodesRespNodesNextStateAfterReboot = "MIXED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootNOTRESPONDING   V0041OpenapiNodesRespNodesNextStateAfterReboot = "NOT_RESPONDING"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPLANNED         V0041OpenapiNodesRespNodesNextStateAfterReboot = "PLANNED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERDOWN       V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWER_DOWN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERDRAIN      V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWER_DRAIN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWEREDDOWN     V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWERED_DOWN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERINGDOWN    V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWERING_DOWN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERINGUP      V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWERING_UP"
	V0041OpenapiNodesRespNodesNextStateAfterRebootPOWERUP         V0041OpenapiNodesRespNodesNextStateAfterReboot = "POWER_UP"
	V0041OpenapiNodesRespNodesNextStateAfterRebootREBOOTCANCELED  V0041OpenapiNodesRespNodesNextStateAfterReboot = "REBOOT_CANCELED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootREBOOTISSUED    V0041OpenapiNodesRespNodesNextStateAfterReboot = "REBOOT_ISSUED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootREBOOTREQUESTED V0041OpenapiNodesRespNodesNextStateAfterReboot = "REBOOT_REQUESTED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootRESERVED        V0041OpenapiNodesRespNodesNextStateAfterReboot = "RESERVED"
	V0041OpenapiNodesRespNodesNextStateAfterRebootRESUME          V0041OpenapiNodesRespNodesNextStateAfterReboot = "RESUME"
	V0041OpenapiNodesRespNodesNextStateAfterRebootUNDRAIN         V0041OpenapiNodesRespNodesNextStateAfterReboot = "UNDRAIN"
	V0041OpenapiNodesRespNodesNextStateAfterRebootUNKNOWN         V0041OpenapiNodesRespNodesNextStateAfterReboot = "UNKNOWN"
)

// Defines values for V0041OpenapiNodesRespNodesState.
const (
	V0041OpenapiNodesRespNodesStateALLOCATED       V0041OpenapiNodesRespNodesState = "ALLOCATED"
	V0041OpenapiNodesRespNodesStateCLOUD           V0041OpenapiNodesRespNodesState = "CLOUD"
	V0041OpenapiNodesRespNodesStateCOMPLETING      V0041OpenapiNodesRespNodesState = "COMPLETING"
	V0041OpenapiNodesRespNodesStateDOWN            V0041OpenapiNodesRespNodesState = "DOWN"
	V0041OpenapiNodesRespNodesStateDRAIN           V0041OpenapiNodesRespNodesState = "DRAIN"
	V0041OpenapiNodesRespNodesStateDYNAMICFUTURE   V0041OpenapiNodesRespNodesState = "DYNAMIC_FUTURE"
	V0041OpenapiNodesRespNodesStateDYNAMICNORM     V0041OpenapiNodesRespNodesState = "DYNAMIC_NORM"
	V0041OpenapiNodesRespNodesStateERROR           V0041OpenapiNodesRespNodesState = "ERROR"
	V0041OpenapiNodesRespNodesStateFAIL            V0041OpenapiNodesRespNodesState = "FAIL"
	V0041OpenapiNodesRespNodesStateFUTURE          V0041OpenapiNodesRespNodesState = "FUTURE"
	V0041OpenapiNodesRespNodesStateIDLE            V0041OpenapiNodesRespNodesState = "IDLE"
	V0041OpenapiNodesRespNodesStateINVALID         V0041OpenapiNodesRespNodesState = "INVALID"
	V0041OpenapiNodesRespNodesStateINVALIDREG      V0041OpenapiNodesRespNodesState = "INVALID_REG"
	V0041OpenapiNodesRespNodesStateMAINTENANCE     V0041OpenapiNodesRespNodesState = "MAINTENANCE"
	V0041OpenapiNodesRespNodesStateMIXED           V0041OpenapiNodesRespNodesState = "MIXED"
	V0041OpenapiNodesRespNodesStateNOTRESPONDING   V0041OpenapiNodesRespNodesState = "NOT_RESPONDING"
	V0041OpenapiNodesRespNodesStatePLANNED         V0041OpenapiNodesRespNodesState = "PLANNED"
	V0041OpenapiNodesRespNodesStatePOWERDOWN       V0041OpenapiNodesRespNodesState = "POWER_DOWN"
	V0041OpenapiNodesRespNodesStatePOWERDRAIN      V0041OpenapiNodesRespNodesState = "POWER_DRAIN"
	V0041OpenapiNodesRespNodesStatePOWEREDDOWN     V0041OpenapiNodesRespNodesState = "POWERED_DOWN"
	V0041OpenapiNodesRespNodesStatePOWERINGDOWN    V0041OpenapiNodesRespNodesState = "POWERING_DOWN"
	V0041OpenapiNodesRespNodesStatePOWERINGUP      V0041OpenapiNodesRespNodesState = "POWERING_UP"
	V0041OpenapiNodesRespNodesStatePOWERUP         V0041OpenapiNodesRespNodesState = "POWER_UP"
	V0041OpenapiNodesRespNodesStateREBOOTCANCELED  V0041OpenapiNodesRespNodesState = "REBOOT_CANCELED"
	V0041OpenapiNodesRespNodesStateREBOOTISSUED    V0041OpenapiNodesRespNodesState = "REBOOT_ISSUED"
	V0041OpenapiNodesRespNodesStateREBOOTREQUESTED V0041OpenapiNodesRespNodesState = "REBOOT_REQUESTED"
	V0041OpenapiNodesRespNodesStateRESERVED        V0041OpenapiNodesRespNodesState = "RESERVED"
	V0041OpenapiNodesRespNodesStateRESUME          V0041OpenapiNodesRespNodesState = "RESUME"
	V0041OpenapiNodesRespNodesStateUNDRAIN         V0041OpenapiNodesRespNodesState = "UNDRAIN"
	V0041OpenapiNodesRespNodesStateUNKNOWN         V0041OpenapiNodesRespNodesState = "UNKNOWN"
)

// Defines values for V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags.
const (
	Force V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags = "force"
)

// Defines values for V0041OpenapiPartitionRespPartitionsPartitionState.
const (
	V0041OpenapiPartitionRespPartitionsPartitionStateDOWN     V0041OpenapiPartitionRespPartitionsPartitionState = "DOWN"
	V0041OpenapiPartitionRespPartitionsPartitionStateDRAIN    V0041OpenapiPartitionRespPartitionsPartitionState = "DRAIN"
	V0041OpenapiPartitionRespPartitionsPartitionStateINACTIVE V0041OpenapiPartitionRespPartitionsPartitionState = "INACTIVE"
	V0041OpenapiPartitionRespPartitionsPartitionStateUNKNOWN  V0041OpenapiPartitionRespPartitionsPartitionState = "UNKNOWN"
	V0041OpenapiPartitionRespPartitionsPartitionStateUP       V0041OpenapiPartitionRespPartitionsPartitionState = "UP"
)

// Defines values for V0041OpenapiPartitionRespPartitionsSelectType.
const (
	V0041OpenapiPartitionRespPartitionsSelectTypeBOARD                V0041OpenapiPartitionRespPartitionsSelectType = "BOARD"
	V0041OpenapiPartitionRespPartitionsSelectTypeCORE                 V0041OpenapiPartitionRespPartitionsSelectType = "CORE"
	V0041OpenapiPartitionRespPartitionsSelectTypeCOREDEFAULTDISTBLOCK V0041OpenapiPartitionRespPartitionsSelectType = "CORE_DEFAULT_DIST_BLOCK"
	V0041OpenapiPartitionRespPartitionsSelectTypeCPU                  V0041OpenapiPartitionRespPartitionsSelectType = "CPU"
	V0041OpenapiPartitionRespPartitionsSelectTypeLINEAR               V0041OpenapiPartitionRespPartitionsSelectType = "LINEAR"
	V0041OpenapiPartitionRespPartitionsSelectTypeLLN                  V0041OpenapiPartitionRespPartitionsSelectType = "LLN"
	V0041OpenapiPartitionRespPartitionsSelectTypeMEMORY               V0041OpenapiPartitionRespPartitionsSelectType = "MEMORY"
	V0041OpenapiPartitionRespPartitionsSelectTypeONETASKPERCORE       V0041OpenapiPartitionRespPartitionsSelectType = "ONE_TASK_PER_CORE"
	V0041OpenapiPartitionRespPartitionsSelectTypePACKNODES            V0041OpenapiPartitionRespPartitionsSelectType = "PACK_NODES"
	V0041OpenapiPartitionRespPartitionsSelectTypeSOCKET               V0041OpenapiPartitionRespPartitionsSelectType = "SOCKET"
)

// Defines values for V0041OpenapiReservationRespReservationsFlags.
const (
	V0041OpenapiReservationRespReservationsFlagsALLNODES           V0041OpenapiReservationRespReservationsFlags = "ALL_NODES"
	V0041OpenapiReservationRespReservationsFlagsANYNODES           V0041OpenapiReservationRespReservationsFlags = "ANY_NODES"
	V0041OpenapiReservationRespReservationsFlagsDAILY              V0041OpenapiReservationRespReservationsFlags = "DAILY"
	V0041OpenapiReservationRespReservationsFlagsDURATIONMINUS      V0041OpenapiReservationRespReservationsFlags = "DURATION_MINUS"
	V0041OpenapiReservationRespReservationsFlagsDURATIONPLUS       V0041OpenapiReservationRespReservationsFlags = "DURATION_PLUS"
	V0041OpenapiReservationRespReservationsFlagsFLEX               V0041OpenapiReservationRespReservationsFlags = "FLEX"
	V0041OpenapiReservationRespReservationsFlagsHOURLY             V0041OpenapiReservationRespReservationsFlags = "HOURLY"
	V0041OpenapiReservationRespReservationsFlagsIGNOREJOBS         V0041OpenapiReservationRespReservationsFlags = "IGNORE_JOBS"
	V0041OpenapiReservationRespReservationsFlagsMAGNETIC           V0041OpenapiReservationRespReservationsFlags = "MAGNETIC"
	V0041OpenapiReservationRespReservationsFlagsMAINT              V0041OpenapiReservationRespReservationsFlags = "MAINT"
	V0041OpenapiReservationRespReservationsFlagsNODAILY            V0041OpenapiReservationRespReservationsFlags = "NO_DAILY"
	V0041OpenapiReservationRespReservationsFlagsNOFLEX             V0041OpenapiReservationRespReservationsFlags = "NO_FLEX"
	V0041OpenapiReservationRespReservationsFlagsNOHOLDJOBSAFTEREND V0041OpenapiReservationRespReservationsFlags = "NO_HOLD_JOBS_AFTER_END"
	V0041OpenapiReservationRespReservationsFlagsNOHOURLY           V0041OpenapiReservationRespReservationsFlags = "NO_HOURLY"
	V0041OpenapiReservationRespReservationsFlagsNOIGNOREJOBS       V0041OpenapiReservationRespReservationsFlags = "NO_IGNORE_JOBS"
	V0041OpenapiReservationRespReservationsFlagsNOMAINT            V0041OpenapiReservationRespReservationsFlags = "NO_MAINT"
	V0041OpenapiReservationRespReservationsFlagsNOPARTNODES        V0041OpenapiReservationRespReservationsFlags = "NO_PART_NODES"
	V0041OpenapiReservationRespReservationsFlagsNOPURGECOMP        V0041OpenapiReservationRespReservationsFlags = "NO_PURGE_COMP"
	V0041OpenapiReservationRespReservationsFlagsNOSTATIC           V0041OpenapiReservationRespReservationsFlags = "NO_STATIC"
	V0041OpenapiReservationRespReservationsFlagsNOUSERDELETE       V0041OpenapiReservationRespReservationsFlags = "NO_USER_DELETE"
	V0041OpenapiReservationRespReservationsFlagsNOWEEKDAY          V0041OpenapiReservationRespReservationsFlags = "NO_WEEKDAY"
	V0041OpenapiReservationRespReservationsFlagsNOWEEKEND          V0041OpenapiReservationRespReservationsFlags = "NO_WEEKEND"
	V0041OpenapiReservationRespReservationsFlagsNOWEEKLY           V0041OpenapiReservationRespReservationsFlags = "NO_WEEKLY"
	V0041OpenapiReservationRespReservationsFlagsOVERLAP            V0041OpenapiReservationRespReservationsFlags = "OVERLAP"
	V0041OpenapiReservationRespReservationsFlagsPARTNODES          V0041OpenapiReservationRespReservationsFlags = "PART_NODES"
	V0041OpenapiReservationRespReservationsFlagsPURGECOMP          V0041OpenapiReservationRespReservationsFlags = "PURGE_COMP"
	V0041OpenapiReservationRespReservationsFlagsREOCCURRING        V0041OpenapiReservationRespReservationsFlags = "REOCCURRING"
	V0041OpenapiReservationRespReservationsFlagsREPLACE            V0041OpenapiReservationRespReservationsFlags = "REPLACE"
	V0041OpenapiReservationRespReservationsFlagsSKIP               V0041OpenapiReservationRespReservationsFlags = "SKIP"
	V0041OpenapiReservationRespReservationsFlagsSPECNODES          V0041OpenapiReservationRespReservationsFlags = "SPEC_NODES"
	V0041OpenapiReservationRespReservationsFlagsSTATIC             V0041OpenapiReservationRespReservationsFlags = "STATIC"
	V0041OpenapiReservationRespReservationsFlagsTIMEFLOAT          V0041OpenapiReservationRespReservationsFlags = "TIME_FLOAT"
	V0041OpenapiReservationRespReservationsFlagsUSERDELETE         V0041OpenapiReservationRespReservationsFlags = "USER_DELETE"
	V0041OpenapiReservationRespReservationsFlagsWEEKDAY            V0041OpenapiReservationRespReservationsFlags = "WEEKDAY"
	V0041OpenapiReservationRespReservationsFlagsWEEKEND            V0041OpenapiReservationRespReservationsFlags = "WEEKEND"
	V0041OpenapiReservationRespReservationsFlagsWEEKLY             V0041OpenapiReservationRespReservationsFlags = "WEEKLY"
)

// Defines values for V0041OpenapiSharesRespSharesSharesType.
const (
	ASSOCIATION V0041OpenapiSharesRespSharesSharesType = "ASSOCIATION"
	USER        V0041OpenapiSharesRespSharesSharesType = "USER"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespAccountsFlags.
const (
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsDELETED          V0041OpenapiSlurmdbdConfigRespAccountsFlags = "DELETED"
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsNoUsersAreCoords V0041OpenapiSlurmdbdConfigRespAccountsFlags = "NoUsersAreCoords"
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsUsersAreCoords   V0041OpenapiSlurmdbdConfigRespAccountsFlags = "UsersAreCoords"
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsWithAssociations V0041OpenapiSlurmdbdConfigRespAccountsFlags = "WithAssociations"
	V0041OpenapiSlurmdbdConfigRespAccountsFlagsWithCoordinators V0041OpenapiSlurmdbdConfigRespAccountsFlags = "WithCoordinators"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespAssociationsFlags.
const (
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsDELETED          V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "DELETED"
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsExact            V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "Exact"
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsNoUpdate         V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "NoUpdate"
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsNoUsersAreCoords V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "NoUsersAreCoords"
	V0041OpenapiSlurmdbdConfigRespAssociationsFlagsUsersAreCoords   V0041OpenapiSlurmdbdConfigRespAssociationsFlags = "UsersAreCoords"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespClustersFlags.
const (
	V0041OpenapiSlurmdbdConfigRespClustersFlagsEXTERNAL       V0041OpenapiSlurmdbdConfigRespClustersFlags = "EXTERNAL"
	V0041OpenapiSlurmdbdConfigRespClustersFlagsFEDERATION     V0041OpenapiSlurmdbdConfigRespClustersFlags = "FEDERATION"
	V0041OpenapiSlurmdbdConfigRespClustersFlagsFRONTEND       V0041OpenapiSlurmdbdConfigRespClustersFlags = "FRONT_END"
	V0041OpenapiSlurmdbdConfigRespClustersFlagsMULTIPLESLURMD V0041OpenapiSlurmdbdConfigRespClustersFlags = "MULTIPLE_SLURMD"
	V0041OpenapiSlurmdbdConfigRespClustersFlagsREGISTERING    V0041OpenapiSlurmdbdConfigRespClustersFlags = "REGISTERING"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespQosFlags.
const (
	V0041OpenapiSlurmdbdConfigRespQosFlagsADD                   V0041OpenapiSlurmdbdConfigRespQosFlags = "ADD"
	V0041OpenapiSlurmdbdConfigRespQosFlagsDENYLIMIT             V0041OpenapiSlurmdbdConfigRespQosFlags = "DENY_LIMIT"
	V0041OpenapiSlurmdbdConfigRespQosFlagsENFORCEUSAGETHRESHOLD V0041OpenapiSlurmdbdConfigRespQosFlags = "ENFORCE_USAGE_THRESHOLD"
	V0041OpenapiSlurmdbdConfigRespQosFlagsNODECAY               V0041OpenapiSlurmdbdConfigRespQosFlags = "NO_DECAY"
	V0041OpenapiSlurmdbdConfigRespQosFlagsNORESERVE             V0041OpenapiSlurmdbdConfigRespQosFlags = "NO_RESERVE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsNOTSET                V0041OpenapiSlurmdbdConfigRespQosFlags = "NOT_SET"
	V0041OpenapiSlurmdbdConfigRespQosFlagsOVERRIDEPARTITIONQOS  V0041OpenapiSlurmdbdConfigRespQosFlags = "OVERRIDE_PARTITION_QOS"
	V0041OpenapiSlurmdbdConfigRespQosFlagsPARTITIONMAXIMUMNODE  V0041OpenapiSlurmdbdConfigRespQosFlags = "PARTITION_MAXIMUM_NODE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsPARTITIONMINIMUMNODE  V0041OpenapiSlurmdbdConfigRespQosFlags = "PARTITION_MINIMUM_NODE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsPARTITIONTIMELIMIT    V0041OpenapiSlurmdbdConfigRespQosFlags = "PARTITION_TIME_LIMIT"
	V0041OpenapiSlurmdbdConfigRespQosFlagsRELATIVE              V0041OpenapiSlurmdbdConfigRespQosFlags = "RELATIVE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsREMOVE                V0041OpenapiSlurmdbdConfigRespQosFlags = "REMOVE"
	V0041OpenapiSlurmdbdConfigRespQosFlagsREQUIREDRESERVATION   V0041OpenapiSlurmdbdConfigRespQosFlags = "REQUIRED_RESERVATION"
	V0041OpenapiSlurmdbdConfigRespQosFlagsUSAGEFACTORSAFE       V0041OpenapiSlurmdbdConfigRespQosFlags = "USAGE_FACTOR_SAFE"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespQosPreemptMode.
const (
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeCANCEL   V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "CANCEL"
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeDISABLED V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "DISABLED"
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeGANG     V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "GANG"
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeREQUEUE  V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "REQUEUE"
	V0041OpenapiSlurmdbdConfigRespQosPreemptModeSUSPEND  V0041OpenapiSlurmdbdConfigRespQosPreemptMode = "SUSPEND"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel.
const (
	V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevelAdministrator V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel = "Administrator"
	V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevelNone          V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel = "None"
	V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevelNotSet        V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel = "Not Set"
	V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevelOperator      V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel = "Operator"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespUsersFlags.
const (
	V0041OpenapiSlurmdbdConfigRespUsersFlagsDELETED V0041OpenapiSlurmdbdConfigRespUsersFlags = "DELETED"
	V0041OpenapiSlurmdbdConfigRespUsersFlagsNONE    V0041OpenapiSlurmdbdConfigRespUsersFlags = "NONE"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags.
const (
	V0041OpenapiSlurmdbdConfigRespUsersWckeysFlagsDELETED V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags = "DELETED"
)

// Defines values for V0041OpenapiSlurmdbdConfigRespWckeysFlags.
const (
	V0041OpenapiSlurmdbdConfigRespWckeysFlagsDELETED V0041OpenapiSlurmdbdConfigRespWckeysFlags = "DELETED"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus.
const (
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusCOREDUMPED V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusERROR      V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "ERROR"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusINVALID    V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "INVALID"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusPENDING    V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusSIGNALED   V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "SIGNALED"
	V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatusSUCCESS    V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus.
const (
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusCOREDUMPED V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusERROR      V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "ERROR"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusINVALID    V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "INVALID"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusPENDING    V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusSIGNALED   V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "SIGNALED"
	V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatusSUCCESS    V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsFlags.
const (
	V0041OpenapiSlurmdbdJobsRespJobsFlagsCLEARSCHEDULING   V0041OpenapiSlurmdbdJobsRespJobsFlags = "CLEAR_SCHEDULING"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsNONE              V0041OpenapiSlurmdbdJobsRespJobsFlags = "NONE"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsNOTSET            V0041OpenapiSlurmdbdJobsRespJobsFlags = "NOT_SET"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsSTARTEDONBACKFILL V0041OpenapiSlurmdbdJobsRespJobsFlags = "STARTED_ON_BACKFILL"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsSTARTEDONSCHEDULE V0041OpenapiSlurmdbdJobsRespJobsFlags = "STARTED_ON_SCHEDULE"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsSTARTEDONSUBMIT   V0041OpenapiSlurmdbdJobsRespJobsFlags = "STARTED_ON_SUBMIT"
	V0041OpenapiSlurmdbdJobsRespJobsFlagsSTARTRECEIVED     V0041OpenapiSlurmdbdJobsRespJobsFlags = "START_RECEIVED"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsStateCurrent.
const (
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentBOOTFAIL     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "BOOT_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentCANCELLED    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "CANCELLED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentCOMPLETED    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "COMPLETED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentCOMPLETING   V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "COMPLETING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentCONFIGURING  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "CONFIGURING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentDEADLINE     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "DEADLINE"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentFAILED       V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "FAILED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentLAUNCHFAILED V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "LAUNCH_FAILED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentNODEFAIL     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "NODE_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentOUTOFMEMORY  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "OUT_OF_MEMORY"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentPENDING      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentPOWERUPNODE  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "POWER_UP_NODE"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentPREEMPTED    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "PREEMPTED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentRECONFIGFAIL V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "RECONFIG_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentREQUEUED     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "REQUEUED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentREQUEUEFED   V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "REQUEUE_FED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentREQUEUEHOLD  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "REQUEUE_HOLD"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentRESIZING     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "RESIZING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentRESVDELHOLD  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "RESV_DEL_HOLD"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentREVOKED      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "REVOKED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentRUNNING      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "RUNNING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSIGNALING    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "SIGNALING"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSPECIALEXIT  V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "SPECIAL_EXIT"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSTAGEOUT     V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "STAGE_OUT"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSTOPPED      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "STOPPED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentSUSPENDED    V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "SUSPENDED"
	V0041OpenapiSlurmdbdJobsRespJobsStateCurrentTIMEOUT      V0041OpenapiSlurmdbdJobsRespJobsStateCurrent = "TIMEOUT"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus.
const (
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusCOREDUMPED V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "CORE_DUMPED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusERROR      V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "ERROR"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusINVALID    V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "INVALID"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusPENDING    V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusSIGNALED   V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "SIGNALED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatusSUCCESS    V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus = "SUCCESS"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsStepsState.
const (
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateBOOTFAIL     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "BOOT_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateCANCELLED    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "CANCELLED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateCOMPLETED    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "COMPLETED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateCOMPLETING   V0041OpenapiSlurmdbdJobsRespJobsStepsState = "COMPLETING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateCONFIGURING  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "CONFIGURING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateDEADLINE     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "DEADLINE"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateFAILED       V0041OpenapiSlurmdbdJobsRespJobsStepsState = "FAILED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateLAUNCHFAILED V0041OpenapiSlurmdbdJobsRespJobsStepsState = "LAUNCH_FAILED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateNODEFAIL     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "NODE_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateOUTOFMEMORY  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "OUT_OF_MEMORY"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStatePENDING      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "PENDING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStatePOWERUPNODE  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "POWER_UP_NODE"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStatePREEMPTED    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "PREEMPTED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateRECONFIGFAIL V0041OpenapiSlurmdbdJobsRespJobsStepsState = "RECONFIG_FAIL"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateREQUEUED     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "REQUEUED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateREQUEUEFED   V0041OpenapiSlurmdbdJobsRespJobsStepsState = "REQUEUE_FED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateREQUEUEHOLD  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "REQUEUE_HOLD"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateRESIZING     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "RESIZING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateRESVDELHOLD  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "RESV_DEL_HOLD"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateREVOKED      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "REVOKED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateRUNNING      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "RUNNING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSIGNALING    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "SIGNALING"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSPECIALEXIT  V0041OpenapiSlurmdbdJobsRespJobsStepsState = "SPECIAL_EXIT"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSTAGEOUT     V0041OpenapiSlurmdbdJobsRespJobsStepsState = "STAGE_OUT"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSTOPPED      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "STOPPED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateSUSPENDED    V0041OpenapiSlurmdbdJobsRespJobsStepsState = "SUSPENDED"
	V0041OpenapiSlurmdbdJobsRespJobsStepsStateTIMEOUT      V0041OpenapiSlurmdbdJobsRespJobsStepsState = "TIMEOUT"
)

// Defines values for V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags.
const (
	ASSIGNEDDEFAULT V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags = "ASSIGNED_DEFAULT"
)

// Defines values for V0041OpenapiSlurmdbdQosRespQosFlags.
const (
	V0041OpenapiSlurmdbdQosRespQosFlagsADD                   V0041OpenapiSlurmdbdQosRespQosFlags = "ADD"
	V0041OpenapiSlurmdbdQosRespQosFlagsDENYLIMIT             V0041OpenapiSlurmdbdQosRespQosFlags = "DENY_LIMIT"
	V0041OpenapiSlurmdbdQosRespQosFlagsENFORCEUSAGETHRESHOLD V0041OpenapiSlurmdbdQosRespQosFlags = "ENFORCE_USAGE_THRESHOLD"
	V0041OpenapiSlurmdbdQosRespQosFlagsNODECAY               V0041OpenapiSlurmdbdQosRespQosFlags = "NO_DECAY"
	V0041OpenapiSlurmdbdQosRespQosFlagsNORESERVE             V0041OpenapiSlurmdbdQosRespQosFlags = "NO_RESERVE"
	V0041OpenapiSlurmdbdQosRespQosFlagsNOTSET                V0041OpenapiSlurmdbdQosRespQosFlags = "NOT_SET"
	V0041OpenapiSlurmdbdQosRespQosFlagsOVERRIDEPARTITIONQOS  V0041OpenapiSlurmdbdQosRespQosFlags = "OVERRIDE_PARTITION_QOS"
	V0041OpenapiSlurmdbdQosRespQosFlagsPARTITIONMAXIMUMNODE  V0041OpenapiSlurmdbdQosRespQosFlags = "PARTITION_MAXIMUM_NODE"
	V0041OpenapiSlurmdbdQosRespQosFlagsPARTITIONMINIMUMNODE  V0041OpenapiSlurmdbdQosRespQosFlags = "PARTITION_MINIMUM_NODE"
	V0041OpenapiSlurmdbdQosRespQosFlagsPARTITIONTIMELIMIT    V0041OpenapiSlurmdbdQosRespQosFlags = "PARTITION_TIME_LIMIT"
	V0041OpenapiSlurmdbdQosRespQosFlagsRELATIVE              V0041OpenapiSlurmdbdQosRespQosFlags = "RELATIVE"
	V0041OpenapiSlurmdbdQosRespQosFlagsREMOVE                V0041OpenapiSlurmdbdQosRespQosFlags = "REMOVE"
	V0041OpenapiSlurmdbdQosRespQosFlagsREQUIREDRESERVATION   V0041OpenapiSlurmdbdQosRespQosFlags = "REQUIRED_RESERVATION"
	V0041OpenapiSlurmdbdQosRespQosFlagsUSAGEFACTORSAFE       V0041OpenapiSlurmdbdQosRespQosFlags = "USAGE_FACTOR_SAFE"
)

// Defines values for V0041OpenapiSlurmdbdQosRespQosPreemptMode.
const (
	V0041OpenapiSlurmdbdQosRespQosPreemptModeCANCEL   V0041OpenapiSlurmdbdQosRespQosPreemptMode = "CANCEL"
	V0041OpenapiSlurmdbdQosRespQosPreemptModeDISABLED V0041OpenapiSlurmdbdQosRespQosPreemptMode = "DISABLED"
	V0041OpenapiSlurmdbdQosRespQosPreemptModeGANG     V0041OpenapiSlurmdbdQosRespQosPreemptMode = "GANG"
	V0041OpenapiSlurmdbdQosRespQosPreemptModeREQUEUE  V0041OpenapiSlurmdbdQosRespQosPreemptMode = "REQUEUE"
	V0041OpenapiSlurmdbdQosRespQosPreemptModeSUSPEND  V0041OpenapiSlurmdbdQosRespQosPreemptMode = "SUSPEND"
)

// Defines values for V0041OpenapiUsersRespUsersAdministratorLevel.
const (
	V0041OpenapiUsersRespUsersAdministratorLevelAdministrator V0041OpenapiUsersRespUsersAdministratorLevel = "Administrator"
	V0041OpenapiUsersRespUsersAdministratorLevelNone          V0041OpenapiUsersRespUsersAdministratorLevel = "None"
	V0041OpenapiUsersRespUsersAdministratorLevelNotSet        V0041OpenapiUsersRespUsersAdministratorLevel = "Not Set"
	V0041OpenapiUsersRespUsersAdministratorLevelOperator      V0041OpenapiUsersRespUsersAdministratorLevel = "Operator"
)

// Defines values for V0041OpenapiUsersRespUsersFlags.
const (
	V0041OpenapiUsersRespUsersFlagsDELETED V0041OpenapiUsersRespUsersFlags = "DELETED"
	V0041OpenapiUsersRespUsersFlagsNONE    V0041OpenapiUsersRespUsersFlags = "NONE"
)

// Defines values for V0041OpenapiUsersRespUsersWckeysFlags.
const (
	V0041OpenapiUsersRespUsersWckeysFlagsDELETED V0041OpenapiUsersRespUsersWckeysFlags = "DELETED"
)

// Defines values for V0041OpenapiWckeyRespWckeysFlags.
const (
	V0041OpenapiWckeyRespWckeysFlagsDELETED V0041OpenapiWckeyRespWckeysFlags = "DELETED"
)

// Defines values for V0041UpdateNodeMsgState.
const (
	V0041UpdateNodeMsgStateALLOCATED       V0041UpdateNodeMsgState = "ALLOCATED"
	V0041UpdateNodeMsgStateCLOUD           V0041UpdateNodeMsgState = "CLOUD"
	V0041UpdateNodeMsgStateCOMPLETING      V0041UpdateNodeMsgState = "COMPLETING"
	V0041UpdateNodeMsgStateDOWN            V0041UpdateNodeMsgState = "DOWN"
	V0041UpdateNodeMsgStateDRAIN           V0041UpdateNodeMsgState = "DRAIN"
	V0041UpdateNodeMsgStateDYNAMICFUTURE   V0041UpdateNodeMsgState = "DYNAMIC_FUTURE"
	V0041UpdateNodeMsgStateDYNAMICNORM     V0041UpdateNodeMsgState = "DYNAMIC_NORM"
	V0041UpdateNodeMsgStateERROR           V0041UpdateNodeMsgState = "ERROR"
	V0041UpdateNodeMsgStateFAIL            V0041UpdateNodeMsgState = "FAIL"
	V0041UpdateNodeMsgStateFUTURE          V0041UpdateNodeMsgState = "FUTURE"
	V0041UpdateNodeMsgStateIDLE            V0041UpdateNodeMsgState = "IDLE"
	V0041UpdateNodeMsgStateINVALID         V0041UpdateNodeMsgState = "INVALID"
	V0041UpdateNodeMsgStateINVALIDREG      V0041UpdateNodeMsgState = "INVALID_REG"
	V0041UpdateNodeMsgStateMAINTENANCE     V0041UpdateNodeMsgState = "MAINTENANCE"
	V0041UpdateNodeMsgStateMIXED           V0041UpdateNodeMsgState = "MIXED"
	V0041UpdateNodeMsgStateNOTRESPONDING   V0041UpdateNodeMsgState = "NOT_RESPONDING"
	V0041UpdateNodeMsgStatePLANNED         V0041UpdateNodeMsgState = "PLANNED"
	V0041UpdateNodeMsgStatePOWERDOWN       V0041UpdateNodeMsgState = "POWER_DOWN"
	V0041UpdateNodeMsgStatePOWERDRAIN      V0041UpdateNodeMsgState = "POWER_DRAIN"
	V0041UpdateNodeMsgStatePOWEREDDOWN     V0041UpdateNodeMsgState = "POWERED_DOWN"
	V0041UpdateNodeMsgStatePOWERINGDOWN    V0041UpdateNodeMsgState = "POWERING_DOWN"
	V0041UpdateNodeMsgStatePOWERINGUP      V0041UpdateNodeMsgState = "POWERING_UP"
	V0041UpdateNodeMsgStatePOWERUP         V0041UpdateNodeMsgState = "POWER_UP"
	V0041UpdateNodeMsgStateREBOOTCANCELED  V0041UpdateNodeMsgState = "REBOOT_CANCELED"
	V0041UpdateNodeMsgStateREBOOTISSUED    V0041UpdateNodeMsgState = "REBOOT_ISSUED"
	V0041UpdateNodeMsgStateREBOOTREQUESTED V0041UpdateNodeMsgState = "REBOOT_REQUESTED"
	V0041UpdateNodeMsgStateRESERVED        V0041UpdateNodeMsgState = "RESERVED"
	V0041UpdateNodeMsgStateRESUME          V0041UpdateNodeMsgState = "RESUME"
	V0041UpdateNodeMsgStateUNDRAIN         V0041UpdateNodeMsgState = "UNDRAIN"
	V0041UpdateNodeMsgStateUNKNOWN         V0041UpdateNodeMsgState = "UNKNOWN"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDLDMAP            SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDLDMASK           SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDLDRANK           SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDMAP              SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDMASK             SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDNONE             SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDRANK             SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDTOCORES          SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlagsVERBOSE                 SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlagsWILDDAYOFMONTH SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags = "WILD_DAY_OF_MONTH"
	SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlagsWILDDAYOFWEEK  SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags = "WILD_DAY_OF_WEEK"
	SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlagsWILDHOUR       SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags = "WILD_HOUR"
	SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlagsWILDMINUTE     SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags = "WILD_MINUTE"
	SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlagsWILDMONTH      SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobExclusive.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobExclusiveFalse SlurmV0041PostJobAllocateJSONBodyHetjobExclusive = "false"
	SlurmV0041PostJobAllocateJSONBodyHetjobExclusiveMcs   SlurmV0041PostJobAllocateJSONBodyHetjobExclusive = "mcs"
	SlurmV0041PostJobAllocateJSONBodyHetjobExclusiveTopo  SlurmV0041PostJobAllocateJSONBodyHetjobExclusive = "topo"
	SlurmV0041PostJobAllocateJSONBodyHetjobExclusiveTrue  SlurmV0041PostJobAllocateJSONBodyHetjobExclusive = "true"
	SlurmV0041PostJobAllocateJSONBodyHetjobExclusiveUser  SlurmV0041PostJobAllocateJSONBodyHetjobExclusive = "user"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsACCRUECOUNTCLEARED       SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "ACCRUE_COUNT_CLEARED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsBACKFILLATTEMPTED        SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "BACKFILL_ATTEMPTED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsCRONJOB                  SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "CRON_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsDEPENDENT                SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "DEPENDENT"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsEXACTCPUCOUNTREQUESTED   SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "EXACT_CPU_COUNT_REQUESTED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsEXACTMEMORYREQUESTED     SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "EXACT_MEMORY_REQUESTED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsEXACTTASKCOUNTREQUESTED  SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "EXACT_TASK_COUNT_REQUESTED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsGRESBINDINGDISABLED      SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "GRES_BINDING_DISABLED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsGRESBINDINGENFORCED      SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "GRES_BINDING_ENFORCED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsHASSTATEDIRECTORY        SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "HAS_STATE_DIRECTORY"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsHETEROGENEOUSJOB         SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "HETEROGENEOUS_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsJOBACCRUETIMERESET       SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "JOB_ACCRUE_TIME_RESET"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsJOBKILLHURRY             SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "JOB_KILL_HURRY"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsJOBWASRUNNING            SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "JOB_WAS_RUNNING"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsKILLINVALIDDEPENDENCY    SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsMAGNETIC                 SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "MAGNETIC"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsNOKILLINVALIDDEPENDENCY  SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "NO_KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsPARTITIONASSIGNED        SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "PARTITION_ASSIGNED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsPREFERMINIMUMNODECOUNT   SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "PREFER_MINIMUM_NODE_COUNT"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsSCHEDULINGATTEMPTED      SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "SCHEDULING_ATTEMPTED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsSENDJOBENVIRONMENT       SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "SEND_JOB_ENVIRONMENT"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsSIBLINGCLUSTERUPDATEONLY SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsSKIPTRESSTRINGACCOUNTING SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsSPREADJOB                SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "SPREAD_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsSTEPMGRENABLED           SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "STEPMGR_ENABLED"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsTESTINGBACKFILL          SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "TESTING_BACKFILL"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsTESTINGWHOLENODEBACKFILL SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "TESTING_WHOLE_NODE_BACKFILL"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsTESTNOWONLY              SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "TEST_NOW_ONLY"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsTOPPRIORITYJOB           SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "TOP_PRIORITY_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsUSINGDEFAULTACCOUNT      SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "USING_DEFAULT_ACCOUNT"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsUSINGDEFAULTPARTITION    SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "USING_DEFAULT_PARTITION"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsUSINGDEFAULTQOS          SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "USING_DEFAULT_QOS"
	SlurmV0041PostJobAllocateJSONBodyHetjobFlagsUSINGDEFAULTWCKEY        SlurmV0041PostJobAllocateJSONBodyHetjobFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsARRAYTASK         SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "ARRAY_TASK"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsBATCHJOB          SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "BATCH_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsCRONJOBS          SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "CRON_JOBS"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsFEDERATIONREQUEUE SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsFULLJOB           SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "FULL_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsFULLSTEPSONLY     SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsHURRY             SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "HURRY"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsNOSIBLINGJOBS     SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsOUTOFMEMORY       SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsRESERVATIONJOB    SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "RESERVATION_JOB"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsVERBOSE           SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "VERBOSE"
	SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlagsWARNINGSENT       SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobMailType.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeARRAYTASKS        SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "ARRAY_TASKS"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeBEGIN             SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "BEGIN"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeEND               SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "END"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeFAIL              SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "FAIL"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeINVALIDDEPENDENCY SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "INVALID_DEPENDENCY"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeREQUEUE           SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "REQUEUE"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeSTAGEOUT          SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "STAGE_OUT"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeTIME100           SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "TIME=100%"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeTIME50            SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "TIME=50%"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeTIME80            SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "TIME=80%"
	SlurmV0041PostJobAllocateJSONBodyHetjobMailTypeTIME90            SlurmV0041PostJobAllocateJSONBodyHetjobMailType = "TIME=90%"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeLOCAL   SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "LOCAL"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeMAP     SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "MAP"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeMASK    SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "MASK"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeNONE    SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "NONE"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypePREFER  SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "PREFER"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeRANK    SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "RANK"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeSORT    SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "SORT"
	SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingTypeVERBOSE SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobOpenMode.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobOpenModeAPPEND   SlurmV0041PostJobAllocateJSONBodyHetjobOpenMode = "APPEND"
	SlurmV0041PostJobAllocateJSONBodyHetjobOpenModeTRUNCATE SlurmV0041PostJobAllocateJSONBodyHetjobOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobProfile.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobProfileENERGY  SlurmV0041PostJobAllocateJSONBodyHetjobProfile = "ENERGY"
	SlurmV0041PostJobAllocateJSONBodyHetjobProfileLUSTRE  SlurmV0041PostJobAllocateJSONBodyHetjobProfile = "LUSTRE"
	SlurmV0041PostJobAllocateJSONBodyHetjobProfileNETWORK SlurmV0041PostJobAllocateJSONBodyHetjobProfile = "NETWORK"
	SlurmV0041PostJobAllocateJSONBodyHetjobProfileNONE    SlurmV0041PostJobAllocateJSONBodyHetjobProfile = "NONE"
	SlurmV0041PostJobAllocateJSONBodyHetjobProfileNOTSET  SlurmV0041PostJobAllocateJSONBodyHetjobProfile = "NOT_SET"
	SlurmV0041PostJobAllocateJSONBodyHetjobProfileTASK    SlurmV0041PostJobAllocateJSONBodyHetjobProfile = "TASK"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobShared.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobSharedMcs           SlurmV0041PostJobAllocateJSONBodyHetjobShared = "mcs"
	SlurmV0041PostJobAllocateJSONBodyHetjobSharedNone          SlurmV0041PostJobAllocateJSONBodyHetjobShared = "none"
	SlurmV0041PostJobAllocateJSONBodyHetjobSharedOversubscribe SlurmV0041PostJobAllocateJSONBodyHetjobShared = "oversubscribe"
	SlurmV0041PostJobAllocateJSONBodyHetjobSharedTopo          SlurmV0041PostJobAllocateJSONBodyHetjobShared = "topo"
	SlurmV0041PostJobAllocateJSONBodyHetjobSharedUser          SlurmV0041PostJobAllocateJSONBodyHetjobShared = "user"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyHetjobX11.
const (
	SlurmV0041PostJobAllocateJSONBodyHetjobX11BATCHNODE       SlurmV0041PostJobAllocateJSONBodyHetjobX11 = "BATCH_NODE"
	SlurmV0041PostJobAllocateJSONBodyHetjobX11FIRSTNODE       SlurmV0041PostJobAllocateJSONBodyHetjobX11 = "FIRST_NODE"
	SlurmV0041PostJobAllocateJSONBodyHetjobX11FORWARDALLNODES SlurmV0041PostJobAllocateJSONBodyHetjobX11 = "FORWARD_ALL_NODES"
	SlurmV0041PostJobAllocateJSONBodyHetjobX11LASTNODE        SlurmV0041PostJobAllocateJSONBodyHetjobX11 = "LAST_NODE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDLDMAP            SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDLDMASK           SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDLDRANK           SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDMAP              SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDMASK             SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDNONE             SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDRANK             SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDTOCORES          SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlagsVERBOSE                 SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyJobCrontabFlagsWILDDAYOFMONTH SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags = "WILD_DAY_OF_MONTH"
	SlurmV0041PostJobAllocateJSONBodyJobCrontabFlagsWILDDAYOFWEEK  SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags = "WILD_DAY_OF_WEEK"
	SlurmV0041PostJobAllocateJSONBodyJobCrontabFlagsWILDHOUR       SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags = "WILD_HOUR"
	SlurmV0041PostJobAllocateJSONBodyJobCrontabFlagsWILDMINUTE     SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags = "WILD_MINUTE"
	SlurmV0041PostJobAllocateJSONBodyJobCrontabFlagsWILDMONTH      SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobExclusive.
const (
	SlurmV0041PostJobAllocateJSONBodyJobExclusiveFalse SlurmV0041PostJobAllocateJSONBodyJobExclusive = "false"
	SlurmV0041PostJobAllocateJSONBodyJobExclusiveMcs   SlurmV0041PostJobAllocateJSONBodyJobExclusive = "mcs"
	SlurmV0041PostJobAllocateJSONBodyJobExclusiveTopo  SlurmV0041PostJobAllocateJSONBodyJobExclusive = "topo"
	SlurmV0041PostJobAllocateJSONBodyJobExclusiveTrue  SlurmV0041PostJobAllocateJSONBodyJobExclusive = "true"
	SlurmV0041PostJobAllocateJSONBodyJobExclusiveUser  SlurmV0041PostJobAllocateJSONBodyJobExclusive = "user"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyJobFlagsACCRUECOUNTCLEARED       SlurmV0041PostJobAllocateJSONBodyJobFlags = "ACCRUE_COUNT_CLEARED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsBACKFILLATTEMPTED        SlurmV0041PostJobAllocateJSONBodyJobFlags = "BACKFILL_ATTEMPTED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsCRONJOB                  SlurmV0041PostJobAllocateJSONBodyJobFlags = "CRON_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsDEPENDENT                SlurmV0041PostJobAllocateJSONBodyJobFlags = "DEPENDENT"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsEXACTCPUCOUNTREQUESTED   SlurmV0041PostJobAllocateJSONBodyJobFlags = "EXACT_CPU_COUNT_REQUESTED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsEXACTMEMORYREQUESTED     SlurmV0041PostJobAllocateJSONBodyJobFlags = "EXACT_MEMORY_REQUESTED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsEXACTTASKCOUNTREQUESTED  SlurmV0041PostJobAllocateJSONBodyJobFlags = "EXACT_TASK_COUNT_REQUESTED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsGRESBINDINGDISABLED      SlurmV0041PostJobAllocateJSONBodyJobFlags = "GRES_BINDING_DISABLED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsGRESBINDINGENFORCED      SlurmV0041PostJobAllocateJSONBodyJobFlags = "GRES_BINDING_ENFORCED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsHASSTATEDIRECTORY        SlurmV0041PostJobAllocateJSONBodyJobFlags = "HAS_STATE_DIRECTORY"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsHETEROGENEOUSJOB         SlurmV0041PostJobAllocateJSONBodyJobFlags = "HETEROGENEOUS_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsJOBACCRUETIMERESET       SlurmV0041PostJobAllocateJSONBodyJobFlags = "JOB_ACCRUE_TIME_RESET"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsJOBKILLHURRY             SlurmV0041PostJobAllocateJSONBodyJobFlags = "JOB_KILL_HURRY"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsJOBWASRUNNING            SlurmV0041PostJobAllocateJSONBodyJobFlags = "JOB_WAS_RUNNING"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsKILLINVALIDDEPENDENCY    SlurmV0041PostJobAllocateJSONBodyJobFlags = "KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsMAGNETIC                 SlurmV0041PostJobAllocateJSONBodyJobFlags = "MAGNETIC"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsNOKILLINVALIDDEPENDENCY  SlurmV0041PostJobAllocateJSONBodyJobFlags = "NO_KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsPARTITIONASSIGNED        SlurmV0041PostJobAllocateJSONBodyJobFlags = "PARTITION_ASSIGNED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsPREFERMINIMUMNODECOUNT   SlurmV0041PostJobAllocateJSONBodyJobFlags = "PREFER_MINIMUM_NODE_COUNT"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsSCHEDULINGATTEMPTED      SlurmV0041PostJobAllocateJSONBodyJobFlags = "SCHEDULING_ATTEMPTED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsSENDJOBENVIRONMENT       SlurmV0041PostJobAllocateJSONBodyJobFlags = "SEND_JOB_ENVIRONMENT"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsSIBLINGCLUSTERUPDATEONLY SlurmV0041PostJobAllocateJSONBodyJobFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsSKIPTRESSTRINGACCOUNTING SlurmV0041PostJobAllocateJSONBodyJobFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsSPREADJOB                SlurmV0041PostJobAllocateJSONBodyJobFlags = "SPREAD_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsSTEPMGRENABLED           SlurmV0041PostJobAllocateJSONBodyJobFlags = "STEPMGR_ENABLED"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsTESTINGBACKFILL          SlurmV0041PostJobAllocateJSONBodyJobFlags = "TESTING_BACKFILL"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsTESTINGWHOLENODEBACKFILL SlurmV0041PostJobAllocateJSONBodyJobFlags = "TESTING_WHOLE_NODE_BACKFILL"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsTESTNOWONLY              SlurmV0041PostJobAllocateJSONBodyJobFlags = "TEST_NOW_ONLY"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsTOPPRIORITYJOB           SlurmV0041PostJobAllocateJSONBodyJobFlags = "TOP_PRIORITY_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsUSINGDEFAULTACCOUNT      SlurmV0041PostJobAllocateJSONBodyJobFlags = "USING_DEFAULT_ACCOUNT"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsUSINGDEFAULTPARTITION    SlurmV0041PostJobAllocateJSONBodyJobFlags = "USING_DEFAULT_PARTITION"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsUSINGDEFAULTQOS          SlurmV0041PostJobAllocateJSONBodyJobFlags = "USING_DEFAULT_QOS"
	SlurmV0041PostJobAllocateJSONBodyJobFlagsUSINGDEFAULTWCKEY        SlurmV0041PostJobAllocateJSONBodyJobFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags.
const (
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsARRAYTASK         SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "ARRAY_TASK"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsBATCHJOB          SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "BATCH_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsCRONJOBS          SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "CRON_JOBS"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsFEDERATIONREQUEUE SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsFULLJOB           SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "FULL_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsFULLSTEPSONLY     SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsHURRY             SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "HURRY"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsNOSIBLINGJOBS     SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsOUTOFMEMORY       SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsRESERVATIONJOB    SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "RESERVATION_JOB"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsVERBOSE           SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "VERBOSE"
	SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlagsWARNINGSENT       SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobMailType.
const (
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeARRAYTASKS        SlurmV0041PostJobAllocateJSONBodyJobMailType = "ARRAY_TASKS"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeBEGIN             SlurmV0041PostJobAllocateJSONBodyJobMailType = "BEGIN"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeEND               SlurmV0041PostJobAllocateJSONBodyJobMailType = "END"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeFAIL              SlurmV0041PostJobAllocateJSONBodyJobMailType = "FAIL"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeINVALIDDEPENDENCY SlurmV0041PostJobAllocateJSONBodyJobMailType = "INVALID_DEPENDENCY"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeREQUEUE           SlurmV0041PostJobAllocateJSONBodyJobMailType = "REQUEUE"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeSTAGEOUT          SlurmV0041PostJobAllocateJSONBodyJobMailType = "STAGE_OUT"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeTIME100           SlurmV0041PostJobAllocateJSONBodyJobMailType = "TIME=100%"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeTIME50            SlurmV0041PostJobAllocateJSONBodyJobMailType = "TIME=50%"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeTIME80            SlurmV0041PostJobAllocateJSONBodyJobMailType = "TIME=80%"
	SlurmV0041PostJobAllocateJSONBodyJobMailTypeTIME90            SlurmV0041PostJobAllocateJSONBodyJobMailType = "TIME=90%"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType.
const (
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeLOCAL   SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "LOCAL"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeMAP     SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "MAP"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeMASK    SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "MASK"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeNONE    SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "NONE"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypePREFER  SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "PREFER"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeRANK    SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "RANK"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeSORT    SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "SORT"
	SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingTypeVERBOSE SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobOpenMode.
const (
	SlurmV0041PostJobAllocateJSONBodyJobOpenModeAPPEND   SlurmV0041PostJobAllocateJSONBodyJobOpenMode = "APPEND"
	SlurmV0041PostJobAllocateJSONBodyJobOpenModeTRUNCATE SlurmV0041PostJobAllocateJSONBodyJobOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobProfile.
const (
	SlurmV0041PostJobAllocateJSONBodyJobProfileENERGY  SlurmV0041PostJobAllocateJSONBodyJobProfile = "ENERGY"
	SlurmV0041PostJobAllocateJSONBodyJobProfileLUSTRE  SlurmV0041PostJobAllocateJSONBodyJobProfile = "LUSTRE"
	SlurmV0041PostJobAllocateJSONBodyJobProfileNETWORK SlurmV0041PostJobAllocateJSONBodyJobProfile = "NETWORK"
	SlurmV0041PostJobAllocateJSONBodyJobProfileNONE    SlurmV0041PostJobAllocateJSONBodyJobProfile = "NONE"
	SlurmV0041PostJobAllocateJSONBodyJobProfileNOTSET  SlurmV0041PostJobAllocateJSONBodyJobProfile = "NOT_SET"
	SlurmV0041PostJobAllocateJSONBodyJobProfileTASK    SlurmV0041PostJobAllocateJSONBodyJobProfile = "TASK"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobShared.
const (
	SlurmV0041PostJobAllocateJSONBodyJobSharedMcs           SlurmV0041PostJobAllocateJSONBodyJobShared = "mcs"
	SlurmV0041PostJobAllocateJSONBodyJobSharedNone          SlurmV0041PostJobAllocateJSONBodyJobShared = "none"
	SlurmV0041PostJobAllocateJSONBodyJobSharedOversubscribe SlurmV0041PostJobAllocateJSONBodyJobShared = "oversubscribe"
	SlurmV0041PostJobAllocateJSONBodyJobSharedTopo          SlurmV0041PostJobAllocateJSONBodyJobShared = "topo"
	SlurmV0041PostJobAllocateJSONBodyJobSharedUser          SlurmV0041PostJobAllocateJSONBodyJobShared = "user"
)

// Defines values for SlurmV0041PostJobAllocateJSONBodyJobX11.
const (
	SlurmV0041PostJobAllocateJSONBodyJobX11BATCHNODE       SlurmV0041PostJobAllocateJSONBodyJobX11 = "BATCH_NODE"
	SlurmV0041PostJobAllocateJSONBodyJobX11FIRSTNODE       SlurmV0041PostJobAllocateJSONBodyJobX11 = "FIRST_NODE"
	SlurmV0041PostJobAllocateJSONBodyJobX11FORWARDALLNODES SlurmV0041PostJobAllocateJSONBodyJobX11 = "FORWARD_ALL_NODES"
	SlurmV0041PostJobAllocateJSONBodyJobX11LASTNODE        SlurmV0041PostJobAllocateJSONBodyJobX11 = "LAST_NODE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDLDMAP            SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDLDMASK           SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDLDRANK           SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDMAP              SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDMASK             SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDNONE             SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDRANK             SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDTOCORES          SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlagsVERBOSE                 SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobCrontabFlagsWILDDAYOFMONTH SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags = "WILD_DAY_OF_MONTH"
	SlurmV0041PostJobSubmitJSONBodyJobCrontabFlagsWILDDAYOFWEEK  SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags = "WILD_DAY_OF_WEEK"
	SlurmV0041PostJobSubmitJSONBodyJobCrontabFlagsWILDHOUR       SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags = "WILD_HOUR"
	SlurmV0041PostJobSubmitJSONBodyJobCrontabFlagsWILDMINUTE     SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags = "WILD_MINUTE"
	SlurmV0041PostJobSubmitJSONBodyJobCrontabFlagsWILDMONTH      SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobExclusive.
const (
	SlurmV0041PostJobSubmitJSONBodyJobExclusiveFalse SlurmV0041PostJobSubmitJSONBodyJobExclusive = "false"
	SlurmV0041PostJobSubmitJSONBodyJobExclusiveMcs   SlurmV0041PostJobSubmitJSONBodyJobExclusive = "mcs"
	SlurmV0041PostJobSubmitJSONBodyJobExclusiveTopo  SlurmV0041PostJobSubmitJSONBodyJobExclusive = "topo"
	SlurmV0041PostJobSubmitJSONBodyJobExclusiveTrue  SlurmV0041PostJobSubmitJSONBodyJobExclusive = "true"
	SlurmV0041PostJobSubmitJSONBodyJobExclusiveUser  SlurmV0041PostJobSubmitJSONBodyJobExclusive = "user"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobFlagsACCRUECOUNTCLEARED       SlurmV0041PostJobSubmitJSONBodyJobFlags = "ACCRUE_COUNT_CLEARED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsBACKFILLATTEMPTED        SlurmV0041PostJobSubmitJSONBodyJobFlags = "BACKFILL_ATTEMPTED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsCRONJOB                  SlurmV0041PostJobSubmitJSONBodyJobFlags = "CRON_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsDEPENDENT                SlurmV0041PostJobSubmitJSONBodyJobFlags = "DEPENDENT"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsEXACTCPUCOUNTREQUESTED   SlurmV0041PostJobSubmitJSONBodyJobFlags = "EXACT_CPU_COUNT_REQUESTED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsEXACTMEMORYREQUESTED     SlurmV0041PostJobSubmitJSONBodyJobFlags = "EXACT_MEMORY_REQUESTED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsEXACTTASKCOUNTREQUESTED  SlurmV0041PostJobSubmitJSONBodyJobFlags = "EXACT_TASK_COUNT_REQUESTED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsGRESBINDINGDISABLED      SlurmV0041PostJobSubmitJSONBodyJobFlags = "GRES_BINDING_DISABLED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsGRESBINDINGENFORCED      SlurmV0041PostJobSubmitJSONBodyJobFlags = "GRES_BINDING_ENFORCED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsHASSTATEDIRECTORY        SlurmV0041PostJobSubmitJSONBodyJobFlags = "HAS_STATE_DIRECTORY"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsHETEROGENEOUSJOB         SlurmV0041PostJobSubmitJSONBodyJobFlags = "HETEROGENEOUS_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsJOBACCRUETIMERESET       SlurmV0041PostJobSubmitJSONBodyJobFlags = "JOB_ACCRUE_TIME_RESET"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsJOBKILLHURRY             SlurmV0041PostJobSubmitJSONBodyJobFlags = "JOB_KILL_HURRY"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsJOBWASRUNNING            SlurmV0041PostJobSubmitJSONBodyJobFlags = "JOB_WAS_RUNNING"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsKILLINVALIDDEPENDENCY    SlurmV0041PostJobSubmitJSONBodyJobFlags = "KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsMAGNETIC                 SlurmV0041PostJobSubmitJSONBodyJobFlags = "MAGNETIC"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsNOKILLINVALIDDEPENDENCY  SlurmV0041PostJobSubmitJSONBodyJobFlags = "NO_KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsPARTITIONASSIGNED        SlurmV0041PostJobSubmitJSONBodyJobFlags = "PARTITION_ASSIGNED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsPREFERMINIMUMNODECOUNT   SlurmV0041PostJobSubmitJSONBodyJobFlags = "PREFER_MINIMUM_NODE_COUNT"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsSCHEDULINGATTEMPTED      SlurmV0041PostJobSubmitJSONBodyJobFlags = "SCHEDULING_ATTEMPTED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsSENDJOBENVIRONMENT       SlurmV0041PostJobSubmitJSONBodyJobFlags = "SEND_JOB_ENVIRONMENT"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsSIBLINGCLUSTERUPDATEONLY SlurmV0041PostJobSubmitJSONBodyJobFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsSKIPTRESSTRINGACCOUNTING SlurmV0041PostJobSubmitJSONBodyJobFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsSPREADJOB                SlurmV0041PostJobSubmitJSONBodyJobFlags = "SPREAD_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsSTEPMGRENABLED           SlurmV0041PostJobSubmitJSONBodyJobFlags = "STEPMGR_ENABLED"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsTESTINGBACKFILL          SlurmV0041PostJobSubmitJSONBodyJobFlags = "TESTING_BACKFILL"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsTESTINGWHOLENODEBACKFILL SlurmV0041PostJobSubmitJSONBodyJobFlags = "TESTING_WHOLE_NODE_BACKFILL"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsTESTNOWONLY              SlurmV0041PostJobSubmitJSONBodyJobFlags = "TEST_NOW_ONLY"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsTOPPRIORITYJOB           SlurmV0041PostJobSubmitJSONBodyJobFlags = "TOP_PRIORITY_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsUSINGDEFAULTACCOUNT      SlurmV0041PostJobSubmitJSONBodyJobFlags = "USING_DEFAULT_ACCOUNT"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsUSINGDEFAULTPARTITION    SlurmV0041PostJobSubmitJSONBodyJobFlags = "USING_DEFAULT_PARTITION"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsUSINGDEFAULTQOS          SlurmV0041PostJobSubmitJSONBodyJobFlags = "USING_DEFAULT_QOS"
	SlurmV0041PostJobSubmitJSONBodyJobFlagsUSINGDEFAULTWCKEY        SlurmV0041PostJobSubmitJSONBodyJobFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsARRAYTASK         SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "ARRAY_TASK"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsBATCHJOB          SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "BATCH_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsCRONJOBS          SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "CRON_JOBS"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsFEDERATIONREQUEUE SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsFULLJOB           SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "FULL_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsFULLSTEPSONLY     SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsHURRY             SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "HURRY"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsNOSIBLINGJOBS     SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsOUTOFMEMORY       SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsRESERVATIONJOB    SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "RESERVATION_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsVERBOSE           SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "VERBOSE"
	SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlagsWARNINGSENT       SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobMailType.
const (
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeARRAYTASKS        SlurmV0041PostJobSubmitJSONBodyJobMailType = "ARRAY_TASKS"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeBEGIN             SlurmV0041PostJobSubmitJSONBodyJobMailType = "BEGIN"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeEND               SlurmV0041PostJobSubmitJSONBodyJobMailType = "END"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeFAIL              SlurmV0041PostJobSubmitJSONBodyJobMailType = "FAIL"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeINVALIDDEPENDENCY SlurmV0041PostJobSubmitJSONBodyJobMailType = "INVALID_DEPENDENCY"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeREQUEUE           SlurmV0041PostJobSubmitJSONBodyJobMailType = "REQUEUE"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeSTAGEOUT          SlurmV0041PostJobSubmitJSONBodyJobMailType = "STAGE_OUT"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeTIME100           SlurmV0041PostJobSubmitJSONBodyJobMailType = "TIME=100%"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeTIME50            SlurmV0041PostJobSubmitJSONBodyJobMailType = "TIME=50%"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeTIME80            SlurmV0041PostJobSubmitJSONBodyJobMailType = "TIME=80%"
	SlurmV0041PostJobSubmitJSONBodyJobMailTypeTIME90            SlurmV0041PostJobSubmitJSONBodyJobMailType = "TIME=90%"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType.
const (
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeLOCAL   SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "LOCAL"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeMAP     SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "MAP"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeMASK    SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "MASK"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeNONE    SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "NONE"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypePREFER  SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "PREFER"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeRANK    SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "RANK"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeSORT    SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "SORT"
	SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingTypeVERBOSE SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobOpenMode.
const (
	SlurmV0041PostJobSubmitJSONBodyJobOpenModeAPPEND   SlurmV0041PostJobSubmitJSONBodyJobOpenMode = "APPEND"
	SlurmV0041PostJobSubmitJSONBodyJobOpenModeTRUNCATE SlurmV0041PostJobSubmitJSONBodyJobOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobProfile.
const (
	SlurmV0041PostJobSubmitJSONBodyJobProfileENERGY  SlurmV0041PostJobSubmitJSONBodyJobProfile = "ENERGY"
	SlurmV0041PostJobSubmitJSONBodyJobProfileLUSTRE  SlurmV0041PostJobSubmitJSONBodyJobProfile = "LUSTRE"
	SlurmV0041PostJobSubmitJSONBodyJobProfileNETWORK SlurmV0041PostJobSubmitJSONBodyJobProfile = "NETWORK"
	SlurmV0041PostJobSubmitJSONBodyJobProfileNONE    SlurmV0041PostJobSubmitJSONBodyJobProfile = "NONE"
	SlurmV0041PostJobSubmitJSONBodyJobProfileNOTSET  SlurmV0041PostJobSubmitJSONBodyJobProfile = "NOT_SET"
	SlurmV0041PostJobSubmitJSONBodyJobProfileTASK    SlurmV0041PostJobSubmitJSONBodyJobProfile = "TASK"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobShared.
const (
	SlurmV0041PostJobSubmitJSONBodyJobSharedMcs           SlurmV0041PostJobSubmitJSONBodyJobShared = "mcs"
	SlurmV0041PostJobSubmitJSONBodyJobSharedNone          SlurmV0041PostJobSubmitJSONBodyJobShared = "none"
	SlurmV0041PostJobSubmitJSONBodyJobSharedOversubscribe SlurmV0041PostJobSubmitJSONBodyJobShared = "oversubscribe"
	SlurmV0041PostJobSubmitJSONBodyJobSharedTopo          SlurmV0041PostJobSubmitJSONBodyJobShared = "topo"
	SlurmV0041PostJobSubmitJSONBodyJobSharedUser          SlurmV0041PostJobSubmitJSONBodyJobShared = "user"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobX11.
const (
	SlurmV0041PostJobSubmitJSONBodyJobX11BATCHNODE       SlurmV0041PostJobSubmitJSONBodyJobX11 = "BATCH_NODE"
	SlurmV0041PostJobSubmitJSONBodyJobX11FIRSTNODE       SlurmV0041PostJobSubmitJSONBodyJobX11 = "FIRST_NODE"
	SlurmV0041PostJobSubmitJSONBodyJobX11FORWARDALLNODES SlurmV0041PostJobSubmitJSONBodyJobX11 = "FORWARD_ALL_NODES"
	SlurmV0041PostJobSubmitJSONBodyJobX11LASTNODE        SlurmV0041PostJobSubmitJSONBodyJobX11 = "LAST_NODE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDLDMAP            SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDLDMASK           SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDLDRANK           SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDMAP              SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDMASK             SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDNONE             SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDRANK             SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDTOCORES          SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlagsVERBOSE                 SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlagsWILDDAYOFMONTH SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags = "WILD_DAY_OF_MONTH"
	SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlagsWILDDAYOFWEEK  SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags = "WILD_DAY_OF_WEEK"
	SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlagsWILDHOUR       SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags = "WILD_HOUR"
	SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlagsWILDMINUTE     SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags = "WILD_MINUTE"
	SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlagsWILDMONTH      SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsExclusive.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsExclusiveFalse SlurmV0041PostJobSubmitJSONBodyJobsExclusive = "false"
	SlurmV0041PostJobSubmitJSONBodyJobsExclusiveMcs   SlurmV0041PostJobSubmitJSONBodyJobsExclusive = "mcs"
	SlurmV0041PostJobSubmitJSONBodyJobsExclusiveTopo  SlurmV0041PostJobSubmitJSONBodyJobsExclusive = "topo"
	SlurmV0041PostJobSubmitJSONBodyJobsExclusiveTrue  SlurmV0041PostJobSubmitJSONBodyJobsExclusive = "true"
	SlurmV0041PostJobSubmitJSONBodyJobsExclusiveUser  SlurmV0041PostJobSubmitJSONBodyJobsExclusive = "user"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsACCRUECOUNTCLEARED       SlurmV0041PostJobSubmitJSONBodyJobsFlags = "ACCRUE_COUNT_CLEARED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsBACKFILLATTEMPTED        SlurmV0041PostJobSubmitJSONBodyJobsFlags = "BACKFILL_ATTEMPTED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsCRONJOB                  SlurmV0041PostJobSubmitJSONBodyJobsFlags = "CRON_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsDEPENDENT                SlurmV0041PostJobSubmitJSONBodyJobsFlags = "DEPENDENT"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsEXACTCPUCOUNTREQUESTED   SlurmV0041PostJobSubmitJSONBodyJobsFlags = "EXACT_CPU_COUNT_REQUESTED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsEXACTMEMORYREQUESTED     SlurmV0041PostJobSubmitJSONBodyJobsFlags = "EXACT_MEMORY_REQUESTED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsEXACTTASKCOUNTREQUESTED  SlurmV0041PostJobSubmitJSONBodyJobsFlags = "EXACT_TASK_COUNT_REQUESTED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsGRESBINDINGDISABLED      SlurmV0041PostJobSubmitJSONBodyJobsFlags = "GRES_BINDING_DISABLED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsGRESBINDINGENFORCED      SlurmV0041PostJobSubmitJSONBodyJobsFlags = "GRES_BINDING_ENFORCED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsHASSTATEDIRECTORY        SlurmV0041PostJobSubmitJSONBodyJobsFlags = "HAS_STATE_DIRECTORY"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsHETEROGENEOUSJOB         SlurmV0041PostJobSubmitJSONBodyJobsFlags = "HETEROGENEOUS_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsJOBACCRUETIMERESET       SlurmV0041PostJobSubmitJSONBodyJobsFlags = "JOB_ACCRUE_TIME_RESET"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsJOBKILLHURRY             SlurmV0041PostJobSubmitJSONBodyJobsFlags = "JOB_KILL_HURRY"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsJOBWASRUNNING            SlurmV0041PostJobSubmitJSONBodyJobsFlags = "JOB_WAS_RUNNING"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsKILLINVALIDDEPENDENCY    SlurmV0041PostJobSubmitJSONBodyJobsFlags = "KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsMAGNETIC                 SlurmV0041PostJobSubmitJSONBodyJobsFlags = "MAGNETIC"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsNOKILLINVALIDDEPENDENCY  SlurmV0041PostJobSubmitJSONBodyJobsFlags = "NO_KILL_INVALID_DEPENDENCY"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsPARTITIONASSIGNED        SlurmV0041PostJobSubmitJSONBodyJobsFlags = "PARTITION_ASSIGNED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsPREFERMINIMUMNODECOUNT   SlurmV0041PostJobSubmitJSONBodyJobsFlags = "PREFER_MINIMUM_NODE_COUNT"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsSCHEDULINGATTEMPTED      SlurmV0041PostJobSubmitJSONBodyJobsFlags = "SCHEDULING_ATTEMPTED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsSENDJOBENVIRONMENT       SlurmV0041PostJobSubmitJSONBodyJobsFlags = "SEND_JOB_ENVIRONMENT"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsSIBLINGCLUSTERUPDATEONLY SlurmV0041PostJobSubmitJSONBodyJobsFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsSKIPTRESSTRINGACCOUNTING SlurmV0041PostJobSubmitJSONBodyJobsFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsSPREADJOB                SlurmV0041PostJobSubmitJSONBodyJobsFlags = "SPREAD_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsSTEPMGRENABLED           SlurmV0041PostJobSubmitJSONBodyJobsFlags = "STEPMGR_ENABLED"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsTESTINGBACKFILL          SlurmV0041PostJobSubmitJSONBodyJobsFlags = "TESTING_BACKFILL"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsTESTINGWHOLENODEBACKFILL SlurmV0041PostJobSubmitJSONBodyJobsFlags = "TESTING_WHOLE_NODE_BACKFILL"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsTESTNOWONLY              SlurmV0041PostJobSubmitJSONBodyJobsFlags = "TEST_NOW_ONLY"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsTOPPRIORITYJOB           SlurmV0041PostJobSubmitJSONBodyJobsFlags = "TOP_PRIORITY_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsUSINGDEFAULTACCOUNT      SlurmV0041PostJobSubmitJSONBodyJobsFlags = "USING_DEFAULT_ACCOUNT"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsUSINGDEFAULTPARTITION    SlurmV0041PostJobSubmitJSONBodyJobsFlags = "USING_DEFAULT_PARTITION"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsUSINGDEFAULTQOS          SlurmV0041PostJobSubmitJSONBodyJobsFlags = "USING_DEFAULT_QOS"
	SlurmV0041PostJobSubmitJSONBodyJobsFlagsUSINGDEFAULTWCKEY        SlurmV0041PostJobSubmitJSONBodyJobsFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsARRAYTASK         SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "ARRAY_TASK"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsBATCHJOB          SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "BATCH_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsCRONJOBS          SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "CRON_JOBS"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsFEDERATIONREQUEUE SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsFULLJOB           SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "FULL_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsFULLSTEPSONLY     SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsHURRY             SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "HURRY"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsNOSIBLINGJOBS     SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsOUTOFMEMORY       SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsRESERVATIONJOB    SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "RESERVATION_JOB"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsVERBOSE           SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "VERBOSE"
	SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlagsWARNINGSENT       SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsMailType.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeARRAYTASKS        SlurmV0041PostJobSubmitJSONBodyJobsMailType = "ARRAY_TASKS"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeBEGIN             SlurmV0041PostJobSubmitJSONBodyJobsMailType = "BEGIN"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeEND               SlurmV0041PostJobSubmitJSONBodyJobsMailType = "END"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeFAIL              SlurmV0041PostJobSubmitJSONBodyJobsMailType = "FAIL"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeINVALIDDEPENDENCY SlurmV0041PostJobSubmitJSONBodyJobsMailType = "INVALID_DEPENDENCY"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeREQUEUE           SlurmV0041PostJobSubmitJSONBodyJobsMailType = "REQUEUE"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeSTAGEOUT          SlurmV0041PostJobSubmitJSONBodyJobsMailType = "STAGE_OUT"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeTIME100           SlurmV0041PostJobSubmitJSONBodyJobsMailType = "TIME=100%"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeTIME50            SlurmV0041PostJobSubmitJSONBodyJobsMailType = "TIME=50%"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeTIME80            SlurmV0041PostJobSubmitJSONBodyJobsMailType = "TIME=80%"
	SlurmV0041PostJobSubmitJSONBodyJobsMailTypeTIME90            SlurmV0041PostJobSubmitJSONBodyJobsMailType = "TIME=90%"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeLOCAL   SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "LOCAL"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeMAP     SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "MAP"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeMASK    SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "MASK"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeNONE    SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "NONE"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypePREFER  SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "PREFER"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeRANK    SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "RANK"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeSORT    SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "SORT"
	SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingTypeVERBOSE SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsOpenMode.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsOpenModeAPPEND   SlurmV0041PostJobSubmitJSONBodyJobsOpenMode = "APPEND"
	SlurmV0041PostJobSubmitJSONBodyJobsOpenModeTRUNCATE SlurmV0041PostJobSubmitJSONBodyJobsOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsProfile.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsProfileENERGY  SlurmV0041PostJobSubmitJSONBodyJobsProfile = "ENERGY"
	SlurmV0041PostJobSubmitJSONBodyJobsProfileLUSTRE  SlurmV0041PostJobSubmitJSONBodyJobsProfile = "LUSTRE"
	SlurmV0041PostJobSubmitJSONBodyJobsProfileNETWORK SlurmV0041PostJobSubmitJSONBodyJobsProfile = "NETWORK"
	SlurmV0041PostJobSubmitJSONBodyJobsProfileNONE    SlurmV0041PostJobSubmitJSONBodyJobsProfile = "NONE"
	SlurmV0041PostJobSubmitJSONBodyJobsProfileNOTSET  SlurmV0041PostJobSubmitJSONBodyJobsProfile = "NOT_SET"
	SlurmV0041PostJobSubmitJSONBodyJobsProfileTASK    SlurmV0041PostJobSubmitJSONBodyJobsProfile = "TASK"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsShared.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsSharedMcs           SlurmV0041PostJobSubmitJSONBodyJobsShared = "mcs"
	SlurmV0041PostJobSubmitJSONBodyJobsSharedNone          SlurmV0041PostJobSubmitJSONBodyJobsShared = "none"
	SlurmV0041PostJobSubmitJSONBodyJobsSharedOversubscribe SlurmV0041PostJobSubmitJSONBodyJobsShared = "oversubscribe"
	SlurmV0041PostJobSubmitJSONBodyJobsSharedTopo          SlurmV0041PostJobSubmitJSONBodyJobsShared = "topo"
	SlurmV0041PostJobSubmitJSONBodyJobsSharedUser          SlurmV0041PostJobSubmitJSONBodyJobsShared = "user"
)

// Defines values for SlurmV0041PostJobSubmitJSONBodyJobsX11.
const (
	SlurmV0041PostJobSubmitJSONBodyJobsX11BATCHNODE       SlurmV0041PostJobSubmitJSONBodyJobsX11 = "BATCH_NODE"
	SlurmV0041PostJobSubmitJSONBodyJobsX11FIRSTNODE       SlurmV0041PostJobSubmitJSONBodyJobsX11 = "FIRST_NODE"
	SlurmV0041PostJobSubmitJSONBodyJobsX11FORWARDALLNODES SlurmV0041PostJobSubmitJSONBodyJobsX11 = "FORWARD_ALL_NODES"
	SlurmV0041PostJobSubmitJSONBodyJobsX11LASTNODE        SlurmV0041PostJobSubmitJSONBodyJobsX11 = "LAST_NODE"
)

// Defines values for SlurmV0041DeleteJobParamsFlags.
const (
	SlurmV0041DeleteJobParamsFlagsARRAYTASK         SlurmV0041DeleteJobParamsFlags = "ARRAY_TASK"
	SlurmV0041DeleteJobParamsFlagsBATCHJOB          SlurmV0041DeleteJobParamsFlags = "BATCH_JOB"
	SlurmV0041DeleteJobParamsFlagsCRONJOBS          SlurmV0041DeleteJobParamsFlags = "CRON_JOBS"
	SlurmV0041DeleteJobParamsFlagsFEDERATIONREQUEUE SlurmV0041DeleteJobParamsFlags = "FEDERATION_REQUEUE"
	SlurmV0041DeleteJobParamsFlagsFULLJOB           SlurmV0041DeleteJobParamsFlags = "FULL_JOB"
	SlurmV0041DeleteJobParamsFlagsFULLSTEPSONLY     SlurmV0041DeleteJobParamsFlags = "FULL_STEPS_ONLY"
	SlurmV0041DeleteJobParamsFlagsHURRY             SlurmV0041DeleteJobParamsFlags = "HURRY"
	SlurmV0041DeleteJobParamsFlagsNOSIBLINGJOBS     SlurmV0041DeleteJobParamsFlags = "NO_SIBLING_JOBS"
	SlurmV0041DeleteJobParamsFlagsOUTOFMEMORY       SlurmV0041DeleteJobParamsFlags = "OUT_OF_MEMORY"
	SlurmV0041DeleteJobParamsFlagsRESERVATIONJOB    SlurmV0041DeleteJobParamsFlags = "RESERVATION_JOB"
	SlurmV0041DeleteJobParamsFlagsVERBOSE           SlurmV0041DeleteJobParamsFlags = "VERBOSE"
	SlurmV0041DeleteJobParamsFlagsWARNINGSENT       SlurmV0041DeleteJobParamsFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041GetJobParamsFlags.
const (
	SlurmV0041GetJobParamsFlagsALL        SlurmV0041GetJobParamsFlags = "ALL"
	SlurmV0041GetJobParamsFlagsDETAIL     SlurmV0041GetJobParamsFlags = "DETAIL"
	SlurmV0041GetJobParamsFlagsFEDERATION SlurmV0041GetJobParamsFlags = "FEDERATION"
	SlurmV0041GetJobParamsFlagsFUTURE     SlurmV0041GetJobParamsFlags = "FUTURE"
	SlurmV0041GetJobParamsFlagsLOCAL      SlurmV0041GetJobParamsFlags = "LOCAL"
	SlurmV0041GetJobParamsFlagsMIXED      SlurmV0041GetJobParamsFlags = "MIXED"
	SlurmV0041GetJobParamsFlagsSIBLING    SlurmV0041GetJobParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041PostJobJSONBodyCpuBindingFlags.
const (
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDLDMAP            SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_LDMAP"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDLDMASK           SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_LDMASK"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDLDRANK           SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_LDRANK"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDMAP              SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_MAP"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDMASK             SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_MASK"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDNONE             SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_NONE"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDONETHREADPERCORE SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDRANK             SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_RANK"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDTOCORES          SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_TO_CORES"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDTOLDOMS          SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDTOSOCKETS        SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsCPUBINDTOTHREADS        SlurmV0041PostJobJSONBodyCpuBindingFlags = "CPU_BIND_TO_THREADS"
	SlurmV0041PostJobJSONBodyCpuBindingFlagsVERBOSE                 SlurmV0041PostJobJSONBodyCpuBindingFlags = "VERBOSE"
)

// Defines values for SlurmV0041PostJobJSONBodyCrontabFlags.
const (
	WILDDAYOFMONTH SlurmV0041PostJobJSONBodyCrontabFlags = "WILD_DAY_OF_MONTH"
	WILDDAYOFWEEK  SlurmV0041PostJobJSONBodyCrontabFlags = "WILD_DAY_OF_WEEK"
	WILDHOUR       SlurmV0041PostJobJSONBodyCrontabFlags = "WILD_HOUR"
	WILDMINUTE     SlurmV0041PostJobJSONBodyCrontabFlags = "WILD_MINUTE"
	WILDMONTH      SlurmV0041PostJobJSONBodyCrontabFlags = "WILD_MONTH"
)

// Defines values for SlurmV0041PostJobJSONBodyExclusive.
const (
	SlurmV0041PostJobJSONBodyExclusiveFalse SlurmV0041PostJobJSONBodyExclusive = "false"
	SlurmV0041PostJobJSONBodyExclusiveMcs   SlurmV0041PostJobJSONBodyExclusive = "mcs"
	SlurmV0041PostJobJSONBodyExclusiveTopo  SlurmV0041PostJobJSONBodyExclusive = "topo"
	SlurmV0041PostJobJSONBodyExclusiveTrue  SlurmV0041PostJobJSONBodyExclusive = "true"
	SlurmV0041PostJobJSONBodyExclusiveUser  SlurmV0041PostJobJSONBodyExclusive = "user"
)

// Defines values for SlurmV0041PostJobJSONBodyFlags.
const (
	ACCRUECOUNTCLEARED       SlurmV0041PostJobJSONBodyFlags = "ACCRUE_COUNT_CLEARED"
	BACKFILLATTEMPTED        SlurmV0041PostJobJSONBodyFlags = "BACKFILL_ATTEMPTED"
	CRONJOB                  SlurmV0041PostJobJSONBodyFlags = "CRON_JOB"
	DEPENDENT                SlurmV0041PostJobJSONBodyFlags = "DEPENDENT"
	EXACTCPUCOUNTREQUESTED   SlurmV0041PostJobJSONBodyFlags = "EXACT_CPU_COUNT_REQUESTED"
	EXACTMEMORYREQUESTED     SlurmV0041PostJobJSONBodyFlags = "EXACT_MEMORY_REQUESTED"
	EXACTTASKCOUNTREQUESTED  SlurmV0041PostJobJSONBodyFlags = "EXACT_TASK_COUNT_REQUESTED"
	GRESBINDINGDISABLED      SlurmV0041PostJobJSONBodyFlags = "GRES_BINDING_DISABLED"
	GRESBINDINGENFORCED      SlurmV0041PostJobJSONBodyFlags = "GRES_BINDING_ENFORCED"
	HASSTATEDIRECTORY        SlurmV0041PostJobJSONBodyFlags = "HAS_STATE_DIRECTORY"
	HETEROGENEOUSJOB         SlurmV0041PostJobJSONBodyFlags = "HETEROGENEOUS_JOB"
	JOBACCRUETIMERESET       SlurmV0041PostJobJSONBodyFlags = "JOB_ACCRUE_TIME_RESET"
	JOBKILLHURRY             SlurmV0041PostJobJSONBodyFlags = "JOB_KILL_HURRY"
	JOBWASRUNNING            SlurmV0041PostJobJSONBodyFlags = "JOB_WAS_RUNNING"
	KILLINVALIDDEPENDENCY    SlurmV0041PostJobJSONBodyFlags = "KILL_INVALID_DEPENDENCY"
	MAGNETIC                 SlurmV0041PostJobJSONBodyFlags = "MAGNETIC"
	NOKILLINVALIDDEPENDENCY  SlurmV0041PostJobJSONBodyFlags = "NO_KILL_INVALID_DEPENDENCY"
	PARTITIONASSIGNED        SlurmV0041PostJobJSONBodyFlags = "PARTITION_ASSIGNED"
	PREFERMINIMUMNODECOUNT   SlurmV0041PostJobJSONBodyFlags = "PREFER_MINIMUM_NODE_COUNT"
	SCHEDULINGATTEMPTED      SlurmV0041PostJobJSONBodyFlags = "SCHEDULING_ATTEMPTED"
	SENDJOBENVIRONMENT       SlurmV0041PostJobJSONBodyFlags = "SEND_JOB_ENVIRONMENT"
	SIBLINGCLUSTERUPDATEONLY SlurmV0041PostJobJSONBodyFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	SKIPTRESSTRINGACCOUNTING SlurmV0041PostJobJSONBodyFlags = "SKIP_TRES_STRING_ACCOUNTING"
	SPREADJOB                SlurmV0041PostJobJSONBodyFlags = "SPREAD_JOB"
	STEPMGRENABLED           SlurmV0041PostJobJSONBodyFlags = "STEPMGR_ENABLED"
	TESTINGBACKFILL          SlurmV0041PostJobJSONBodyFlags = "TESTING_BACKFILL"
	TESTINGWHOLENODEBACKFILL SlurmV0041PostJobJSONBodyFlags = "TESTING_WHOLE_NODE_BACKFILL"
	TESTNOWONLY              SlurmV0041PostJobJSONBodyFlags = "TEST_NOW_ONLY"
	TOPPRIORITYJOB           SlurmV0041PostJobJSONBodyFlags = "TOP_PRIORITY_JOB"
	USINGDEFAULTACCOUNT      SlurmV0041PostJobJSONBodyFlags = "USING_DEFAULT_ACCOUNT"
	USINGDEFAULTPARTITION    SlurmV0041PostJobJSONBodyFlags = "USING_DEFAULT_PARTITION"
	USINGDEFAULTQOS          SlurmV0041PostJobJSONBodyFlags = "USING_DEFAULT_QOS"
	USINGDEFAULTWCKEY        SlurmV0041PostJobJSONBodyFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for SlurmV0041PostJobJSONBodyKillWarningFlags.
const (
	SlurmV0041PostJobJSONBodyKillWarningFlagsARRAYTASK         SlurmV0041PostJobJSONBodyKillWarningFlags = "ARRAY_TASK"
	SlurmV0041PostJobJSONBodyKillWarningFlagsBATCHJOB          SlurmV0041PostJobJSONBodyKillWarningFlags = "BATCH_JOB"
	SlurmV0041PostJobJSONBodyKillWarningFlagsCRONJOBS          SlurmV0041PostJobJSONBodyKillWarningFlags = "CRON_JOBS"
	SlurmV0041PostJobJSONBodyKillWarningFlagsFEDERATIONREQUEUE SlurmV0041PostJobJSONBodyKillWarningFlags = "FEDERATION_REQUEUE"
	SlurmV0041PostJobJSONBodyKillWarningFlagsFULLJOB           SlurmV0041PostJobJSONBodyKillWarningFlags = "FULL_JOB"
	SlurmV0041PostJobJSONBodyKillWarningFlagsFULLSTEPSONLY     SlurmV0041PostJobJSONBodyKillWarningFlags = "FULL_STEPS_ONLY"
	SlurmV0041PostJobJSONBodyKillWarningFlagsHURRY             SlurmV0041PostJobJSONBodyKillWarningFlags = "HURRY"
	SlurmV0041PostJobJSONBodyKillWarningFlagsNOSIBLINGJOBS     SlurmV0041PostJobJSONBodyKillWarningFlags = "NO_SIBLING_JOBS"
	SlurmV0041PostJobJSONBodyKillWarningFlagsOUTOFMEMORY       SlurmV0041PostJobJSONBodyKillWarningFlags = "OUT_OF_MEMORY"
	SlurmV0041PostJobJSONBodyKillWarningFlagsRESERVATIONJOB    SlurmV0041PostJobJSONBodyKillWarningFlags = "RESERVATION_JOB"
	SlurmV0041PostJobJSONBodyKillWarningFlagsVERBOSE           SlurmV0041PostJobJSONBodyKillWarningFlags = "VERBOSE"
	SlurmV0041PostJobJSONBodyKillWarningFlagsWARNINGSENT       SlurmV0041PostJobJSONBodyKillWarningFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041PostJobJSONBodyMailType.
const (
	SlurmV0041PostJobJSONBodyMailTypeARRAYTASKS        SlurmV0041PostJobJSONBodyMailType = "ARRAY_TASKS"
	SlurmV0041PostJobJSONBodyMailTypeBEGIN             SlurmV0041PostJobJSONBodyMailType = "BEGIN"
	SlurmV0041PostJobJSONBodyMailTypeEND               SlurmV0041PostJobJSONBodyMailType = "END"
	SlurmV0041PostJobJSONBodyMailTypeFAIL              SlurmV0041PostJobJSONBodyMailType = "FAIL"
	SlurmV0041PostJobJSONBodyMailTypeINVALIDDEPENDENCY SlurmV0041PostJobJSONBodyMailType = "INVALID_DEPENDENCY"
	SlurmV0041PostJobJSONBodyMailTypeREQUEUE           SlurmV0041PostJobJSONBodyMailType = "REQUEUE"
	SlurmV0041PostJobJSONBodyMailTypeSTAGEOUT          SlurmV0041PostJobJSONBodyMailType = "STAGE_OUT"
	SlurmV0041PostJobJSONBodyMailTypeTIME100           SlurmV0041PostJobJSONBodyMailType = "TIME=100%"
	SlurmV0041PostJobJSONBodyMailTypeTIME50            SlurmV0041PostJobJSONBodyMailType = "TIME=50%"
	SlurmV0041PostJobJSONBodyMailTypeTIME80            SlurmV0041PostJobJSONBodyMailType = "TIME=80%"
	SlurmV0041PostJobJSONBodyMailTypeTIME90            SlurmV0041PostJobJSONBodyMailType = "TIME=90%"
)

// Defines values for SlurmV0041PostJobJSONBodyMemoryBindingType.
const (
	SlurmV0041PostJobJSONBodyMemoryBindingTypeLOCAL   SlurmV0041PostJobJSONBodyMemoryBindingType = "LOCAL"
	SlurmV0041PostJobJSONBodyMemoryBindingTypeMAP     SlurmV0041PostJobJSONBodyMemoryBindingType = "MAP"
	SlurmV0041PostJobJSONBodyMemoryBindingTypeMASK    SlurmV0041PostJobJSONBodyMemoryBindingType = "MASK"
	SlurmV0041PostJobJSONBodyMemoryBindingTypeNONE    SlurmV0041PostJobJSONBodyMemoryBindingType = "NONE"
	SlurmV0041PostJobJSONBodyMemoryBindingTypePREFER  SlurmV0041PostJobJSONBodyMemoryBindingType = "PREFER"
	SlurmV0041PostJobJSONBodyMemoryBindingTypeRANK    SlurmV0041PostJobJSONBodyMemoryBindingType = "RANK"
	SlurmV0041PostJobJSONBodyMemoryBindingTypeSORT    SlurmV0041PostJobJSONBodyMemoryBindingType = "SORT"
	SlurmV0041PostJobJSONBodyMemoryBindingTypeVERBOSE SlurmV0041PostJobJSONBodyMemoryBindingType = "VERBOSE"
)

// Defines values for SlurmV0041PostJobJSONBodyOpenMode.
const (
	APPEND   SlurmV0041PostJobJSONBodyOpenMode = "APPEND"
	TRUNCATE SlurmV0041PostJobJSONBodyOpenMode = "TRUNCATE"
)

// Defines values for SlurmV0041PostJobJSONBodyProfile.
const (
	ENERGY  SlurmV0041PostJobJSONBodyProfile = "ENERGY"
	LUSTRE  SlurmV0041PostJobJSONBodyProfile = "LUSTRE"
	NETWORK SlurmV0041PostJobJSONBodyProfile = "NETWORK"
	NONE    SlurmV0041PostJobJSONBodyProfile = "NONE"
	NOTSET  SlurmV0041PostJobJSONBodyProfile = "NOT_SET"
	TASK    SlurmV0041PostJobJSONBodyProfile = "TASK"
)

// Defines values for SlurmV0041PostJobJSONBodyShared.
const (
	SlurmV0041PostJobJSONBodySharedMcs           SlurmV0041PostJobJSONBodyShared = "mcs"
	SlurmV0041PostJobJSONBodySharedNone          SlurmV0041PostJobJSONBodyShared = "none"
	SlurmV0041PostJobJSONBodySharedOversubscribe SlurmV0041PostJobJSONBodyShared = "oversubscribe"
	SlurmV0041PostJobJSONBodySharedTopo          SlurmV0041PostJobJSONBodyShared = "topo"
	SlurmV0041PostJobJSONBodySharedUser          SlurmV0041PostJobJSONBodyShared = "user"
)

// Defines values for SlurmV0041PostJobJSONBodyX11.
const (
	BATCHNODE       SlurmV0041PostJobJSONBodyX11 = "BATCH_NODE"
	FIRSTNODE       SlurmV0041PostJobJSONBodyX11 = "FIRST_NODE"
	FORWARDALLNODES SlurmV0041PostJobJSONBodyX11 = "FORWARD_ALL_NODES"
	LASTNODE        SlurmV0041PostJobJSONBodyX11 = "LAST_NODE"
)

// Defines values for SlurmV0041DeleteJobsJSONBodyFlags.
const (
	SlurmV0041DeleteJobsJSONBodyFlagsARRAYTASK         SlurmV0041DeleteJobsJSONBodyFlags = "ARRAY_TASK"
	SlurmV0041DeleteJobsJSONBodyFlagsBATCHJOB          SlurmV0041DeleteJobsJSONBodyFlags = "BATCH_JOB"
	SlurmV0041DeleteJobsJSONBodyFlagsCRONJOBS          SlurmV0041DeleteJobsJSONBodyFlags = "CRON_JOBS"
	SlurmV0041DeleteJobsJSONBodyFlagsFEDERATIONREQUEUE SlurmV0041DeleteJobsJSONBodyFlags = "FEDERATION_REQUEUE"
	SlurmV0041DeleteJobsJSONBodyFlagsFULLJOB           SlurmV0041DeleteJobsJSONBodyFlags = "FULL_JOB"
	SlurmV0041DeleteJobsJSONBodyFlagsFULLSTEPSONLY     SlurmV0041DeleteJobsJSONBodyFlags = "FULL_STEPS_ONLY"
	SlurmV0041DeleteJobsJSONBodyFlagsHURRY             SlurmV0041DeleteJobsJSONBodyFlags = "HURRY"
	SlurmV0041DeleteJobsJSONBodyFlagsNOSIBLINGJOBS     SlurmV0041DeleteJobsJSONBodyFlags = "NO_SIBLING_JOBS"
	SlurmV0041DeleteJobsJSONBodyFlagsOUTOFMEMORY       SlurmV0041DeleteJobsJSONBodyFlags = "OUT_OF_MEMORY"
	SlurmV0041DeleteJobsJSONBodyFlagsRESERVATIONJOB    SlurmV0041DeleteJobsJSONBodyFlags = "RESERVATION_JOB"
	SlurmV0041DeleteJobsJSONBodyFlagsVERBOSE           SlurmV0041DeleteJobsJSONBodyFlags = "VERBOSE"
	SlurmV0041DeleteJobsJSONBodyFlagsWARNINGSENT       SlurmV0041DeleteJobsJSONBodyFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041DeleteJobsJSONBodyJobState.
const (
	SlurmV0041DeleteJobsJSONBodyJobStateBOOTFAIL     SlurmV0041DeleteJobsJSONBodyJobState = "BOOT_FAIL"
	SlurmV0041DeleteJobsJSONBodyJobStateCANCELLED    SlurmV0041DeleteJobsJSONBodyJobState = "CANCELLED"
	SlurmV0041DeleteJobsJSONBodyJobStateCOMPLETED    SlurmV0041DeleteJobsJSONBodyJobState = "COMPLETED"
	SlurmV0041DeleteJobsJSONBodyJobStateCOMPLETING   SlurmV0041DeleteJobsJSONBodyJobState = "COMPLETING"
	SlurmV0041DeleteJobsJSONBodyJobStateCONFIGURING  SlurmV0041DeleteJobsJSONBodyJobState = "CONFIGURING"
	SlurmV0041DeleteJobsJSONBodyJobStateDEADLINE     SlurmV0041DeleteJobsJSONBodyJobState = "DEADLINE"
	SlurmV0041DeleteJobsJSONBodyJobStateFAILED       SlurmV0041DeleteJobsJSONBodyJobState = "FAILED"
	SlurmV0041DeleteJobsJSONBodyJobStateLAUNCHFAILED SlurmV0041DeleteJobsJSONBodyJobState = "LAUNCH_FAILED"
	SlurmV0041DeleteJobsJSONBodyJobStateNODEFAIL     SlurmV0041DeleteJobsJSONBodyJobState = "NODE_FAIL"
	SlurmV0041DeleteJobsJSONBodyJobStateOUTOFMEMORY  SlurmV0041DeleteJobsJSONBodyJobState = "OUT_OF_MEMORY"
	SlurmV0041DeleteJobsJSONBodyJobStatePENDING      SlurmV0041DeleteJobsJSONBodyJobState = "PENDING"
	SlurmV0041DeleteJobsJSONBodyJobStatePOWERUPNODE  SlurmV0041DeleteJobsJSONBodyJobState = "POWER_UP_NODE"
	SlurmV0041DeleteJobsJSONBodyJobStatePREEMPTED    SlurmV0041DeleteJobsJSONBodyJobState = "PREEMPTED"
	SlurmV0041DeleteJobsJSONBodyJobStateRECONFIGFAIL SlurmV0041DeleteJobsJSONBodyJobState = "RECONFIG_FAIL"
	SlurmV0041DeleteJobsJSONBodyJobStateREQUEUED     SlurmV0041DeleteJobsJSONBodyJobState = "REQUEUED"
	SlurmV0041DeleteJobsJSONBodyJobStateREQUEUEFED   SlurmV0041DeleteJobsJSONBodyJobState = "REQUEUE_FED"
	SlurmV0041DeleteJobsJSONBodyJobStateREQUEUEHOLD  SlurmV0041DeleteJobsJSONBodyJobState = "REQUEUE_HOLD"
	SlurmV0041DeleteJobsJSONBodyJobStateRESIZING     SlurmV0041DeleteJobsJSONBodyJobState = "RESIZING"
	SlurmV0041DeleteJobsJSONBodyJobStateRESVDELHOLD  SlurmV0041DeleteJobsJSONBodyJobState = "RESV_DEL_HOLD"
	SlurmV0041DeleteJobsJSONBodyJobStateREVOKED      SlurmV0041DeleteJobsJSONBodyJobState = "REVOKED"
	SlurmV0041DeleteJobsJSONBodyJobStateRUNNING      SlurmV0041DeleteJobsJSONBodyJobState = "RUNNING"
	SlurmV0041DeleteJobsJSONBodyJobStateSIGNALING    SlurmV0041DeleteJobsJSONBodyJobState = "SIGNALING"
	SlurmV0041DeleteJobsJSONBodyJobStateSPECIALEXIT  SlurmV0041DeleteJobsJSONBodyJobState = "SPECIAL_EXIT"
	SlurmV0041DeleteJobsJSONBodyJobStateSTAGEOUT     SlurmV0041DeleteJobsJSONBodyJobState = "STAGE_OUT"
	SlurmV0041DeleteJobsJSONBodyJobStateSTOPPED      SlurmV0041DeleteJobsJSONBodyJobState = "STOPPED"
	SlurmV0041DeleteJobsJSONBodyJobStateSUSPENDED    SlurmV0041DeleteJobsJSONBodyJobState = "SUSPENDED"
	SlurmV0041DeleteJobsJSONBodyJobStateTIMEOUT      SlurmV0041DeleteJobsJSONBodyJobState = "TIMEOUT"
)

// Defines values for SlurmV0041GetJobsParamsFlags.
const (
	SlurmV0041GetJobsParamsFlagsALL        SlurmV0041GetJobsParamsFlags = "ALL"
	SlurmV0041GetJobsParamsFlagsDETAIL     SlurmV0041GetJobsParamsFlags = "DETAIL"
	SlurmV0041GetJobsParamsFlagsFEDERATION SlurmV0041GetJobsParamsFlags = "FEDERATION"
	SlurmV0041GetJobsParamsFlagsFUTURE     SlurmV0041GetJobsParamsFlags = "FUTURE"
	SlurmV0041GetJobsParamsFlagsLOCAL      SlurmV0041GetJobsParamsFlags = "LOCAL"
	SlurmV0041GetJobsParamsFlagsMIXED      SlurmV0041GetJobsParamsFlags = "MIXED"
	SlurmV0041GetJobsParamsFlagsSIBLING    SlurmV0041GetJobsParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetNodeParamsFlags.
const (
	SlurmV0041GetNodeParamsFlagsALL        SlurmV0041GetNodeParamsFlags = "ALL"
	SlurmV0041GetNodeParamsFlagsDETAIL     SlurmV0041GetNodeParamsFlags = "DETAIL"
	SlurmV0041GetNodeParamsFlagsFEDERATION SlurmV0041GetNodeParamsFlags = "FEDERATION"
	SlurmV0041GetNodeParamsFlagsFUTURE     SlurmV0041GetNodeParamsFlags = "FUTURE"
	SlurmV0041GetNodeParamsFlagsLOCAL      SlurmV0041GetNodeParamsFlags = "LOCAL"
	SlurmV0041GetNodeParamsFlagsMIXED      SlurmV0041GetNodeParamsFlags = "MIXED"
	SlurmV0041GetNodeParamsFlagsSIBLING    SlurmV0041GetNodeParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetNodesParamsFlags.
const (
	SlurmV0041GetNodesParamsFlagsALL        SlurmV0041GetNodesParamsFlags = "ALL"
	SlurmV0041GetNodesParamsFlagsDETAIL     SlurmV0041GetNodesParamsFlags = "DETAIL"
	SlurmV0041GetNodesParamsFlagsFEDERATION SlurmV0041GetNodesParamsFlags = "FEDERATION"
	SlurmV0041GetNodesParamsFlagsFUTURE     SlurmV0041GetNodesParamsFlags = "FUTURE"
	SlurmV0041GetNodesParamsFlagsLOCAL      SlurmV0041GetNodesParamsFlags = "LOCAL"
	SlurmV0041GetNodesParamsFlagsMIXED      SlurmV0041GetNodesParamsFlags = "MIXED"
	SlurmV0041GetNodesParamsFlagsSIBLING    SlurmV0041GetNodesParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetPartitionParamsFlags.
const (
	SlurmV0041GetPartitionParamsFlagsALL        SlurmV0041GetPartitionParamsFlags = "ALL"
	SlurmV0041GetPartitionParamsFlagsDETAIL     SlurmV0041GetPartitionParamsFlags = "DETAIL"
	SlurmV0041GetPartitionParamsFlagsFEDERATION SlurmV0041GetPartitionParamsFlags = "FEDERATION"
	SlurmV0041GetPartitionParamsFlagsFUTURE     SlurmV0041GetPartitionParamsFlags = "FUTURE"
	SlurmV0041GetPartitionParamsFlagsLOCAL      SlurmV0041GetPartitionParamsFlags = "LOCAL"
	SlurmV0041GetPartitionParamsFlagsMIXED      SlurmV0041GetPartitionParamsFlags = "MIXED"
	SlurmV0041GetPartitionParamsFlagsSIBLING    SlurmV0041GetPartitionParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetPartitionsParamsFlags.
const (
	SlurmV0041GetPartitionsParamsFlagsALL        SlurmV0041GetPartitionsParamsFlags = "ALL"
	SlurmV0041GetPartitionsParamsFlagsDETAIL     SlurmV0041GetPartitionsParamsFlags = "DETAIL"
	SlurmV0041GetPartitionsParamsFlagsFEDERATION SlurmV0041GetPartitionsParamsFlags = "FEDERATION"
	SlurmV0041GetPartitionsParamsFlagsFUTURE     SlurmV0041GetPartitionsParamsFlags = "FUTURE"
	SlurmV0041GetPartitionsParamsFlagsLOCAL      SlurmV0041GetPartitionsParamsFlags = "LOCAL"
	SlurmV0041GetPartitionsParamsFlagsMIXED      SlurmV0041GetPartitionsParamsFlags = "MIXED"
	SlurmV0041GetPartitionsParamsFlagsSIBLING    SlurmV0041GetPartitionsParamsFlags = "SIBLING"
)

// Defines values for SlurmdbV0041DeleteClusterParamsClassification.
const (
	SlurmdbV0041DeleteClusterParamsClassificationCAPABILITY                          SlurmdbV0041DeleteClusterParamsClassification = "CAPABILITY"
	SlurmdbV0041DeleteClusterParamsClassificationCAPACITY                            SlurmdbV0041DeleteClusterParamsClassification = "CAPACITY"
	SlurmdbV0041DeleteClusterParamsClassificationCAPAPACITYBothCAPABILITYAndCAPACITY SlurmdbV0041DeleteClusterParamsClassification = "CAPAPACITY (both CAPABILITY and CAPACITY)"
	SlurmdbV0041DeleteClusterParamsClassificationUNCLASSIFIED                        SlurmdbV0041DeleteClusterParamsClassification = "UNCLASSIFIED"
)

// Defines values for SlurmdbV0041DeleteClusterParamsFlags.
const (
	SlurmdbV0041DeleteClusterParamsFlagsEXTERNAL       SlurmdbV0041DeleteClusterParamsFlags = "EXTERNAL"
	SlurmdbV0041DeleteClusterParamsFlagsFEDERATION     SlurmdbV0041DeleteClusterParamsFlags = "FEDERATION"
	SlurmdbV0041DeleteClusterParamsFlagsFRONTEND       SlurmdbV0041DeleteClusterParamsFlags = "FRONT_END"
	SlurmdbV0041DeleteClusterParamsFlagsMULTIPLESLURMD SlurmdbV0041DeleteClusterParamsFlags = "MULTIPLE_SLURMD"
	SlurmdbV0041DeleteClusterParamsFlagsREGISTERING    SlurmdbV0041DeleteClusterParamsFlags = "REGISTERING"
)

// Defines values for SlurmdbV0041GetClusterParamsClassification.
const (
	SlurmdbV0041GetClusterParamsClassificationCAPABILITY                          SlurmdbV0041GetClusterParamsClassification = "CAPABILITY"
	SlurmdbV0041GetClusterParamsClassificationCAPACITY                            SlurmdbV0041GetClusterParamsClassification = "CAPACITY"
	SlurmdbV0041GetClusterParamsClassificationCAPAPACITYBothCAPABILITYAndCAPACITY SlurmdbV0041GetClusterParamsClassification = "CAPAPACITY (both CAPABILITY and CAPACITY)"
	SlurmdbV0041GetClusterParamsClassificationUNCLASSIFIED                        SlurmdbV0041GetClusterParamsClassification = "UNCLASSIFIED"
)

// Defines values for SlurmdbV0041GetClusterParamsFlags.
const (
	SlurmdbV0041GetClusterParamsFlagsEXTERNAL       SlurmdbV0041GetClusterParamsFlags = "EXTERNAL"
	SlurmdbV0041GetClusterParamsFlagsFEDERATION     SlurmdbV0041GetClusterParamsFlags = "FEDERATION"
	SlurmdbV0041GetClusterParamsFlagsFRONTEND       SlurmdbV0041GetClusterParamsFlags = "FRONT_END"
	SlurmdbV0041GetClusterParamsFlagsMULTIPLESLURMD SlurmdbV0041GetClusterParamsFlags = "MULTIPLE_SLURMD"
	SlurmdbV0041GetClusterParamsFlagsREGISTERING    SlurmdbV0041GetClusterParamsFlags = "REGISTERING"
)

// Defines values for SlurmdbV0041GetQosParamsPreemptMode.
const (
	SlurmdbV0041GetQosParamsPreemptModeCANCEL   SlurmdbV0041GetQosParamsPreemptMode = "CANCEL"
	SlurmdbV0041GetQosParamsPreemptModeDISABLED SlurmdbV0041GetQosParamsPreemptMode = "DISABLED"
	SlurmdbV0041GetQosParamsPreemptModeGANG     SlurmdbV0041GetQosParamsPreemptMode = "GANG"
	SlurmdbV0041GetQosParamsPreemptModeREQUEUE  SlurmdbV0041GetQosParamsPreemptMode = "REQUEUE"
	SlurmdbV0041GetQosParamsPreemptModeSUSPEND  SlurmdbV0041GetQosParamsPreemptMode = "SUSPEND"
)

// Defines values for SlurmdbV0041PostQosParamsPreemptMode.
const (
	SlurmdbV0041PostQosParamsPreemptModeCANCEL   SlurmdbV0041PostQosParamsPreemptMode = "CANCEL"
	SlurmdbV0041PostQosParamsPreemptModeDISABLED SlurmdbV0041PostQosParamsPreemptMode = "DISABLED"
	SlurmdbV0041PostQosParamsPreemptModeGANG     SlurmdbV0041PostQosParamsPreemptMode = "GANG"
	SlurmdbV0041PostQosParamsPreemptModeREQUEUE  SlurmdbV0041PostQosParamsPreemptMode = "REQUEUE"
	SlurmdbV0041PostQosParamsPreemptModeSUSPEND  SlurmdbV0041PostQosParamsPreemptMode = "SUSPEND"
)

// Defines values for SlurmdbV0041GetUsersParamsAdminLevel.
const (
	SlurmdbV0041GetUsersParamsAdminLevelAdministrator SlurmdbV0041GetUsersParamsAdminLevel = "Administrator"
	SlurmdbV0041GetUsersParamsAdminLevelNone          SlurmdbV0041GetUsersParamsAdminLevel = "None"
	SlurmdbV0041GetUsersParamsAdminLevelNotSet        SlurmdbV0041GetUsersParamsAdminLevel = "Not Set"
	SlurmdbV0041GetUsersParamsAdminLevelOperator      SlurmdbV0041GetUsersParamsAdminLevel = "Operator"
)

// Defines values for SlurmdbV0041PostUsersAssociationParamsFlags.
const (
	SlurmdbV0041PostUsersAssociationParamsFlagsALL        SlurmdbV0041PostUsersAssociationParamsFlags = "ALL"
	SlurmdbV0041PostUsersAssociationParamsFlagsDETAIL     SlurmdbV0041PostUsersAssociationParamsFlags = "DETAIL"
	SlurmdbV0041PostUsersAssociationParamsFlagsFEDERATION SlurmdbV0041PostUsersAssociationParamsFlags = "FEDERATION"
	SlurmdbV0041PostUsersAssociationParamsFlagsFUTURE     SlurmdbV0041PostUsersAssociationParamsFlags = "FUTURE"
	SlurmdbV0041PostUsersAssociationParamsFlagsLOCAL      SlurmdbV0041PostUsersAssociationParamsFlags = "LOCAL"
	SlurmdbV0041PostUsersAssociationParamsFlagsMIXED      SlurmdbV0041PostUsersAssociationParamsFlags = "MIXED"
	SlurmdbV0041PostUsersAssociationParamsFlagsSIBLING    SlurmdbV0041PostUsersAssociationParamsFlags = "SIBLING"
)

// Defines values for SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel.
const (
	SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevelAdministrator SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel = "Administrator"
	SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevelNone          SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel = "None"
	SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevelNotSet        SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel = "Not Set"
	SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevelOperator      SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel = "Operator"
)

// V0041OpenapiAccountsResp defines model for v0.0.41_openapi_accounts_resp.
type V0041OpenapiAccountsResp struct {
	// Accounts accounts
	Accounts []struct {
		// Associations Associations involving this account (only populated if requested)
		Associations *[]struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"associations,omitempty"`

		// Coordinators List of users that are a coordinator of this account (only populated if requested)
		Coordinators *[]struct {
			// Direct Indicates whether the coordinator was directly assigned to this account
			Direct *bool `json:"direct,omitempty"`

			// Name User name
			Name string `json:"name"`
		} `json:"coordinators,omitempty"`

		// Description Arbitrary string describing the account
		Description string `json:"description"`

		// Flags Flags associated with the account
		Flags *[]V0041OpenapiAccountsRespAccountsFlags `json:"flags,omitempty"`

		// Name Account name
		Name string `json:"name"`

		// Organization Organization to which the account belongs
		Organization string `json:"organization"`
	} `json:"accounts"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiAccountsRespAccountsFlags defines model for V0041OpenapiAccountsResp.Accounts.Flags.
type V0041OpenapiAccountsRespAccountsFlags string

// V0041OpenapiAssocsRemovedResp defines model for v0.0.41_openapi_assocs_removed_resp.
type V0041OpenapiAssocsRemovedResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// RemovedAssociations removed_associations
	RemovedAssociations []string `json:"removed_associations"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiAssocsResp defines model for v0.0.41_openapi_assocs_resp.
type V0041OpenapiAssocsResp struct {
	// Associations associations
	Associations []struct {
		// Account Account
		Account *string `json:"account,omitempty"`

		// Accounting Accounting records containing related resource usage
		Accounting *[]struct {
			// TRES Trackable resources
			TRES *struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"TRES,omitempty"`
			Allocated *struct {
				// Seconds Number of cpu seconds allocated
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"allocated,omitempty"`

			// Id Association ID or Workload characterization key ID
			Id *int32 `json:"id,omitempty"`

			// Start When the record was started
			Start *int64 `json:"start,omitempty"`
		} `json:"accounting,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Comment Arbitrary comment
		Comment *string `json:"comment,omitempty"`
		Default *struct {
			// Qos Default QOS
			Qos *string `json:"qos,omitempty"`
		} `json:"default,omitempty"`

		// Flags Flags on the association
		Flags *[]V0041OpenapiAssocsRespAssociationsFlags `json:"flags,omitempty"`

		// Id Unique ID
		Id *int32 `json:"id,omitempty"`

		// IsDefault Is default association for user
		IsDefault *bool `json:"is_default,omitempty"`

		// Lineage Complete path up the hierarchy to the root association
		Lineage *string `json:"lineage,omitempty"`
		Max     *struct {
			Jobs *struct {
				// Accruing MaxJobsAccrue
				Accruing *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"accruing,omitempty"`

				// Active MaxJobs
				Active *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"active,omitempty"`
				Per *struct {
					// Accruing GrpJobsAccrue
					Accruing *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"accruing,omitempty"`

					// Count GrpJobs
					Count *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"count,omitempty"`

					// Submitted GrpSubmitJobs
					Submitted *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"submitted,omitempty"`

					// WallClock MaxWallDurationPerJob
					WallClock *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"wall_clock,omitempty"`
				} `json:"per,omitempty"`

				// Total MaxSubmitJobs
				Total *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"total,omitempty"`
			} `json:"jobs,omitempty"`
			Per *struct {
				Account *struct {
					// WallClock GrpWall
					WallClock *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"wall_clock,omitempty"`
				} `json:"account,omitempty"`
			} `json:"per,omitempty"`
			Tres *struct {
				Group *struct {
					// Active GrpTRESRunMins
					Active *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"active,omitempty"`

					// Minutes GrpTRESMins
					Minutes *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"minutes,omitempty"`
				} `json:"group,omitempty"`
				Minutes *struct {
					Per *struct {
						// Job MaxTRESMinsPerJob
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`
					} `json:"per,omitempty"`

					// Total MaxTRESMinsPerJob
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"minutes,omitempty"`
				Per *struct {
					// Job MaxTRESPerJob
					Job *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"job,omitempty"`

					// Node MaxTRESPerNode
					Node *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"node,omitempty"`
				} `json:"per,omitempty"`

				// Total GrpTRES
				Total *[]struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"total,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"max,omitempty"`
		Min *struct {
			// PriorityThreshold MinPrioThreshold
			PriorityThreshold *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority_threshold,omitempty"`
		} `json:"min,omitempty"`

		// ParentAccount Name of parent account
		ParentAccount *string `json:"parent_account,omitempty"`

		// Partition Partition name
		Partition *string `json:"partition,omitempty"`

		// Priority Association priority factor
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Qos List of available QOS names
		Qos *[]string `json:"qos,omitempty"`

		// SharesRaw Allocated shares used for fairshare calculation
		SharesRaw *int32 `json:"shares_raw,omitempty"`

		// User User name
		User string `json:"user"`
	} `json:"associations"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiAssocsRespAssociationsFlags defines model for V0041OpenapiAssocsResp.Associations.Flags.
type V0041OpenapiAssocsRespAssociationsFlags string

// V0041OpenapiClustersResp defines model for v0.0.41_openapi_clusters_resp.
type V0041OpenapiClustersResp struct {
	// Clusters clusters
	Clusters []struct {
		Associations *struct {
			// Root Root association information
			Root *struct {
				// Account Account
				Account *string `json:"account,omitempty"`

				// Cluster Cluster
				Cluster *string `json:"cluster,omitempty"`

				// Id Numeric association ID
				Id *int32 `json:"id,omitempty"`

				// Partition Partition
				Partition *string `json:"partition,omitempty"`

				// User User name
				User string `json:"user"`
			} `json:"root,omitempty"`
		} `json:"associations,omitempty"`
		Controller *struct {
			// Host ControlHost
			Host *string `json:"host,omitempty"`

			// Port ControlPort
			Port *int32 `json:"port,omitempty"`
		} `json:"controller,omitempty"`

		// Flags Flags
		Flags *[]V0041OpenapiClustersRespClustersFlags `json:"flags,omitempty"`

		// Name ClusterName
		Name *string `json:"name,omitempty"`

		// Nodes Node names
		Nodes *string `json:"nodes,omitempty"`

		// RpcVersion RPC version used in the cluster
		RpcVersion *int32 `json:"rpc_version,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		SelectPlugin *string `json:"select_plugin,omitempty"`

		// Tres Trackable resources
		Tres *[]struct {
			// Count TRES count (0 if listed generically)
			Count *int64 `json:"count,omitempty"`

			// Id ID used in database
			Id *int32 `json:"id,omitempty"`

			// Name TRES name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type TRES type (CPU, MEM, etc)
			Type string `json:"type"`
		} `json:"tres,omitempty"`
	} `json:"clusters"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiClustersRespClustersFlags defines model for V0041OpenapiClustersResp.Clusters.Flags.
type V0041OpenapiClustersRespClustersFlags string

// V0041OpenapiInstancesResp defines model for v0.0.41_openapi_instances_resp.
type V0041OpenapiInstancesResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Instances instances
	Instances []struct {
		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// InstanceId Cloud instance ID
		InstanceId *string `json:"instance_id,omitempty"`

		// InstanceType Cloud instance type
		InstanceType *string `json:"instance_type,omitempty"`

		// NodeName NodeName
		NodeName *string `json:"node_name,omitempty"`
		Time     *struct {
			// TimeEnd When the instance will end (UNIX timestamp)
			TimeEnd *int64 `json:"time_end,omitempty"`

			// TimeStart When the instance will start (UNIX timestamp)
			TimeStart *int64 `json:"time_start,omitempty"`
		} `json:"time,omitempty"`
	} `json:"instances"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiJobInfoResp defines model for v0.0.41_openapi_job_info_resp.
type V0041OpenapiJobInfoResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Jobs List of jobs
	Jobs []struct {
		// Account Account associated with the job
		Account *string `json:"account,omitempty"`

		// AccrueTime When the job started accruing age priority (UNIX timestamp)
		AccrueTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"accrue_time,omitempty"`

		// AdminComment Arbitrary comment made by administrator
		AdminComment *string `json:"admin_comment,omitempty"`

		// AllocatingNode Local node making the resource allocation
		AllocatingNode *string `json:"allocating_node,omitempty"`

		// ArrayJobId Job ID of job array, or 0 if N/A
		ArrayJobId *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"array_job_id,omitempty"`

		// ArrayMaxTasks Maximum number of simultaneously running array tasks, 0 if no limit
		ArrayMaxTasks *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"array_max_tasks,omitempty"`

		// ArrayTaskId Task ID of this task in job array
		ArrayTaskId *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"array_task_id,omitempty"`

		// ArrayTaskString String expression of task IDs in this record
		ArrayTaskString *string `json:"array_task_string,omitempty"`

		// AssociationId Unique identifier for the association
		AssociationId *int32 `json:"association_id,omitempty"`

		// BatchFeatures Features required for batch script's node
		BatchFeatures *string `json:"batch_features,omitempty"`

		// BatchFlag True if batch job
		BatchFlag *bool `json:"batch_flag,omitempty"`

		// BatchHost Name of host running batch script
		BatchHost *string `json:"batch_host,omitempty"`

		// BillableTres Billable TRES
		BillableTres *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"billable_tres,omitempty"`

		// BurstBuffer Burst buffer specifications
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// BurstBufferState Burst buffer state details
		BurstBufferState *string `json:"burst_buffer_state,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// ClusterFeatures List of required cluster features
		ClusterFeatures *string `json:"cluster_features,omitempty"`

		// Command Executed command
		Command *string `json:"command,omitempty"`

		// Comment Arbitrary comment
		Comment *string `json:"comment,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// ContainerId OCI container ID
		ContainerId *string `json:"container_id,omitempty"`

		// Contiguous True if job requires contiguous nodes
		Contiguous *bool `json:"contiguous,omitempty"`

		// CoreSpec Specialized core count
		CoreSpec *int32 `json:"core_spec,omitempty"`

		// CoresPerSocket Cores per socket required
		CoresPerSocket *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cores_per_socket,omitempty"`

		// CpuFrequencyGovernor CPU frequency governor
		CpuFrequencyGovernor *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpu_frequency_governor,omitempty"`

		// CpuFrequencyMaximum Maximum CPU frequency
		CpuFrequencyMaximum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpu_frequency_maximum,omitempty"`

		// CpuFrequencyMinimum Minimum CPU frequency
		CpuFrequencyMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpu_frequency_minimum,omitempty"`

		// Cpus Minimum number of CPUs required
		Cpus *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpus,omitempty"`

		// CpusPerTask Number of CPUs required by each task
		CpusPerTask *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpus_per_task,omitempty"`

		// CpusPerTres Semicolon delimited list of TRES=# values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
		CpusPerTres *string `json:"cpus_per_tres,omitempty"`

		// Cron Time specification for scrontab job
		Cron *string `json:"cron,omitempty"`

		// CurrentWorkingDirectory Working directory to use for the job
		CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

		// Deadline Latest time that the job may start (UNIX timestamp)
		Deadline *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"deadline,omitempty"`

		// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
		DelayBoot *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"delay_boot,omitempty"`

		// Dependency Other jobs that must meet certain criteria before this job can start
		Dependency *string `json:"dependency,omitempty"`

		// DerivedExitCode Highest exit code of all job steps
		DerivedExitCode *struct {
			// ReturnCode Process return code (numeric)
			ReturnCode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"return_code,omitempty"`
			Signal *struct {
				// Id Signal sent to process (numeric)
				Id *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"id,omitempty"`

				// Name Signal sent to process
				Name *string `json:"name,omitempty"`
			} `json:"signal,omitempty"`

			// Status Status given by return code
			Status *[]V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus `json:"status,omitempty"`
		} `json:"derived_exit_code,omitempty"`

		// EligibleTime Time when the job became eligible to run (UNIX timestamp)
		EligibleTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"eligible_time,omitempty"`

		// EndTime End time, real or expected (UNIX timestamp)
		EndTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"end_time,omitempty"`

		// ExcludedNodes Comma separated list of nodes that may not be used
		ExcludedNodes *string `json:"excluded_nodes,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Exclusive *[]V0041OpenapiJobInfoRespJobsExclusive `json:"exclusive,omitempty"`

		// ExitCode Exit code of the job
		ExitCode *struct {
			// ReturnCode Process return code (numeric)
			ReturnCode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"return_code,omitempty"`
			Signal *struct {
				// Id Signal sent to process (numeric)
				Id *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"id,omitempty"`

				// Name Signal sent to process
				Name *string `json:"name,omitempty"`
			} `json:"signal,omitempty"`

			// Status Status given by return code
			Status *[]V0041OpenapiJobInfoRespJobsExitCodeStatus `json:"status,omitempty"`
		} `json:"exit_code,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// FailedNode Name of node that caused job failure
		FailedNode *string `json:"failed_node,omitempty"`

		// Features Comma separated list of features that are required
		Features *string `json:"features,omitempty"`

		// FederationOrigin Origin cluster's name (when using federation)
		FederationOrigin *string `json:"federation_origin,omitempty"`

		// FederationSiblingsActive Active sibling job names
		FederationSiblingsActive *string `json:"federation_siblings_active,omitempty"`

		// FederationSiblingsViable Viable sibling job names
		FederationSiblingsViable *string `json:"federation_siblings_viable,omitempty"`

		// Flags Job flags
		Flags *[]V0041OpenapiJobInfoRespJobsFlags `json:"flags,omitempty"`

		// GresDetail List of GRES index and counts allocated per node
		GresDetail *[]string `json:"gres_detail,omitempty"`

		// GroupId Group ID of the user that owns the job
		GroupId *int32 `json:"group_id,omitempty"`

		// GroupName Group name of the user that owns the job
		GroupName *string `json:"group_name,omitempty"`

		// HetJobId Heterogeneous job ID, if applicable
		HetJobId *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"het_job_id,omitempty"`

		// HetJobIdSet Job ID range for all heterogeneous job components
		HetJobIdSet *string `json:"het_job_id_set,omitempty"`

		// HetJobOffset Unique sequence number applied to this component of the heterogeneous job
		HetJobOffset *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"het_job_offset,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// JobResources Resources used by the job
		JobResources *struct {
			// Cpus Number of allocated CPUs
			Cpus  int32 `json:"cpus"`
			Nodes *struct {
				// Allocation Allocated node resources
				Allocation *[]struct {
					Cpus *struct {
						// Count Total number of CPUs assigned to job
						Count *int32 `json:"count,omitempty"`

						// Used Total number of CPUs used by job
						Used *int32 `json:"used,omitempty"`
					} `json:"cpus,omitempty"`

					// Index Node index
					Index  int32 `json:"index"`
					Memory *struct {
						// Allocated Total memory (MiB) allocated to job
						Allocated *int64 `json:"allocated,omitempty"`

						// Used Total memory (MiB) used by job
						Used *int64 `json:"used,omitempty"`
					} `json:"memory,omitempty"`

					// Name Node name
					Name string `json:"name"`

					// Sockets Socket allocations in node
					Sockets []struct {
						// Cores Core in socket
						Cores []struct {
							// Index Core index
							Index int32 `json:"index"`

							// Status Core status
							Status []V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus `json:"status"`
						} `json:"cores"`

						// Index Core index
						Index int32 `json:"index"`
					} `json:"sockets"`
				} `json:"allocation,omitempty"`

				// Count Number of allocated nodes
				Count *int32 `json:"count,omitempty"`

				// List Node(s) allocated to the job
				List *string `json:"list,omitempty"`

				// SelectType Node scheduling selection method
				SelectType *[]V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType `json:"select_type,omitempty"`

				// Whole Whether whole nodes were allocated
				Whole *bool `json:"whole,omitempty"`
			} `json:"nodes,omitempty"`

			// SelectType Scheduler consumable resource selection type
			SelectType []V0041OpenapiJobInfoRespJobsJobResourcesSelectType `json:"select_type"`

			// ThreadsPerCore Number of processor threads per CPU core
			ThreadsPerCore struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"threads_per_core"`
		} `json:"job_resources,omitempty"`

		// JobSizeStr Number of nodes (in a range) required for this job
		JobSizeStr *[]string `json:"job_size_str,omitempty"`

		// JobState Current state
		JobState *[]V0041OpenapiJobInfoRespJobsJobState `json:"job_state,omitempty"`

		// LastSchedEvaluation Last time job was evaluated for scheduling (UNIX timestamp)
		LastSchedEvaluation *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"last_sched_evaluation,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`

		// MailType Mail event type(s)
		MailType *[]V0041OpenapiJobInfoRespJobsMailType `json:"mail_type,omitempty"`

		// MailUser User to receive email notifications
		MailUser *string `json:"mail_user,omitempty"`

		// MaxCpus Maximum number of CPUs usable by the job
		MaxCpus *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"max_cpus,omitempty"`

		// MaxNodes Maximum number of nodes usable by the job
		MaxNodes *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"max_nodes,omitempty"`

		// MaximumSwitchWaitTime Maximum time to wait for switches in seconds
		MaximumSwitchWaitTime *int32 `json:"maximum_switch_wait_time,omitempty"`

		// McsLabel Multi-Category Security label on the job
		McsLabel *string `json:"mcs_label,omitempty"`

		// MemoryPerCpu Minimum memory in megabytes per allocated CPU
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Minimum memory in megabytes per allocated node
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`

		// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
		MemoryPerTres *string `json:"memory_per_tres,omitempty"`

		// MinimumCpusPerNode Minimum number of CPUs per node
		MinimumCpusPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"minimum_cpus_per_node,omitempty"`

		// MinimumSwitches Maximum number of switches (the 'minimum' in the key is incorrect)
		MinimumSwitches *int32 `json:"minimum_switches,omitempty"`

		// MinimumTmpDiskPerNode Minimum tmp disk space required per node
		MinimumTmpDiskPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"minimum_tmp_disk_per_node,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Network Network specs for the job
		Network *string `json:"network,omitempty"`

		// Nice Requested job priority change
		Nice *int32 `json:"nice,omitempty"`

		// NodeCount Minimum number of nodes required
		NodeCount *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"node_count,omitempty"`

		// Nodes Node(s) allocated to the job
		Nodes *string `json:"nodes,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Oversubscribe *bool `json:"oversubscribe,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`
		Power     *struct {
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			Flags *[]interface{} `json:"flags,omitempty"`
		} `json:"power,omitempty"`

		// PreSusTime Total run time prior to last suspend in seconds
		PreSusTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"pre_sus_time,omitempty"`

		// PreemptTime Time job received preemption signal (UNIX timestamp)
		PreemptTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"preempt_time,omitempty"`

		// PreemptableTime Time job becomes eligible for preemption (UNIX timestamp)
		PreemptableTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"preemptable_time,omitempty"`

		// Prefer Feature(s) the job requested but that are not required
		Prefer *string `json:"prefer,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Profile Profile used by the acct_gather_profile plugin
		Profile *[]V0041OpenapiJobInfoRespJobsProfile `json:"profile,omitempty"`

		// Qos Quality of Service assigned to the job, if pending the QOS requested
		Qos *string `json:"qos,omitempty"`

		// Reboot Node reboot requested before start
		Reboot *bool `json:"reboot,omitempty"`

		// Requeue Determines whether the job may be requeued
		Requeue *bool `json:"requeue,omitempty"`

		// RequiredNodes Comma separated list of required nodes
		RequiredNodes *string `json:"required_nodes,omitempty"`

		// ResizeTime Time of last size change (UNIX timestamp)
		ResizeTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"resize_time,omitempty"`

		// RestartCnt Number of job restarts
		RestartCnt *int32 `json:"restart_cnt,omitempty"`

		// ResvName Name of reservation to use
		ResvName *string `json:"resv_name,omitempty"`

		// ScheduledNodes List of nodes scheduled to be used for the job
		ScheduledNodes *string `json:"scheduled_nodes,omitempty"`

		// SelinuxContext SELinux context
		SelinuxContext *string `json:"selinux_context,omitempty"`

		// Shared How the job can share resources with other jobs, if at all
		Shared *[]V0041OpenapiJobInfoRespJobsShared `json:"shared,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		ShowFlags *[]V0041OpenapiJobInfoRespJobsShowFlags `json:"show_flags,omitempty"`

		// SocketsPerBoard Number of sockets per board required
		SocketsPerBoard *int32 `json:"sockets_per_board,omitempty"`

		// SocketsPerNode Number of sockets per node required
		SocketsPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"sockets_per_node,omitempty"`

		// StandardError Path to stderr file
		StandardError *string `json:"standard_error,omitempty"`

		// StandardInput Path to stdin file
		StandardInput *string `json:"standard_input,omitempty"`

		// StandardOutput Path to stdout file
		StandardOutput *string `json:"standard_output,omitempty"`

		// StartTime Time execution began, or is expected to begin (UNIX timestamp)
		StartTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"start_time,omitempty"`

		// StateDescription Optional details for state_reason
		StateDescription *string `json:"state_description,omitempty"`

		// StateReason Reason for current Pending or Failed state
		StateReason *string `json:"state_reason,omitempty"`

		// SubmitTime Time when the job was submitted (UNIX timestamp)
		SubmitTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"submit_time,omitempty"`

		// SuspendTime Time the job was last suspended or resumed (UNIX timestamp)
		SuspendTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"suspend_time,omitempty"`

		// SystemComment Arbitrary comment from slurmctld
		SystemComment *string `json:"system_comment,omitempty"`

		// Tasks Number of tasks
		Tasks *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks,omitempty"`

		// TasksPerBoard Number of tasks invoked on each board
		TasksPerBoard *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_board,omitempty"`

		// TasksPerCore Number of tasks invoked on each core
		TasksPerCore *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_core,omitempty"`

		// TasksPerNode Number of tasks invoked on each node
		TasksPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_node,omitempty"`

		// TasksPerSocket Number of tasks invoked on each socket
		TasksPerSocket *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_socket,omitempty"`

		// TasksPerTres Number of tasks that can assess each GPU
		TasksPerTres *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"tasks_per_tres,omitempty"`

		// ThreadSpec Specialized thread count
		ThreadSpec *int32 `json:"thread_spec,omitempty"`

		// ThreadsPerCore Number of processor threads per CPU core required
		ThreadsPerCore *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"threads_per_core,omitempty"`

		// TimeLimit Maximum run time in minutes
		TimeLimit *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Minimum run time in minutes
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`

		// TresAllocStr TRES used by the job
		TresAllocStr *string `json:"tres_alloc_str,omitempty"`

		// TresBind Task to TRES binding directives
		TresBind *string `json:"tres_bind,omitempty"`

		// TresFreq TRES frequency directives
		TresFreq *string `json:"tres_freq,omitempty"`

		// TresPerJob Comma separated list of TRES=# values to be allocated per job
		TresPerJob *string `json:"tres_per_job,omitempty"`

		// TresPerNode Comma separated list of TRES=# values to be allocated per node
		TresPerNode *string `json:"tres_per_node,omitempty"`

		// TresPerSocket Comma separated list of TRES=# values to be allocated per socket
		TresPerSocket *string `json:"tres_per_socket,omitempty"`

		// TresPerTask Comma separated list of TRES=# values to be allocated per task
		TresPerTask *string `json:"tres_per_task,omitempty"`

		// TresReqStr TRES requested by the job
		TresReqStr *string `json:"tres_req_str,omitempty"`

		// UserId User ID that owns the job
		UserId *int32 `json:"user_id,omitempty"`

		// UserName User name that owns the job
		UserName *string `json:"user_name,omitempty"`

		// Wckey Workload characterization key
		Wckey *string `json:"wckey,omitempty"`
	} `json:"jobs"`

	// LastBackfill Time of last backfill scheduler run (UNIX timestamp)
	LastBackfill struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_backfill"`

	// LastUpdate Time of last job change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus defines model for V0041OpenapiJobInfoResp.Jobs.DerivedExitCode.Status.
type V0041OpenapiJobInfoRespJobsDerivedExitCodeStatus string

// V0041OpenapiJobInfoRespJobsExclusive defines model for V0041OpenapiJobInfoResp.Jobs.Exclusive.
type V0041OpenapiJobInfoRespJobsExclusive string

// V0041OpenapiJobInfoRespJobsExitCodeStatus defines model for V0041OpenapiJobInfoResp.Jobs.ExitCode.Status.
type V0041OpenapiJobInfoRespJobsExitCodeStatus string

// V0041OpenapiJobInfoRespJobsFlags defines model for V0041OpenapiJobInfoResp.Jobs.Flags.
type V0041OpenapiJobInfoRespJobsFlags string

// V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus defines model for V0041OpenapiJobInfoResp.Jobs.JobResources.Nodes.Allocation.Sockets.Cores.Status.
type V0041OpenapiJobInfoRespJobsJobResourcesNodesAllocationSocketsCoresStatus string

// V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType defines model for V0041OpenapiJobInfoResp.Jobs.JobResources.Nodes.SelectType.
type V0041OpenapiJobInfoRespJobsJobResourcesNodesSelectType string

// V0041OpenapiJobInfoRespJobsJobResourcesSelectType defines model for V0041OpenapiJobInfoResp.Jobs.JobResources.SelectType.
type V0041OpenapiJobInfoRespJobsJobResourcesSelectType string

// V0041OpenapiJobInfoRespJobsJobState defines model for V0041OpenapiJobInfoResp.Jobs.JobState.
type V0041OpenapiJobInfoRespJobsJobState string

// V0041OpenapiJobInfoRespJobsMailType defines model for V0041OpenapiJobInfoResp.Jobs.MailType.
type V0041OpenapiJobInfoRespJobsMailType string

// V0041OpenapiJobInfoRespJobsProfile defines model for V0041OpenapiJobInfoResp.Jobs.Profile.
type V0041OpenapiJobInfoRespJobsProfile string

// V0041OpenapiJobInfoRespJobsShared defines model for V0041OpenapiJobInfoResp.Jobs.Shared.
type V0041OpenapiJobInfoRespJobsShared string

// V0041OpenapiJobInfoRespJobsShowFlags defines model for V0041OpenapiJobInfoResp.Jobs.ShowFlags.
type V0041OpenapiJobInfoRespJobsShowFlags string

// V0041OpenapiNodesResp defines model for v0.0.41_openapi_nodes_resp.
type V0041OpenapiNodesResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// LastUpdate Time of last node change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Nodes List of nodes
	Nodes []struct {
		// ActiveFeatures Currently active features
		ActiveFeatures *[]string `json:"active_features,omitempty"`

		// Address NodeAddr, used to establish a communication path
		Address *string `json:"address,omitempty"`

		// AllocCpus Total number of CPUs currently allocated for jobs
		AllocCpus *int32 `json:"alloc_cpus,omitempty"`

		// AllocIdleCpus Total number of idle CPUs
		AllocIdleCpus *int32 `json:"alloc_idle_cpus,omitempty"`

		// AllocMemory Total memory in MB currently allocated for jobs
		AllocMemory *int64 `json:"alloc_memory,omitempty"`

		// Architecture Computer architecture
		Architecture *string `json:"architecture,omitempty"`

		// Boards Number of Baseboards in nodes with a baseboard controller
		Boards *int32 `json:"boards,omitempty"`

		// BootTime Time when the node booted (UNIX timestamp)
		BootTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"boot_time,omitempty"`

		// BurstbufferNetworkAddress Alternate network path to be used for sbcast network traffic
		BurstbufferNetworkAddress *string `json:"burstbuffer_network_address,omitempty"`

		// ClusterName Cluster name (only set in federated environments)
		ClusterName *string `json:"cluster_name,omitempty"`

		// Comment Arbitrary comment
		Comment *string `json:"comment,omitempty"`

		// Cores Number of cores in a single physical processor socket
		Cores *int32 `json:"cores,omitempty"`

		// CpuBinding Default method for binding tasks to allocated CPUs
		CpuBinding *int32 `json:"cpu_binding,omitempty"`

		// CpuLoad CPU load as reported by the OS
		CpuLoad *int32 `json:"cpu_load,omitempty"`

		// Cpus Total CPUs, including cores and threads
		Cpus *int32 `json:"cpus,omitempty"`

		// EffectiveCpus Number of effective CPUs (excluding specialized CPUs)
		EffectiveCpus *int32 `json:"effective_cpus,omitempty"`

		// Energy Energy usage data
		Energy *struct {
			// AverageWatts Average power consumption, in watts
			AverageWatts *int32 `json:"average_watts,omitempty"`

			// BaseConsumedEnergy The energy consumed between when the node was powered on and the last time it was registered by slurmd, in joules
			BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`

			// ConsumedEnergy The energy consumed between the last time the node was registered by the slurmd daemon and the last node energy accounting sample, in joules
			ConsumedEnergy *int64 `json:"consumed_energy,omitempty"`

			// CurrentWatts The instantaneous power consumption at the time of the last node energy accounting sample, in watts
			CurrentWatts *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"current_watts,omitempty"`

			// LastCollected Time when energy data was last retrieved (UNIX timestamp)
			LastCollected *int64 `json:"last_collected,omitempty"`

			// PreviousConsumedEnergy Previous value of consumed_energy
			PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
		} `json:"energy,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		ExternalSensors *map[string]interface{} `json:"external_sensors,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// Features Available features
		Features *[]string `json:"features,omitempty"`

		// FreeMem Total memory in MB currently free as reported by the OS
		FreeMem *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"free_mem,omitempty"`

		// GpuSpec CPU cores reserved for jobs that also use a GPU
		GpuSpec *string `json:"gpu_spec,omitempty"`

		// Gres Generic resources
		Gres *string `json:"gres,omitempty"`

		// GresDrained Drained generic resources
		GresDrained *string `json:"gres_drained,omitempty"`

		// GresUsed Generic resources currently in use
		GresUsed *string `json:"gres_used,omitempty"`

		// Hostname NodeHostname
		Hostname *string `json:"hostname,omitempty"`

		// InstanceId Cloud instance ID
		InstanceId *string `json:"instance_id,omitempty"`

		// InstanceType Cloud instance type
		InstanceType *string `json:"instance_type,omitempty"`

		// LastBusy Time when the node was last busy (UNIX timestamp)
		LastBusy *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"last_busy,omitempty"`

		// McsLabel Multi-Category Security label
		McsLabel *string `json:"mcs_label,omitempty"`

		// Name NodeName
		Name *string `json:"name,omitempty"`

		// NextStateAfterReboot The state the node will be assigned after rebooting
		NextStateAfterReboot *[]V0041OpenapiNodesRespNodesNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`

		// OperatingSystem Operating system reported by the node
		OperatingSystem *string `json:"operating_system,omitempty"`

		// Owner User allowed to run jobs on this node (unset if no restriction)
		Owner *string `json:"owner,omitempty"`

		// Partitions Partitions containing this node
		Partitions *[]string `json:"partitions,omitempty"`

		// Port TCP port number of the slurmd
		Port *int32 `json:"port,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Power *map[string]interface{} `json:"power,omitempty"`

		// RealMemory Total memory in MB on the node
		RealMemory *int64 `json:"real_memory,omitempty"`

		// Reason Describes why the node is in a "DOWN", "DRAINED", "DRAINING", "FAILING" or "FAIL" state
		Reason *string `json:"reason,omitempty"`

		// ReasonChangedAt When the reason changed (UNIX timestamp)
		ReasonChangedAt *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"reason_changed_at,omitempty"`

		// ReasonSetByUser User who set the reason
		ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`

		// ResCoresPerGpu Number of CPU cores per GPU restricted to GPU jobs
		ResCoresPerGpu *int32 `json:"res_cores_per_gpu,omitempty"`

		// Reservation Name of reservation containing this node
		Reservation *string `json:"reservation,omitempty"`

		// ResumeAfter Number of seconds after the node's state is updated to "DOWN" or "DRAIN" before scheduling a node state resume
		ResumeAfter *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"resume_after,omitempty"`

		// SlurmdStartTime Time when the slurmd started (UNIX timestamp)
		SlurmdStartTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"slurmd_start_time,omitempty"`

		// Sockets Number of physical processor sockets/chips on the node
		Sockets *int32 `json:"sockets,omitempty"`

		// SpecializedCores Number of cores reserved for system use
		SpecializedCores *int32 `json:"specialized_cores,omitempty"`

		// SpecializedCpus Abstract CPU IDs on this node reserved for exclusive use by slurmd and slurmstepd
		SpecializedCpus *string `json:"specialized_cpus,omitempty"`

		// SpecializedMemory Combined memory limit, in MB, for Slurm compute node daemons
		SpecializedMemory *int64 `json:"specialized_memory,omitempty"`

		// State Node state(s) applicable to this node
		State *[]V0041OpenapiNodesRespNodesState `json:"state,omitempty"`

		// TemporaryDisk Total size in MB of temporary disk storage in TmpFS
		TemporaryDisk *int32 `json:"temporary_disk,omitempty"`

		// Threads Number of logical threads in a single physical core
		Threads *int32 `json:"threads,omitempty"`

		// Tres Configured trackable resources
		Tres *string `json:"tres,omitempty"`

		// TresUsed Trackable resources currently allocated for jobs
		TresUsed *string `json:"tres_used,omitempty"`

		// TresWeighted Weighted number of billable trackable resources allocated
		TresWeighted *float64 `json:"tres_weighted,omitempty"`

		// Version Slurmd version
		Version *string `json:"version,omitempty"`

		// Weight Weight of the node for scheduling purposes
		Weight *int32 `json:"weight,omitempty"`
	} `json:"nodes"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiNodesRespNodesNextStateAfterReboot defines model for V0041OpenapiNodesResp.Nodes.NextStateAfterReboot.
type V0041OpenapiNodesRespNodesNextStateAfterReboot string

// V0041OpenapiNodesRespNodesState defines model for V0041OpenapiNodesResp.Nodes.State.
type V0041OpenapiNodesRespNodesState string

// V0041OpenapiPartitionResp defines model for v0.0.41_openapi_partition_resp.
type V0041OpenapiPartitionResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// LastUpdate Time of last partition change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Partitions List of partitions
	Partitions []struct {
		Accounts *struct {
			// Allowed AllowAccounts
			Allowed *string `json:"allowed,omitempty"`

			// Deny DenyAccounts
			Deny *string `json:"deny,omitempty"`
		} `json:"accounts,omitempty"`

		// Alternate Alternate
		Alternate *string `json:"alternate,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`
		Cpus    *struct {
			// TaskBinding CpuBind
			TaskBinding *int32 `json:"task_binding,omitempty"`

			// Total TotalCPUs
			Total *int32 `json:"total,omitempty"`
		} `json:"cpus,omitempty"`
		Defaults *struct {
			// Job JobDefaults
			Job *string `json:"job,omitempty"`

			// MemoryPerCpu DefMemPerCPU or DefMemPerNode
			MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

			// PartitionMemoryPerCpu DefMemPerCPU
			PartitionMemoryPerCpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"partition_memory_per_cpu,omitempty"`

			// PartitionMemoryPerNode DefMemPerNode
			PartitionMemoryPerNode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"partition_memory_per_node,omitempty"`

			// Time DefaultTime in minutes
			Time *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time,omitempty"`
		} `json:"defaults,omitempty"`

		// GraceTime GraceTime
		GraceTime *int32 `json:"grace_time,omitempty"`
		Groups    *struct {
			// Allowed AllowGroups
			Allowed *string `json:"allowed,omitempty"`
		} `json:"groups,omitempty"`
		Maximums *struct {
			// CpusPerNode MaxCPUsPerNode
			CpusPerNode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus_per_node,omitempty"`

			// CpusPerSocket MaxCPUsPerSocket
			CpusPerSocket *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpus_per_socket,omitempty"`

			// MemoryPerCpu MaxMemPerCPU or MaxMemPerNode
			MemoryPerCpu *int64 `json:"memory_per_cpu,omitempty"`

			// Nodes MaxNodes
			Nodes *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nodes,omitempty"`

			// OverTimeLimit OverTimeLimit
			OverTimeLimit *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"over_time_limit,omitempty"`
			Oversubscribe *struct {
				// Flags Flags applicable to the OverSubscribe setting
				Flags *[]V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags `json:"flags,omitempty"`

				// Jobs Maximum number of jobs allowed to oversubscribe resources
				Jobs *int32 `json:"jobs,omitempty"`
			} `json:"oversubscribe,omitempty"`

			// PartitionMemoryPerCpu MaxMemPerCPU
			PartitionMemoryPerCpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"partition_memory_per_cpu,omitempty"`

			// PartitionMemoryPerNode MaxMemPerNode
			PartitionMemoryPerNode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"partition_memory_per_node,omitempty"`

			// Shares OverSubscribe
			Shares *int32 `json:"shares,omitempty"`

			// Time MaxTime
			Time *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time,omitempty"`
		} `json:"maximums,omitempty"`
		Minimums *struct {
			// Nodes MinNodes
			Nodes *int32 `json:"nodes,omitempty"`
		} `json:"minimums,omitempty"`

		// Name PartitionName
		Name *string `json:"name,omitempty"`

		// NodeSets NodeSets
		NodeSets *string `json:"node_sets,omitempty"`
		Nodes    *struct {
			// AllowedAllocation AllocNodes
			AllowedAllocation *string `json:"allowed_allocation,omitempty"`

			// Configured Nodes
			Configured *string `json:"configured,omitempty"`

			// Total TotalNodes
			Total *int32 `json:"total,omitempty"`
		} `json:"nodes,omitempty"`
		Partition *struct {
			// State Current state(s)
			State *[]V0041OpenapiPartitionRespPartitionsPartitionState `json:"state,omitempty"`
		} `json:"partition,omitempty"`
		Priority *struct {
			// JobFactor PriorityJobFactor
			JobFactor *int32 `json:"job_factor,omitempty"`

			// Tier PriorityTier
			Tier *int32 `json:"tier,omitempty"`
		} `json:"priority,omitempty"`
		Qos *struct {
			// Allowed AllowQOS
			Allowed *string `json:"allowed,omitempty"`

			// Assigned QOS
			Assigned *string `json:"assigned,omitempty"`

			// Deny DenyQOS
			Deny *string `json:"deny,omitempty"`
		} `json:"qos,omitempty"`

		// SelectType Scheduler consumable resource selection type
		SelectType *[]V0041OpenapiPartitionRespPartitionsSelectType `json:"select_type,omitempty"`

		// SuspendTime SuspendTime (GLOBAL if both set and infinite are false)
		SuspendTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"suspend_time,omitempty"`
		Timeouts *struct {
			// Resume ResumeTimeout (GLOBAL if both set and infinite are false)
			Resume *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"resume,omitempty"`

			// Suspend SuspendTimeout (GLOBAL if both set and infinite are false)
			Suspend *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"suspend,omitempty"`
		} `json:"timeouts,omitempty"`
		Tres *struct {
			// BillingWeights TRESBillingWeights
			BillingWeights *string `json:"billing_weights,omitempty"`

			// Configured TRES
			Configured *string `json:"configured,omitempty"`
		} `json:"tres,omitempty"`
	} `json:"partitions"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags defines model for V0041OpenapiPartitionResp.Partitions.Maximums.Oversubscribe.Flags.
type V0041OpenapiPartitionRespPartitionsMaximumsOversubscribeFlags string

// V0041OpenapiPartitionRespPartitionsPartitionState defines model for V0041OpenapiPartitionResp.Partitions.Partition.State.
type V0041OpenapiPartitionRespPartitionsPartitionState string

// V0041OpenapiPartitionRespPartitionsSelectType defines model for V0041OpenapiPartitionResp.Partitions.SelectType.
type V0041OpenapiPartitionRespPartitionsSelectType string

// V0041OpenapiReservationResp defines model for v0.0.41_openapi_reservation_resp.
type V0041OpenapiReservationResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// LastUpdate Time of last reservation change (UNIX timestamp)
	LastUpdate struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"last_update"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Reservations List of reservations
	Reservations []struct {
		// Accounts Comma separated list of permitted accounts
		Accounts *string `json:"accounts,omitempty"`

		// BurstBuffer BurstBuffer
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// CoreCount CoreCnt
		CoreCount *int32 `json:"core_count,omitempty"`

		// CoreSpecializations Reserved cores specification
		CoreSpecializations *[]struct {
			// Core IDs of reserved cores
			Core *string `json:"core,omitempty"`

			// Node Name of reserved node
			Node *string `json:"node,omitempty"`
		} `json:"core_specializations,omitempty"`

		// EndTime EndTime (UNIX timestamp)
		EndTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"end_time,omitempty"`

		// Features Features
		Features *string `json:"features,omitempty"`

		// Flags Flags associated with the reservation
		Flags *[]V0041OpenapiReservationRespReservationsFlags `json:"flags,omitempty"`

		// Groups Groups
		Groups *string `json:"groups,omitempty"`

		// Licenses Licenses
		Licenses *string `json:"licenses,omitempty"`

		// MaxStartDelay MaxStartDelay in seconds
		MaxStartDelay *int32 `json:"max_start_delay,omitempty"`

		// Name ReservationName
		Name *string `json:"name,omitempty"`

		// NodeCount NodeCnt
		NodeCount *int32 `json:"node_count,omitempty"`

		// NodeList Nodes
		NodeList *string `json:"node_list,omitempty"`

		// Partition PartitionName
		Partition      *string `json:"partition,omitempty"`
		PurgeCompleted *struct {
			// Time If PURGE_COMP flag is set, the number of seconds this reservation will sit idle until it is revoked
			Time *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"time,omitempty"`
		} `json:"purge_completed,omitempty"`

		// StartTime StartTime (UNIX timestamp)
		StartTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"start_time,omitempty"`

		// Tres Comma separated list of required TRES
		Tres *string `json:"tres,omitempty"`

		// Users Comma separated list of permitted users
		Users *string `json:"users,omitempty"`

		// Watts 32 bit integer number with flags
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Watts *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"watts,omitempty"`
	} `json:"reservations"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiReservationRespReservationsFlags defines model for V0041OpenapiReservationResp.Reservations.Flags.
type V0041OpenapiReservationRespReservationsFlags string

// V0041OpenapiResp defines model for v0.0.41_openapi_resp.
type V0041OpenapiResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSharesResp defines model for v0.0.41_openapi_shares_resp.
type V0041OpenapiSharesResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Shares fairshare info
	Shares struct {
		// Shares Association shares
		Shares *[]struct {
			// Cluster Cluster name
			Cluster *string `json:"cluster,omitempty"`

			// EffectiveUsage Effective, normalized usage
			EffectiveUsage *float64 `json:"effective_usage,omitempty"`
			Fairshare      *struct {
				// Factor Fairshare factor
				Factor *float64 `json:"factor,omitempty"`

				// Level Fairshare factor at this level; stored on an assoc as a long double, but that is not needed for display in sshare
				Level *float64 `json:"level,omitempty"`
			} `json:"fairshare,omitempty"`

			// Id Association ID
			Id *int32 `json:"id,omitempty"`

			// Name Share name
			Name *string `json:"name,omitempty"`

			// Parent Parent name
			Parent *string `json:"parent,omitempty"`

			// Partition Partition name
			Partition *string `json:"partition,omitempty"`

			// Shares Number of shares allocated
			Shares *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"shares,omitempty"`

			// SharesNormalized Normalized shares
			SharesNormalized *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"shares_normalized,omitempty"`
			Tres *struct {
				// GroupMinutes TRES-minute limit
				GroupMinutes *[]struct {
					// Name TRES name
					Name *string `json:"name,omitempty"`

					// Value TRES value
					Value *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"value,omitempty"`
				} `json:"group_minutes,omitempty"`

				// RunSeconds Currently running tres-secs = grp_used_tres_run_secs
				RunSeconds *[]struct {
					// Name TRES name
					Name *string `json:"name,omitempty"`

					// Value TRES value
					Value *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"value,omitempty"`
				} `json:"run_seconds,omitempty"`

				// Usage Measure of each TRES usage
				Usage *[]struct {
					// Name TRES name
					Name *string `json:"name,omitempty"`

					// Value TRES value
					Value *float32 `json:"value,omitempty"`
				} `json:"usage,omitempty"`
			} `json:"tres,omitempty"`

			// Type User or account association
			Type *[]V0041OpenapiSharesRespSharesSharesType `json:"type,omitempty"`

			// Usage Measure of tresbillableunits usage
			Usage *int64 `json:"usage,omitempty"`

			// UsageNormalized Normalized usage
			UsageNormalized *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"usage_normalized,omitempty"`
		} `json:"shares,omitempty"`

		// TotalShares Total number of shares
		TotalShares *int64 `json:"total_shares,omitempty"`
	} `json:"shares"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSharesRespSharesSharesType defines model for V0041OpenapiSharesResp.Shares.Shares.Type.
type V0041OpenapiSharesRespSharesSharesType string

// V0041OpenapiSlurmdbdConfigResp defines model for v0.0.41_openapi_slurmdbd_config_resp.
type V0041OpenapiSlurmdbdConfigResp struct {
	// Accounts Accounts
	Accounts *[]struct {
		// Associations Associations involving this account (only populated if requested)
		Associations *[]struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"associations,omitempty"`

		// Coordinators List of users that are a coordinator of this account (only populated if requested)
		Coordinators *[]struct {
			// Direct Indicates whether the coordinator was directly assigned to this account
			Direct *bool `json:"direct,omitempty"`

			// Name User name
			Name string `json:"name"`
		} `json:"coordinators,omitempty"`

		// Description Arbitrary string describing the account
		Description string `json:"description"`

		// Flags Flags associated with the account
		Flags *[]V0041OpenapiSlurmdbdConfigRespAccountsFlags `json:"flags,omitempty"`

		// Name Account name
		Name string `json:"name"`

		// Organization Organization to which the account belongs
		Organization string `json:"organization"`
	} `json:"accounts,omitempty"`

	// Associations Associations
	Associations *[]struct {
		// Account Account
		Account *string `json:"account,omitempty"`

		// Accounting Accounting records containing related resource usage
		Accounting *[]struct {
			// TRES Trackable resources
			TRES *struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"TRES,omitempty"`
			Allocated *struct {
				// Seconds Number of cpu seconds allocated
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"allocated,omitempty"`

			// Id Association ID or Workload characterization key ID
			Id *int32 `json:"id,omitempty"`

			// Start When the record was started
			Start *int64 `json:"start,omitempty"`
		} `json:"accounting,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Comment Arbitrary comment
		Comment *string `json:"comment,omitempty"`
		Default *struct {
			// Qos Default QOS
			Qos *string `json:"qos,omitempty"`
		} `json:"default,omitempty"`

		// Flags Flags on the association
		Flags *[]V0041OpenapiSlurmdbdConfigRespAssociationsFlags `json:"flags,omitempty"`

		// Id Unique ID
		Id *int32 `json:"id,omitempty"`

		// IsDefault Is default association for user
		IsDefault *bool `json:"is_default,omitempty"`

		// Lineage Complete path up the hierarchy to the root association
		Lineage *string `json:"lineage,omitempty"`
		Max     *struct {
			Jobs *struct {
				// Accruing MaxJobsAccrue
				Accruing *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"accruing,omitempty"`

				// Active MaxJobs
				Active *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"active,omitempty"`
				Per *struct {
					// Accruing GrpJobsAccrue
					Accruing *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"accruing,omitempty"`

					// Count GrpJobs
					Count *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"count,omitempty"`

					// Submitted GrpSubmitJobs
					Submitted *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"submitted,omitempty"`

					// WallClock MaxWallDurationPerJob
					WallClock *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"wall_clock,omitempty"`
				} `json:"per,omitempty"`

				// Total MaxSubmitJobs
				Total *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"total,omitempty"`
			} `json:"jobs,omitempty"`
			Per *struct {
				Account *struct {
					// WallClock GrpWall
					WallClock *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"wall_clock,omitempty"`
				} `json:"account,omitempty"`
			} `json:"per,omitempty"`
			Tres *struct {
				Group *struct {
					// Active GrpTRESRunMins
					Active *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"active,omitempty"`

					// Minutes GrpTRESMins
					Minutes *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"minutes,omitempty"`
				} `json:"group,omitempty"`
				Minutes *struct {
					Per *struct {
						// Job MaxTRESMinsPerJob
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`
					} `json:"per,omitempty"`

					// Total MaxTRESMinsPerJob
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"minutes,omitempty"`
				Per *struct {
					// Job MaxTRESPerJob
					Job *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"job,omitempty"`

					// Node MaxTRESPerNode
					Node *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"node,omitempty"`
				} `json:"per,omitempty"`

				// Total GrpTRES
				Total *[]struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"total,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"max,omitempty"`
		Min *struct {
			// PriorityThreshold MinPrioThreshold
			PriorityThreshold *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority_threshold,omitempty"`
		} `json:"min,omitempty"`

		// ParentAccount Name of parent account
		ParentAccount *string `json:"parent_account,omitempty"`

		// Partition Partition name
		Partition *string `json:"partition,omitempty"`

		// Priority Association priority factor
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Qos List of available QOS names
		Qos *[]string `json:"qos,omitempty"`

		// SharesRaw Allocated shares used for fairshare calculation
		SharesRaw *int32 `json:"shares_raw,omitempty"`

		// User User name
		User string `json:"user"`
	} `json:"associations,omitempty"`

	// Clusters Clusters
	Clusters *[]struct {
		Associations *struct {
			// Root Root association information
			Root *struct {
				// Account Account
				Account *string `json:"account,omitempty"`

				// Cluster Cluster
				Cluster *string `json:"cluster,omitempty"`

				// Id Numeric association ID
				Id *int32 `json:"id,omitempty"`

				// Partition Partition
				Partition *string `json:"partition,omitempty"`

				// User User name
				User string `json:"user"`
			} `json:"root,omitempty"`
		} `json:"associations,omitempty"`
		Controller *struct {
			// Host ControlHost
			Host *string `json:"host,omitempty"`

			// Port ControlPort
			Port *int32 `json:"port,omitempty"`
		} `json:"controller,omitempty"`

		// Flags Flags
		Flags *[]V0041OpenapiSlurmdbdConfigRespClustersFlags `json:"flags,omitempty"`

		// Name ClusterName
		Name *string `json:"name,omitempty"`

		// Nodes Node names
		Nodes *string `json:"nodes,omitempty"`

		// RpcVersion RPC version used in the cluster
		RpcVersion *int32 `json:"rpc_version,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		SelectPlugin *string `json:"select_plugin,omitempty"`

		// Tres Trackable resources
		Tres *[]struct {
			// Count TRES count (0 if listed generically)
			Count *int64 `json:"count,omitempty"`

			// Id ID used in database
			Id *int32 `json:"id,omitempty"`

			// Name TRES name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type TRES type (CPU, MEM, etc)
			Type string `json:"type"`
		} `json:"tres,omitempty"`
	} `json:"clusters,omitempty"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Instances Instances
	Instances *[]struct {
		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// InstanceId Cloud instance ID
		InstanceId *string `json:"instance_id,omitempty"`

		// InstanceType Cloud instance type
		InstanceType *string `json:"instance_type,omitempty"`

		// NodeName NodeName
		NodeName *string `json:"node_name,omitempty"`
		Time     *struct {
			// TimeEnd When the instance will end (UNIX timestamp)
			TimeEnd *int64 `json:"time_end,omitempty"`

			// TimeStart When the instance will start (UNIX timestamp)
			TimeStart *int64 `json:"time_start,omitempty"`
		} `json:"time,omitempty"`
	} `json:"instances,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Qos QOS
	Qos *[]struct {
		// Description Arbitrary description
		Description *string `json:"description,omitempty"`

		// Flags Flags, to avoid modifying current values specify NOT_SET
		Flags *[]V0041OpenapiSlurmdbdConfigRespQosFlags `json:"flags,omitempty"`

		// Id Unique ID
		Id     *int32 `json:"id,omitempty"`
		Limits *struct {
			// Factor LimitFactor
			Factor *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"factor,omitempty"`

			// GraceTime GraceTime
			GraceTime *int32 `json:"grace_time,omitempty"`
			Max       *struct {
				Accruing *struct {
					Per *struct {
						// Account MaxJobsAccruePerAccount
						Account *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"account,omitempty"`

						// User MaxJobsAccruePerUser
						User *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"accruing,omitempty"`
				ActiveJobs *struct {
					// Accruing GrpJobsAccrue
					Accruing *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"accruing,omitempty"`

					// Count GrpJobs
					Count *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"count,omitempty"`
				} `json:"active_jobs,omitempty"`
				Jobs *struct {
					ActiveJobs *struct {
						Per *struct {
							// Account MaxJobsPerAccount
							Account *struct {
								// Infinite True if number has been set to infinite; "set" and "number" will be ignored
								Infinite *bool `json:"infinite,omitempty"`

								// Number If "set" is True the number will be set with value; otherwise ignore number contents
								Number *int32 `json:"number,omitempty"`

								// Set True if number has been set; False if number is unset
								Set *bool `json:"set,omitempty"`
							} `json:"account,omitempty"`

							// User MaxJobsPerUser
							User *struct {
								// Infinite True if number has been set to infinite; "set" and "number" will be ignored
								Infinite *bool `json:"infinite,omitempty"`

								// Number If "set" is True the number will be set with value; otherwise ignore number contents
								Number *int32 `json:"number,omitempty"`

								// Set True if number has been set; False if number is unset
								Set *bool `json:"set,omitempty"`
							} `json:"user,omitempty"`
						} `json:"per,omitempty"`
					} `json:"active_jobs,omitempty"`
					Per *struct {
						// Account MaxSubmitJobsPerAccount
						Account *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"account,omitempty"`

						// User MaxSubmitJobsPerUser
						User *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"jobs,omitempty"`
				Tres *struct {
					Minutes *struct {
						Per *struct {
							// Account MaxTRESRunMinsPerAccount
							Account *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"account,omitempty"`

							// Job MaxTRESMinsPerJob
							Job *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"job,omitempty"`

							// Qos GrpTRESRunMins
							Qos *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"qos,omitempty"`

							// User MaxTRESRunMinsPerUser
							User *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"user,omitempty"`
						} `json:"per,omitempty"`
					} `json:"minutes,omitempty"`
					Per *struct {
						// Account MaxTRESPerAccount
						Account *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"account,omitempty"`

						// Job MaxTRESPerJob
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`

						// Node MaxTRESPerNode
						Node *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"node,omitempty"`

						// User MaxTRESPerUser
						User *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`

					// Total GrpTRES
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"tres,omitempty"`
				WallClock *struct {
					Per *struct {
						// Job MaxWallDurationPerJob
						Job *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"job,omitempty"`

						// Qos GrpWall
						Qos *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"qos,omitempty"`
					} `json:"per,omitempty"`
				} `json:"wall_clock,omitempty"`
			} `json:"max,omitempty"`
			Min *struct {
				// PriorityThreshold MinPrioThreshold
				PriorityThreshold *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"priority_threshold,omitempty"`
				Tres *struct {
					Per *struct {
						// Job MinTRES
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`
					} `json:"per,omitempty"`
				} `json:"tres,omitempty"`
			} `json:"min,omitempty"`
		} `json:"limits,omitempty"`

		// Name Name
		Name    *string `json:"name,omitempty"`
		Preempt *struct {
			// ExemptTime PreemptExemptTime
			ExemptTime *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"exempt_time,omitempty"`

			// List Other QOS's this QOS can preempt
			List *[]string `json:"list,omitempty"`

			// Mode PreemptMode
			Mode *[]V0041OpenapiSlurmdbdConfigRespQosPreemptMode `json:"mode,omitempty"`
		} `json:"preempt,omitempty"`

		// Priority Priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// UsageFactor UsageFactor
		UsageFactor *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"usage_factor,omitempty"`

		// UsageThreshold UsageThreshold
		UsageThreshold *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"usage_threshold,omitempty"`
	} `json:"qos,omitempty"`

	// Tres TRES
	Tres *[]struct {
		// Count TRES count (0 if listed generically)
		Count *int64 `json:"count,omitempty"`

		// Id ID used in database
		Id *int32 `json:"id,omitempty"`

		// Name TRES name (if applicable)
		Name *string `json:"name,omitempty"`

		// Type TRES type (CPU, MEM, etc)
		Type string `json:"type"`
	} `json:"tres,omitempty"`

	// Users Users
	Users *[]struct {
		// AdministratorLevel AdminLevel granted to the user
		AdministratorLevel *[]V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel `json:"administrator_level,omitempty"`

		// Associations Associations created for this user
		Associations *[]struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"associations,omitempty"`

		// Coordinators Accounts this user is a coordinator for
		Coordinators *[]struct {
			// Direct Indicates whether the coordinator was directly assigned to this account
			Direct *bool `json:"direct,omitempty"`

			// Name User name
			Name string `json:"name"`
		} `json:"coordinators,omitempty"`
		Default *struct {
			// Account Default Account
			Account *string `json:"account,omitempty"`

			// Wckey Default WCKey
			Wckey *string `json:"wckey,omitempty"`
		} `json:"default,omitempty"`

		// Flags Flags associated with user
		Flags *[]V0041OpenapiSlurmdbdConfigRespUsersFlags `json:"flags,omitempty"`

		// Name User name
		Name string `json:"name"`

		// OldName Previous user name
		OldName *string `json:"old_name,omitempty"`

		// Wckeys List of available WCKeys
		Wckeys *[]struct {
			// Accounting Accounting records containing related resource usage
			Accounting *[]struct {
				// TRES Trackable resources
				TRES *struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"TRES,omitempty"`
				Allocated *struct {
					// Seconds Number of cpu seconds allocated
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"allocated,omitempty"`

				// Id Association ID or Workload characterization key ID
				Id *int32 `json:"id,omitempty"`

				// Start When the record was started
				Start *int64 `json:"start,omitempty"`
			} `json:"accounting,omitempty"`

			// Cluster Cluster name
			Cluster string `json:"cluster"`

			// Flags Flags associated with the WCKey
			Flags *[]V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags `json:"flags,omitempty"`

			// Id Unique ID for this user-cluster-wckey combination
			Id *int32 `json:"id,omitempty"`

			// Name WCKey name
			Name string `json:"name"`

			// User User name
			User string `json:"user"`
		} `json:"wckeys,omitempty"`
	} `json:"users,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`

	// Wckeys WCKeys
	Wckeys *[]struct {
		// Accounting Accounting records containing related resource usage
		Accounting *[]struct {
			// TRES Trackable resources
			TRES *struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"TRES,omitempty"`
			Allocated *struct {
				// Seconds Number of cpu seconds allocated
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"allocated,omitempty"`

			// Id Association ID or Workload characterization key ID
			Id *int32 `json:"id,omitempty"`

			// Start When the record was started
			Start *int64 `json:"start,omitempty"`
		} `json:"accounting,omitempty"`

		// Cluster Cluster name
		Cluster string `json:"cluster"`

		// Flags Flags associated with the WCKey
		Flags *[]V0041OpenapiSlurmdbdConfigRespWckeysFlags `json:"flags,omitempty"`

		// Id Unique ID for this user-cluster-wckey combination
		Id *int32 `json:"id,omitempty"`

		// Name WCKey name
		Name string `json:"name"`

		// User User name
		User string `json:"user"`
	} `json:"wckeys,omitempty"`
}

// V0041OpenapiSlurmdbdConfigRespAccountsFlags defines model for V0041OpenapiSlurmdbdConfigResp.Accounts.Flags.
type V0041OpenapiSlurmdbdConfigRespAccountsFlags string

// V0041OpenapiSlurmdbdConfigRespAssociationsFlags defines model for V0041OpenapiSlurmdbdConfigResp.Associations.Flags.
type V0041OpenapiSlurmdbdConfigRespAssociationsFlags string

// V0041OpenapiSlurmdbdConfigRespClustersFlags defines model for V0041OpenapiSlurmdbdConfigResp.Clusters.Flags.
type V0041OpenapiSlurmdbdConfigRespClustersFlags string

// V0041OpenapiSlurmdbdConfigRespQosFlags defines model for V0041OpenapiSlurmdbdConfigResp.Qos.Flags.
type V0041OpenapiSlurmdbdConfigRespQosFlags string

// V0041OpenapiSlurmdbdConfigRespQosPreemptMode defines model for V0041OpenapiSlurmdbdConfigResp.Qos.Preempt.Mode.
type V0041OpenapiSlurmdbdConfigRespQosPreemptMode string

// V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel defines model for V0041OpenapiSlurmdbdConfigResp.Users.AdministratorLevel.
type V0041OpenapiSlurmdbdConfigRespUsersAdministratorLevel string

// V0041OpenapiSlurmdbdConfigRespUsersFlags defines model for V0041OpenapiSlurmdbdConfigResp.Users.Flags.
type V0041OpenapiSlurmdbdConfigRespUsersFlags string

// V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags defines model for V0041OpenapiSlurmdbdConfigResp.Users.Wckeys.Flags.
type V0041OpenapiSlurmdbdConfigRespUsersWckeysFlags string

// V0041OpenapiSlurmdbdConfigRespWckeysFlags defines model for V0041OpenapiSlurmdbdConfigResp.Wckeys.Flags.
type V0041OpenapiSlurmdbdConfigRespWckeysFlags string

// V0041OpenapiSlurmdbdJobsResp defines model for v0.0.41_openapi_slurmdbd_jobs_resp.
type V0041OpenapiSlurmdbdJobsResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Jobs jobs
	Jobs []struct {
		// Account Account the job ran under
		Account *string `json:"account,omitempty"`

		// AllocationNodes List of nodes allocated to the job
		AllocationNodes *int32 `json:"allocation_nodes,omitempty"`
		Array           *struct {
			// JobId Job ID of job array, or 0 if N/A
			JobId  *int32 `json:"job_id,omitempty"`
			Limits *struct {
				Max *struct {
					Running *struct {
						// Tasks Maximum number of simultaneously running tasks, 0 if no limit
						Tasks *int32 `json:"tasks,omitempty"`
					} `json:"running,omitempty"`
				} `json:"max,omitempty"`
			} `json:"limits,omitempty"`

			// Task String expression of task IDs in this record
			Task *string `json:"task,omitempty"`

			// TaskId Task ID of this task in job array
			TaskId *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"task_id,omitempty"`
		} `json:"array,omitempty"`

		// Association Unique identifier for the association
		Association *struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"association,omitempty"`

		// Block The name of the block to be used (used with Blue Gene systems)
		Block *string `json:"block,omitempty"`

		// Cluster Cluster name
		Cluster *string `json:"cluster,omitempty"`
		Comment *struct {
			// Administrator Arbitrary comment made by administrator
			Administrator *string `json:"administrator,omitempty"`

			// Job Arbitrary comment made by user
			Job *string `json:"job,omitempty"`

			// System Arbitrary comment from slurmctld
			System *string `json:"system,omitempty"`
		} `json:"comment,omitempty"`

		// Constraints Feature(s) the job requested as a constraint
		Constraints *string `json:"constraints,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// DerivedExitCode Highest exit code of all job steps
		DerivedExitCode *struct {
			// ReturnCode Process return code (numeric)
			ReturnCode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"return_code,omitempty"`
			Signal *struct {
				// Id Signal sent to process (numeric)
				Id *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"id,omitempty"`

				// Name Signal sent to process
				Name *string `json:"name,omitempty"`
			} `json:"signal,omitempty"`

			// Status Status given by return code
			Status *[]V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus `json:"status,omitempty"`
		} `json:"derived_exit_code,omitempty"`

		// ExitCode Exit code
		ExitCode *struct {
			// ReturnCode Process return code (numeric)
			ReturnCode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"return_code,omitempty"`
			Signal *struct {
				// Id Signal sent to process (numeric)
				Id *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"id,omitempty"`

				// Name Signal sent to process
				Name *string `json:"name,omitempty"`
			} `json:"signal,omitempty"`

			// Status Status given by return code
			Status *[]V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus `json:"status,omitempty"`
		} `json:"exit_code,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// FailedNode Name of node that caused job failure
		FailedNode *string `json:"failed_node,omitempty"`

		// Flags Flags associated with the job
		Flags *[]V0041OpenapiSlurmdbdJobsRespJobsFlags `json:"flags,omitempty"`

		// Group Group ID of the user that owns the job
		Group *string `json:"group,omitempty"`
		Het   *struct {
			// JobId Heterogeneous job ID, if applicable
			JobId *int32 `json:"job_id,omitempty"`

			// JobOffset Unique sequence number applied to this component of the heterogeneous job
			JobOffset *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"job_offset,omitempty"`
		} `json:"het,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// KillRequestUser User ID that requested termination of the job
		KillRequestUser *string `json:"kill_request_user,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`
		Mcs      *struct {
			// Label Multi-Category Security label on the job
			Label *string `json:"label,omitempty"`
		} `json:"mcs,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Nodes Node(s) allocated to the job
		Nodes *string `json:"nodes,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Qos Quality of Service assigned to the job
		Qos      *string `json:"qos,omitempty"`
		Required *struct {
			// CPUs Minimum number of CPUs required
			CPUs *int32 `json:"CPUs,omitempty"`

			// MemoryPerCpu Minimum memory in megabytes per allocated CPU
			MemoryPerCpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_cpu,omitempty"`

			// MemoryPerNode Minimum memory in megabytes per allocated node
			MemoryPerNode *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memory_per_node,omitempty"`
		} `json:"required,omitempty"`
		Reservation *struct {
			// Id Unique identifier of requested reservation
			Id *int32 `json:"id,omitempty"`

			// Name Name of reservation to use
			Name *string `json:"name,omitempty"`
		} `json:"reservation,omitempty"`

		// Script Job batch script; only the first component in a HetJob is populated or honored
		Script *string `json:"script,omitempty"`
		State  *struct {
			// Current Current state
			Current *[]V0041OpenapiSlurmdbdJobsRespJobsStateCurrent `json:"current,omitempty"`

			// Reason Reason for previous Pending or Failed state
			Reason *string `json:"reason,omitempty"`
		} `json:"state,omitempty"`

		// Stderr Path to stderr file
		Stderr *string `json:"stderr,omitempty"`

		// StderrExpanded Job stderr with expanded fields
		StderrExpanded *string `json:"stderr_expanded,omitempty"`

		// Stdin Path to stdin file
		Stdin *string `json:"stdin,omitempty"`

		// StdinExpanded Job stdin with expanded fields
		StdinExpanded *string `json:"stdin_expanded,omitempty"`

		// Stdout Path to stdout file
		Stdout *string `json:"stdout,omitempty"`

		// StdoutExpanded Job stdout with expanded fields
		StdoutExpanded *string `json:"stdout_expanded,omitempty"`

		// Steps Individual steps in the job
		Steps *[]struct {
			CPU *struct {
				// Governor Requested CPU frequency governor in kHz
				Governor           *string `json:"governor,omitempty"`
				RequestedFrequency *struct {
					// Max Maximum requested CPU frequency in kHz
					Max *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"max,omitempty"`

					// Min Minimum requested CPU frequency in kHz
					Min *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"min,omitempty"`
				} `json:"requested_frequency,omitempty"`
			} `json:"CPU,omitempty"`

			// ExitCode Exit code
			ExitCode *struct {
				// ReturnCode Process return code (numeric)
				ReturnCode *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"return_code,omitempty"`
				Signal *struct {
					// Id Signal sent to process (numeric)
					Id *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"id,omitempty"`

					// Name Signal sent to process
					Name *string `json:"name,omitempty"`
				} `json:"signal,omitempty"`

				// Status Status given by return code
				Status *[]V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus `json:"status,omitempty"`
			} `json:"exit_code,omitempty"`

			// KillRequestUser User ID that requested termination of the step
			KillRequestUser *string `json:"kill_request_user,omitempty"`
			Nodes           *struct {
				// Count Number of nodes in the job step
				Count *int32 `json:"count,omitempty"`

				// List List of nodes used by the step
				List *[]string `json:"list,omitempty"`

				// Range Node(s) allocated to the job step
				Range *string `json:"range,omitempty"`
			} `json:"nodes,omitempty"`

			// Pid Process ID
			Pid *string `json:"pid,omitempty"`

			// State Current state
			State      *[]V0041OpenapiSlurmdbdJobsRespJobsStepsState `json:"state,omitempty"`
			Statistics *struct {
				CPU *struct {
					// ActualFrequency Average weighted CPU frequency of all tasks in kHz
					ActualFrequency *int64 `json:"actual_frequency,omitempty"`
				} `json:"CPU,omitempty"`
				Energy *struct {
					// Consumed Total energy consumed by all tasks in a job in joules
					Consumed *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"consumed,omitempty"`
				} `json:"energy,omitempty"`
			} `json:"statistics,omitempty"`
			Step *struct {
				// Id Step ID
				Id *string `json:"id,omitempty"`

				// Name Step name
				Name *string `json:"name,omitempty"`
			} `json:"step,omitempty"`
			Task *struct {
				// Distribution The layout of the step was when it was running
				Distribution *string `json:"distribution,omitempty"`
			} `json:"task,omitempty"`
			Tasks *struct {
				// Count Total number of tasks
				Count *int32 `json:"count,omitempty"`
			} `json:"tasks,omitempty"`
			Time *struct {
				// Elapsed Elapsed time in seconds
				Elapsed *int32 `json:"elapsed,omitempty"`

				// End End time (UNIX timestamp)
				End *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"end,omitempty"`

				// Start Time execution began (UNIX timestamp)
				Start *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"start,omitempty"`

				// Suspended Time in suspended state in seconds
				Suspended *int32 `json:"suspended,omitempty"`
				System    *struct {
					// Microseconds System CPU time used by the step in microseconds
					Microseconds *int32 `json:"microseconds,omitempty"`

					// Seconds System CPU time used by the step in seconds
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"system,omitempty"`
				Total *struct {
					// Microseconds Total CPU time used by the step in microseconds
					Microseconds *int32 `json:"microseconds,omitempty"`

					// Seconds Total CPU time used by the step in seconds
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"total,omitempty"`
				User *struct {
					// Microseconds User CPU time used by the step in microseconds
					Microseconds *int32 `json:"microseconds,omitempty"`

					// Seconds User CPU time used by the step in seconds
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"user,omitempty"`
			} `json:"time,omitempty"`
			Tres *struct {
				// Allocated Trackable resources allocated to the step
				Allocated *[]struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"allocated,omitempty"`
				Consumed *struct {
					// Average Average TRES usage consumed among all tasks
					Average *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"average,omitempty"`

					// Max Maximum TRES usage consumed among all tasks
					Max *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"max,omitempty"`

					// Min Minimum TRES usage consumed among all tasks
					Min *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"min,omitempty"`

					// Total Total TRES usage consumed among all tasks
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"consumed,omitempty"`
				Requested *struct {
					// Average Average TRES usage requested among all tasks
					Average *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"average,omitempty"`

					// Max Maximum TRES usage requested among all tasks
					Max *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"max,omitempty"`

					// Min Minimum TRES usage requested among all tasks
					Min *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"min,omitempty"`

					// Total Total TRES usage requested among all tasks
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"requested,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"steps,omitempty"`

		// SubmitLine Command used to submit the job
		SubmitLine *string `json:"submit_line,omitempty"`
		Time       *struct {
			// Elapsed Elapsed time in seconds
			Elapsed *int32 `json:"elapsed,omitempty"`

			// Eligible Time when the job became eligible to run (UNIX timestamp)
			Eligible *int64 `json:"eligible,omitempty"`

			// End End time (UNIX timestamp)
			End *int64 `json:"end,omitempty"`

			// Limit Maximum run time in minutes
			Limit *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"limit,omitempty"`

			// Planned Time required to start job after becoming eligible to run in seconds
			Planned *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"planned,omitempty"`

			// Start Time execution began (UNIX timestamp)
			Start *int64 `json:"start,omitempty"`

			// Submission Time when the job was submitted (UNIX timestamp)
			Submission *int64 `json:"submission,omitempty"`

			// Suspended Total time in suspended state in seconds
			Suspended *int32 `json:"suspended,omitempty"`
			System    *struct {
				// Microseconds System CPU time used by the job in microseconds
				Microseconds *int64 `json:"microseconds,omitempty"`

				// Seconds System CPU time used by the job in seconds
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"system,omitempty"`
			Total *struct {
				// Microseconds Sum of System and User CPU time used by the job in microseconds
				Microseconds *int64 `json:"microseconds,omitempty"`

				// Seconds Sum of System and User CPU time used by the job in seconds
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"total,omitempty"`
			User *struct {
				// Microseconds User CPU time used by the job in microseconds
				Microseconds *int64 `json:"microseconds,omitempty"`

				// Seconds User CPU time used by the job in seconds
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"user,omitempty"`
		} `json:"time,omitempty"`
		Tres *struct {
			// Allocated Trackable resources allocated to the job
			Allocated *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"allocated,omitempty"`

			// Requested Trackable resources requested by job
			Requested *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"requested,omitempty"`
		} `json:"tres,omitempty"`

		// UsedGres Generic resources used by job
		UsedGres *string `json:"used_gres,omitempty"`

		// User User that owns the job
		User *string `json:"user,omitempty"`

		// Wckey Workload characterization key
		Wckey *struct {
			// Flags Active flags
			Flags []V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags `json:"flags"`

			// Wckey WCKey name
			Wckey string `json:"wckey"`
		} `json:"wckey,omitempty"`

		// WorkingDirectory Path to current working directory
		WorkingDirectory *string `json:"working_directory,omitempty"`
	} `json:"jobs"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.DerivedExitCode.Status.
type V0041OpenapiSlurmdbdJobsRespJobsDerivedExitCodeStatus string

// V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.ExitCode.Status.
type V0041OpenapiSlurmdbdJobsRespJobsExitCodeStatus string

// V0041OpenapiSlurmdbdJobsRespJobsFlags defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.Flags.
type V0041OpenapiSlurmdbdJobsRespJobsFlags string

// V0041OpenapiSlurmdbdJobsRespJobsStateCurrent defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.State.Current.
type V0041OpenapiSlurmdbdJobsRespJobsStateCurrent string

// V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.Steps.ExitCode.Status.
type V0041OpenapiSlurmdbdJobsRespJobsStepsExitCodeStatus string

// V0041OpenapiSlurmdbdJobsRespJobsStepsState defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.Steps.State.
type V0041OpenapiSlurmdbdJobsRespJobsStepsState string

// V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags defines model for V0041OpenapiSlurmdbdJobsResp.Jobs.Wckey.Flags.
type V0041OpenapiSlurmdbdJobsRespJobsWckeyFlags string

// V0041OpenapiSlurmdbdQosResp defines model for v0.0.41_openapi_slurmdbd_qos_resp.
type V0041OpenapiSlurmdbdQosResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Qos List of QOS
	Qos []struct {
		// Description Arbitrary description
		Description *string `json:"description,omitempty"`

		// Flags Flags, to avoid modifying current values specify NOT_SET
		Flags *[]V0041OpenapiSlurmdbdQosRespQosFlags `json:"flags,omitempty"`

		// Id Unique ID
		Id     *int32 `json:"id,omitempty"`
		Limits *struct {
			// Factor LimitFactor
			Factor *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *float64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"factor,omitempty"`

			// GraceTime GraceTime
			GraceTime *int32 `json:"grace_time,omitempty"`
			Max       *struct {
				Accruing *struct {
					Per *struct {
						// Account MaxJobsAccruePerAccount
						Account *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"account,omitempty"`

						// User MaxJobsAccruePerUser
						User *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"accruing,omitempty"`
				ActiveJobs *struct {
					// Accruing GrpJobsAccrue
					Accruing *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"accruing,omitempty"`

					// Count GrpJobs
					Count *struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int32 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"count,omitempty"`
				} `json:"active_jobs,omitempty"`
				Jobs *struct {
					ActiveJobs *struct {
						Per *struct {
							// Account MaxJobsPerAccount
							Account *struct {
								// Infinite True if number has been set to infinite; "set" and "number" will be ignored
								Infinite *bool `json:"infinite,omitempty"`

								// Number If "set" is True the number will be set with value; otherwise ignore number contents
								Number *int32 `json:"number,omitempty"`

								// Set True if number has been set; False if number is unset
								Set *bool `json:"set,omitempty"`
							} `json:"account,omitempty"`

							// User MaxJobsPerUser
							User *struct {
								// Infinite True if number has been set to infinite; "set" and "number" will be ignored
								Infinite *bool `json:"infinite,omitempty"`

								// Number If "set" is True the number will be set with value; otherwise ignore number contents
								Number *int32 `json:"number,omitempty"`

								// Set True if number has been set; False if number is unset
								Set *bool `json:"set,omitempty"`
							} `json:"user,omitempty"`
						} `json:"per,omitempty"`
					} `json:"active_jobs,omitempty"`
					Per *struct {
						// Account MaxSubmitJobsPerAccount
						Account *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"account,omitempty"`

						// User MaxSubmitJobsPerUser
						User *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"jobs,omitempty"`
				Tres *struct {
					Minutes *struct {
						Per *struct {
							// Account MaxTRESRunMinsPerAccount
							Account *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"account,omitempty"`

							// Job MaxTRESMinsPerJob
							Job *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"job,omitempty"`

							// Qos GrpTRESRunMins
							Qos *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"qos,omitempty"`

							// User MaxTRESRunMinsPerUser
							User *[]struct {
								// Count TRES count (0 if listed generically)
								Count *int64 `json:"count,omitempty"`

								// Id ID used in database
								Id *int32 `json:"id,omitempty"`

								// Name TRES name (if applicable)
								Name *string `json:"name,omitempty"`

								// Type TRES type (CPU, MEM, etc)
								Type string `json:"type"`
							} `json:"user,omitempty"`
						} `json:"per,omitempty"`
					} `json:"minutes,omitempty"`
					Per *struct {
						// Account MaxTRESPerAccount
						Account *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"account,omitempty"`

						// Job MaxTRESPerJob
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`

						// Node MaxTRESPerNode
						Node *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"node,omitempty"`

						// User MaxTRESPerUser
						User *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"user,omitempty"`
					} `json:"per,omitempty"`

					// Total GrpTRES
					Total *[]struct {
						// Count TRES count (0 if listed generically)
						Count *int64 `json:"count,omitempty"`

						// Id ID used in database
						Id *int32 `json:"id,omitempty"`

						// Name TRES name (if applicable)
						Name *string `json:"name,omitempty"`

						// Type TRES type (CPU, MEM, etc)
						Type string `json:"type"`
					} `json:"total,omitempty"`
				} `json:"tres,omitempty"`
				WallClock *struct {
					Per *struct {
						// Job MaxWallDurationPerJob
						Job *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"job,omitempty"`

						// Qos GrpWall
						Qos *struct {
							// Infinite True if number has been set to infinite; "set" and "number" will be ignored
							Infinite *bool `json:"infinite,omitempty"`

							// Number If "set" is True the number will be set with value; otherwise ignore number contents
							Number *int32 `json:"number,omitempty"`

							// Set True if number has been set; False if number is unset
							Set *bool `json:"set,omitempty"`
						} `json:"qos,omitempty"`
					} `json:"per,omitempty"`
				} `json:"wall_clock,omitempty"`
			} `json:"max,omitempty"`
			Min *struct {
				// PriorityThreshold MinPrioThreshold
				PriorityThreshold *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"priority_threshold,omitempty"`
				Tres *struct {
					Per *struct {
						// Job MinTRES
						Job *[]struct {
							// Count TRES count (0 if listed generically)
							Count *int64 `json:"count,omitempty"`

							// Id ID used in database
							Id *int32 `json:"id,omitempty"`

							// Name TRES name (if applicable)
							Name *string `json:"name,omitempty"`

							// Type TRES type (CPU, MEM, etc)
							Type string `json:"type"`
						} `json:"job,omitempty"`
					} `json:"per,omitempty"`
				} `json:"tres,omitempty"`
			} `json:"min,omitempty"`
		} `json:"limits,omitempty"`

		// Name Name
		Name    *string `json:"name,omitempty"`
		Preempt *struct {
			// ExemptTime PreemptExemptTime
			ExemptTime *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"exempt_time,omitempty"`

			// List Other QOS's this QOS can preempt
			List *[]string `json:"list,omitempty"`

			// Mode PreemptMode
			Mode *[]V0041OpenapiSlurmdbdQosRespQosPreemptMode `json:"mode,omitempty"`
		} `json:"preempt,omitempty"`

		// Priority Priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// UsageFactor UsageFactor
		UsageFactor *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"usage_factor,omitempty"`

		// UsageThreshold UsageThreshold
		UsageThreshold *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *float64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"usage_threshold,omitempty"`
	} `json:"qos"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiSlurmdbdQosRespQosFlags defines model for V0041OpenapiSlurmdbdQosResp.Qos.Flags.
type V0041OpenapiSlurmdbdQosRespQosFlags string

// V0041OpenapiSlurmdbdQosRespQosPreemptMode defines model for V0041OpenapiSlurmdbdQosResp.Qos.Preempt.Mode.
type V0041OpenapiSlurmdbdQosRespQosPreemptMode string

// V0041OpenapiTresResp defines model for v0.0.41_openapi_tres_resp.
type V0041OpenapiTresResp struct {
	// TRES TRES
	TRES []struct {
		// Count TRES count (0 if listed generically)
		Count *int64 `json:"count,omitempty"`

		// Id ID used in database
		Id *int32 `json:"id,omitempty"`

		// Name TRES name (if applicable)
		Name *string `json:"name,omitempty"`

		// Type TRES type (CPU, MEM, etc)
		Type string `json:"type"`
	} `json:"TRES"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiUsersResp defines model for v0.0.41_openapi_users_resp.
type V0041OpenapiUsersResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Users users
	Users []struct {
		// AdministratorLevel AdminLevel granted to the user
		AdministratorLevel *[]V0041OpenapiUsersRespUsersAdministratorLevel `json:"administrator_level,omitempty"`

		// Associations Associations created for this user
		Associations *[]struct {
			// Account Account
			Account *string `json:"account,omitempty"`

			// Cluster Cluster
			Cluster *string `json:"cluster,omitempty"`

			// Id Numeric association ID
			Id *int32 `json:"id,omitempty"`

			// Partition Partition
			Partition *string `json:"partition,omitempty"`

			// User User name
			User string `json:"user"`
		} `json:"associations,omitempty"`

		// Coordinators Accounts this user is a coordinator for
		Coordinators *[]struct {
			// Direct Indicates whether the coordinator was directly assigned to this account
			Direct *bool `json:"direct,omitempty"`

			// Name User name
			Name string `json:"name"`
		} `json:"coordinators,omitempty"`
		Default *struct {
			// Account Default Account
			Account *string `json:"account,omitempty"`

			// Wckey Default WCKey
			Wckey *string `json:"wckey,omitempty"`
		} `json:"default,omitempty"`

		// Flags Flags associated with user
		Flags *[]V0041OpenapiUsersRespUsersFlags `json:"flags,omitempty"`

		// Name User name
		Name string `json:"name"`

		// OldName Previous user name
		OldName *string `json:"old_name,omitempty"`

		// Wckeys List of available WCKeys
		Wckeys *[]struct {
			// Accounting Accounting records containing related resource usage
			Accounting *[]struct {
				// TRES Trackable resources
				TRES *struct {
					// Count TRES count (0 if listed generically)
					Count *int64 `json:"count,omitempty"`

					// Id ID used in database
					Id *int32 `json:"id,omitempty"`

					// Name TRES name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type TRES type (CPU, MEM, etc)
					Type string `json:"type"`
				} `json:"TRES,omitempty"`
				Allocated *struct {
					// Seconds Number of cpu seconds allocated
					Seconds *int64 `json:"seconds,omitempty"`
				} `json:"allocated,omitempty"`

				// Id Association ID or Workload characterization key ID
				Id *int32 `json:"id,omitempty"`

				// Start When the record was started
				Start *int64 `json:"start,omitempty"`
			} `json:"accounting,omitempty"`

			// Cluster Cluster name
			Cluster string `json:"cluster"`

			// Flags Flags associated with the WCKey
			Flags *[]V0041OpenapiUsersRespUsersWckeysFlags `json:"flags,omitempty"`

			// Id Unique ID for this user-cluster-wckey combination
			Id *int32 `json:"id,omitempty"`

			// Name WCKey name
			Name string `json:"name"`

			// User User name
			User string `json:"user"`
		} `json:"wckeys,omitempty"`
	} `json:"users"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// V0041OpenapiUsersRespUsersAdministratorLevel defines model for V0041OpenapiUsersResp.Users.AdministratorLevel.
type V0041OpenapiUsersRespUsersAdministratorLevel string

// V0041OpenapiUsersRespUsersFlags defines model for V0041OpenapiUsersResp.Users.Flags.
type V0041OpenapiUsersRespUsersFlags string

// V0041OpenapiUsersRespUsersWckeysFlags defines model for V0041OpenapiUsersResp.Users.Wckeys.Flags.
type V0041OpenapiUsersRespUsersWckeysFlags string

// V0041OpenapiWckeyResp defines model for v0.0.41_openapi_wckey_resp.
type V0041OpenapiWckeyResp struct {
	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`

	// Wckeys wckeys
	Wckeys []struct {
		// Accounting Accounting records containing related resource usage
		Accounting *[]struct {
			// TRES Trackable resources
			TRES *struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"TRES,omitempty"`
			Allocated *struct {
				// Seconds Number of cpu seconds allocated
				Seconds *int64 `json:"seconds,omitempty"`
			} `json:"allocated,omitempty"`

			// Id Association ID or Workload characterization key ID
			Id *int32 `json:"id,omitempty"`

			// Start When the record was started
			Start *int64 `json:"start,omitempty"`
		} `json:"accounting,omitempty"`

		// Cluster Cluster name
		Cluster string `json:"cluster"`

		// Flags Flags associated with the WCKey
		Flags *[]V0041OpenapiWckeyRespWckeysFlags `json:"flags,omitempty"`

		// Id Unique ID for this user-cluster-wckey combination
		Id *int32 `json:"id,omitempty"`

		// Name WCKey name
		Name string `json:"name"`

		// User User name
		User string `json:"user"`
	} `json:"wckeys"`
}

// V0041OpenapiWckeyRespWckeysFlags defines model for V0041OpenapiWckeyResp.Wckeys.Flags.
type V0041OpenapiWckeyRespWckeysFlags string

// V0041UpdateNodeMsg defines model for v0.0.41_update_node_msg.
type V0041UpdateNodeMsg struct {
	// Address NodeAddr, used to establish a communication path
	Address *[]string `json:"address,omitempty"`

	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// CpuBind Default method for binding tasks to allocated CPUs
	CpuBind *int32 `json:"cpu_bind,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// Features Available features
	Features *[]string `json:"features,omitempty"`

	// FeaturesAct Currently active features
	FeaturesAct *[]string `json:"features_act,omitempty"`

	// Gres Generic resources
	Gres *string `json:"gres,omitempty"`

	// Hostname NodeHostname
	Hostname *[]string `json:"hostname,omitempty"`

	// Name NodeName
	Name *[]string `json:"name,omitempty"`

	// Reason Reason for node being DOWN or DRAINING
	Reason *string `json:"reason,omitempty"`

	// ReasonUid User ID to associate with the reason (needed if user root is sending message)
	ReasonUid *string `json:"reason_uid,omitempty"`

	// ResumeAfter Number of seconds after which to automatically resume DOWN or DRAINED node
	ResumeAfter *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"resume_after,omitempty"`

	// State New state to assign to the node
	State *[]V0041UpdateNodeMsgState `json:"state,omitempty"`

	// Weight Weight of the node for scheduling purposes
	Weight *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"weight,omitempty"`
}

// V0041UpdateNodeMsgState defines model for V0041UpdateNodeMsg.State.
type V0041UpdateNodeMsgState string

// SlurmV0041PostJobAllocateJSONBody defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBody struct {
	// Hetjob HetJob description
	Hetjob *[]struct {
		// Account Account associated with the job
		Account *string `json:"account,omitempty"`

		// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
		AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

		// AdminComment Arbitrary comment made by administrator
		AdminComment *string `json:"admin_comment,omitempty"`

		// AllocationNodeList Local node making the resource allocation
		AllocationNodeList *string `json:"allocation_node_list,omitempty"`

		// AllocationNodePort Port to send allocation confirmation to
		AllocationNodePort *int32 `json:"allocation_node_port,omitempty"`

		// Argv Arguments to the script
		Argv *[]string `json:"argv,omitempty"`

		// Array Job array index value specification
		Array *string `json:"array,omitempty"`

		// BatchFeatures Features required for batch script's node
		BatchFeatures *string `json:"batch_features,omitempty"`

		// BeginTime Defer the allocation of the job until the specified time (UNIX timestamp)
		BeginTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"begin_time,omitempty"`

		// BurstBuffer Burst buffer specifications
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
		ClusterConstraint *string `json:"cluster_constraint,omitempty"`

		// Clusters Clusters that a federated job can run on
		Clusters *string `json:"clusters,omitempty"`

		// Comment Arbitrary comment made by user
		Comment *string `json:"comment,omitempty"`

		// Constraints Comma separated list of features that are required
		Constraints *string `json:"constraints,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// ContainerId OCI container ID
		ContainerId *string `json:"container_id,omitempty"`

		// Contiguous True if job requires contiguous nodes
		Contiguous *bool `json:"contiguous,omitempty"`

		// CoreSpecification Specialized core count
		CoreSpecification *int32 `json:"core_specification,omitempty"`

		// CpuBinding Method for binding tasks to allocated CPUs
		CpuBinding *string `json:"cpu_binding,omitempty"`

		// CpuBindingFlags Flags for CPU binding
		CpuBindingFlags *[]SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

		// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
		CpuFrequency *string `json:"cpu_frequency,omitempty"`

		// CpusPerTask Number of CPUs required by each task
		CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

		// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
		CpusPerTres *string `json:"cpus_per_tres,omitempty"`

		// Crontab Specification for scrontab job
		Crontab *struct {
			// Command Command to run
			Command *string `json:"command,omitempty"`

			// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
			DayOfMonth *string `json:"day_of_month,omitempty"`

			// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
			DayOfWeek *string `json:"day_of_week,omitempty"`

			// Flags Flags
			Flags *[]SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags `json:"flags,omitempty"`

			// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
			Hour *string `json:"hour,omitempty"`
			Line *struct {
				// End End of this entry in file
				End *int32 `json:"end,omitempty"`

				// Start Start of this entry in file
				Start *int32 `json:"start,omitempty"`
			} `json:"line,omitempty"`

			// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
			Minute *string `json:"minute,omitempty"`

			// Month Ranged string specifying eligible month values (e.g. 0-5,12)
			Month *string `json:"month,omitempty"`

			// Specification Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
			Specification *string `json:"specification,omitempty"`
		} `json:"crontab,omitempty"`

		// CurrentWorkingDirectory Working directory to use for the job
		CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

		// Deadline Latest time that the job may start (UNIX timestamp)
		Deadline *int64 `json:"deadline,omitempty"`

		// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
		DelayBoot *int32 `json:"delay_boot,omitempty"`

		// Dependency Other jobs that must meet certain criteria before this job can start
		Dependency *string `json:"dependency,omitempty"`

		// Distribution Layout
		Distribution *string `json:"distribution,omitempty"`

		// DistributionPlaneSize Plane size specification when distribution specifies plane
		DistributionPlaneSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"distribution_plane_size,omitempty"`

		// EndTime Expected end time (UNIX timestamp)
		EndTime *int64 `json:"end_time,omitempty"`

		// Environment Environment variables to be set for the job
		Environment *[]string `json:"environment,omitempty"`

		// ExcludedNodes Comma separated list of nodes that may not be used
		ExcludedNodes *[]string `json:"excluded_nodes,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Exclusive *[]SlurmV0041PostJobAllocateJSONBodyHetjobExclusive `json:"exclusive,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// Flags Job flags
		Flags *[]SlurmV0041PostJobAllocateJSONBodyHetjobFlags `json:"flags,omitempty"`

		// GroupId Group ID of the user that owns the job
		GroupId *string `json:"group_id,omitempty"`

		// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
		HetjobGroup *int32 `json:"hetjob_group,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// Immediate If true, exit if resources are not available within the time period specified
		Immediate *bool `json:"immediate,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// KillOnNodeFail If true, kill job on node failure
		KillOnNodeFail *bool `json:"kill_on_node_fail,omitempty"`

		// KillWarningDelay Number of seconds before end time to send the warning signal
		KillWarningDelay *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"kill_warning_delay,omitempty"`

		// KillWarningFlags Flags related to job signals
		KillWarningFlags *[]SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags `json:"kill_warning_flags,omitempty"`

		// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
		KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`

		// MailType Mail event type(s)
		MailType *[]SlurmV0041PostJobAllocateJSONBodyHetjobMailType `json:"mail_type,omitempty"`

		// MailUser User to receive email notifications
		MailUser *string `json:"mail_user,omitempty"`

		// MaximumCpus Maximum number of CPUs required
		MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

		// MaximumNodes Maximum node count
		MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

		// McsLabel Multi-Category Security label on the job
		McsLabel *string `json:"mcs_label,omitempty"`

		// MemoryBinding Binding map for map/mask_cpu
		MemoryBinding *string `json:"memory_binding,omitempty"`

		// MemoryBindingType Method for binding tasks to memory
		MemoryBindingType *[]SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType `json:"memory_binding_type,omitempty"`

		// MemoryPerCpu Minimum memory in megabytes per allocated CPU
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Minimum memory in megabytes per allocated CPU
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`

		// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
		MemoryPerTres *string `json:"memory_per_tres,omitempty"`

		// MinimumBoardsPerNode Boards per node required
		MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

		// MinimumCpus Minimum number of CPUs required
		MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

		// MinimumCpusPerNode Minimum number of CPUs per node
		MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

		// MinimumNodes Minimum node count
		MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

		// MinimumSocketsPerBoard Sockets per board required
		MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Network Network specs for job step
		Network *string `json:"network,omitempty"`

		// Nice Requested job priority change
		Nice *int32 `json:"nice,omitempty"`

		// Nodes Node count range specification (e.g. 1-15:4)
		Nodes *string `json:"nodes,omitempty"`

		// NtasksPerTres Number of tasks that can access each GPU
		NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

		// OpenMode Open mode used for stdout and stderr files
		OpenMode *[]SlurmV0041PostJobAllocateJSONBodyHetjobOpenMode `json:"open_mode,omitempty"`

		// Overcommit Overcommit resources
		Overcommit *bool `json:"overcommit,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Oversubscribe *bool `json:"oversubscribe,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		PowerFlags *[]interface{} `json:"power_flags,omitempty"`

		// Prefer Comma separated list of features that are preferred but not required
		Prefer *string `json:"prefer,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Profile Profile used by the acct_gather_profile plugin
		Profile *[]SlurmV0041PostJobAllocateJSONBodyHetjobProfile `json:"profile,omitempty"`

		// Qos Quality of Service assigned to the job
		Qos *string `json:"qos,omitempty"`

		// Reboot Node reboot requested before start
		Reboot *bool `json:"reboot,omitempty"`

		// Requeue Determines whether the job may be requeued
		Requeue *bool `json:"requeue,omitempty"`

		// RequiredNodes Comma separated list of required nodes
		RequiredNodes *[]string `json:"required_nodes,omitempty"`

		// RequiredSwitches Maximum number of switches
		RequiredSwitches *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"required_switches,omitempty"`

		// Reservation Name of reservation to use
		Reservation *string `json:"reservation,omitempty"`

		// ReservePorts Port to send various notification msg to
		ReservePorts *int32 `json:"reserve_ports,omitempty"`

		// ResvMpiPorts Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
		ResvMpiPorts *int32 `json:"resv_mpi_ports,omitempty"`
		Rlimits      *struct {
			// As Address space limit.
			As *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"as,omitempty"`

			// Core Largest core file that can be created, in bytes.
			Core *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"core,omitempty"`

			// Cpu Per-process CPU limit, in seconds.
			Cpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu,omitempty"`

			// Data Maximum size of data segment, in bytes.
			Data *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"data,omitempty"`

			// Fsize Largest file that can be created, in bytes.
			Fsize *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"fsize,omitempty"`

			// Memlock Locked-in-memory address space
			Memlock *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memlock,omitempty"`

			// Nofile Number of open files.
			Nofile *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nofile,omitempty"`

			// Nproc Number of processes.
			Nproc *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nproc,omitempty"`

			// Rss Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size will be more likely to have physical memory taken from them.
			Rss *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"rss,omitempty"`

			// Stack Maximum size of stack segment, in bytes.
			Stack *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"stack,omitempty"`
		} `json:"rlimits,omitempty"`

		// Script Job batch script; only the first component in a HetJob is populated or honored
		Script *string `json:"script,omitempty"`

		// SegmentSize Segment size for topology/block
		SegmentSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"segment_size,omitempty"`

		// SelinuxContext SELinux context
		SelinuxContext *string `json:"selinux_context,omitempty"`

		// Shared How the job can share resources with other jobs, if at all
		Shared *[]SlurmV0041PostJobAllocateJSONBodyHetjobShared `json:"shared,omitempty"`

		// SiteFactor Site-specific priority factor
		SiteFactor *int32 `json:"site_factor,omitempty"`

		// SocketsPerNode Sockets per node required
		SocketsPerNode *int32 `json:"sockets_per_node,omitempty"`

		// SpankEnvironment Environment variables for job prolog/epilog scripts as set by SPANK plugins
		SpankEnvironment *[]string `json:"spank_environment,omitempty"`

		// StandardError Path to stderr file
		StandardError *string `json:"standard_error,omitempty"`

		// StandardInput Path to stdin file
		StandardInput *string `json:"standard_input,omitempty"`

		// StandardOutput Path to stdout file
		StandardOutput *string `json:"standard_output,omitempty"`

		// Tasks Number of tasks
		Tasks *int32 `json:"tasks,omitempty"`

		// TasksPerBoard Number of tasks to invoke on each board
		TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

		// TasksPerCore Number of tasks to invoke on each core
		TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

		// TasksPerNode Number of tasks to invoke on each node
		TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

		// TasksPerSocket Number of tasks to invoke on each socket
		TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

		// TemporaryDiskPerNode Minimum tmp disk space required per node
		TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

		// ThreadSpecification Specialized thread count
		ThreadSpecification *int32 `json:"thread_specification,omitempty"`

		// ThreadsPerCore Threads per core required
		ThreadsPerCore *int32 `json:"threads_per_core,omitempty"`

		// TimeLimit Maximum run time in minutes
		TimeLimit *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Minimum run time in minutes
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`

		// TresBind Task to TRES binding directives
		TresBind *string `json:"tres_bind,omitempty"`

		// TresFreq TRES frequency directives
		TresFreq *string `json:"tres_freq,omitempty"`

		// TresPerJob Comma separated list of TRES=# values to be allocated for every job
		TresPerJob *string `json:"tres_per_job,omitempty"`

		// TresPerNode Comma separated list of TRES=# values to be allocated for every node
		TresPerNode *string `json:"tres_per_node,omitempty"`

		// TresPerSocket Comma separated list of TRES=# values to be allocated for every socket
		TresPerSocket *string `json:"tres_per_socket,omitempty"`

		// TresPerTask Comma separated list of TRES=# values to be allocated for every task
		TresPerTask *string `json:"tres_per_task,omitempty"`

		// UserId User ID that owns the job
		UserId *string `json:"user_id,omitempty"`

		// WaitAllNodes If true, wait to start until after all nodes have booted
		WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

		// WaitForSwitch Maximum time to wait for switches in seconds
		WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

		// Wckey Workload characterization key
		Wckey *string `json:"wckey,omitempty"`

		// X11 X11 forwarding options
		X11 *[]SlurmV0041PostJobAllocateJSONBodyHetjobX11 `json:"x11,omitempty"`

		// X11MagicCookie Magic cookie for X11 forwarding
		X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

		// X11TargetHost Hostname or UNIX socket if x11_target_port=0
		X11TargetHost *string `json:"x11_target_host,omitempty"`

		// X11TargetPort TCP port
		X11TargetPort *int32 `json:"x11_target_port,omitempty"`
	} `json:"hetjob,omitempty"`

	// Job Job description
	Job *struct {
		// Account Account associated with the job
		Account *string `json:"account,omitempty"`

		// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
		AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

		// AdminComment Arbitrary comment made by administrator
		AdminComment *string `json:"admin_comment,omitempty"`

		// AllocationNodeList Local node making the resource allocation
		AllocationNodeList *string `json:"allocation_node_list,omitempty"`

		// AllocationNodePort Port to send allocation confirmation to
		AllocationNodePort *int32 `json:"allocation_node_port,omitempty"`

		// Argv Arguments to the script
		Argv *[]string `json:"argv,omitempty"`

		// Array Job array index value specification
		Array *string `json:"array,omitempty"`

		// BatchFeatures Features required for batch script's node
		BatchFeatures *string `json:"batch_features,omitempty"`

		// BeginTime Defer the allocation of the job until the specified time (UNIX timestamp)
		BeginTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"begin_time,omitempty"`

		// BurstBuffer Burst buffer specifications
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
		ClusterConstraint *string `json:"cluster_constraint,omitempty"`

		// Clusters Clusters that a federated job can run on
		Clusters *string `json:"clusters,omitempty"`

		// Comment Arbitrary comment made by user
		Comment *string `json:"comment,omitempty"`

		// Constraints Comma separated list of features that are required
		Constraints *string `json:"constraints,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// ContainerId OCI container ID
		ContainerId *string `json:"container_id,omitempty"`

		// Contiguous True if job requires contiguous nodes
		Contiguous *bool `json:"contiguous,omitempty"`

		// CoreSpecification Specialized core count
		CoreSpecification *int32 `json:"core_specification,omitempty"`

		// CpuBinding Method for binding tasks to allocated CPUs
		CpuBinding *string `json:"cpu_binding,omitempty"`

		// CpuBindingFlags Flags for CPU binding
		CpuBindingFlags *[]SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

		// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
		CpuFrequency *string `json:"cpu_frequency,omitempty"`

		// CpusPerTask Number of CPUs required by each task
		CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

		// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
		CpusPerTres *string `json:"cpus_per_tres,omitempty"`

		// Crontab Specification for scrontab job
		Crontab *struct {
			// Command Command to run
			Command *string `json:"command,omitempty"`

			// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
			DayOfMonth *string `json:"day_of_month,omitempty"`

			// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
			DayOfWeek *string `json:"day_of_week,omitempty"`

			// Flags Flags
			Flags *[]SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags `json:"flags,omitempty"`

			// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
			Hour *string `json:"hour,omitempty"`
			Line *struct {
				// End End of this entry in file
				End *int32 `json:"end,omitempty"`

				// Start Start of this entry in file
				Start *int32 `json:"start,omitempty"`
			} `json:"line,omitempty"`

			// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
			Minute *string `json:"minute,omitempty"`

			// Month Ranged string specifying eligible month values (e.g. 0-5,12)
			Month *string `json:"month,omitempty"`

			// Specification Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
			Specification *string `json:"specification,omitempty"`
		} `json:"crontab,omitempty"`

		// CurrentWorkingDirectory Working directory to use for the job
		CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

		// Deadline Latest time that the job may start (UNIX timestamp)
		Deadline *int64 `json:"deadline,omitempty"`

		// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
		DelayBoot *int32 `json:"delay_boot,omitempty"`

		// Dependency Other jobs that must meet certain criteria before this job can start
		Dependency *string `json:"dependency,omitempty"`

		// Distribution Layout
		Distribution *string `json:"distribution,omitempty"`

		// DistributionPlaneSize Plane size specification when distribution specifies plane
		DistributionPlaneSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"distribution_plane_size,omitempty"`

		// EndTime Expected end time (UNIX timestamp)
		EndTime *int64 `json:"end_time,omitempty"`

		// Environment Environment variables to be set for the job
		Environment *[]string `json:"environment,omitempty"`

		// ExcludedNodes Comma separated list of nodes that may not be used
		ExcludedNodes *[]string `json:"excluded_nodes,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Exclusive *[]SlurmV0041PostJobAllocateJSONBodyJobExclusive `json:"exclusive,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// Flags Job flags
		Flags *[]SlurmV0041PostJobAllocateJSONBodyJobFlags `json:"flags,omitempty"`

		// GroupId Group ID of the user that owns the job
		GroupId *string `json:"group_id,omitempty"`

		// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
		HetjobGroup *int32 `json:"hetjob_group,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// Immediate If true, exit if resources are not available within the time period specified
		Immediate *bool `json:"immediate,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// KillOnNodeFail If true, kill job on node failure
		KillOnNodeFail *bool `json:"kill_on_node_fail,omitempty"`

		// KillWarningDelay Number of seconds before end time to send the warning signal
		KillWarningDelay *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"kill_warning_delay,omitempty"`

		// KillWarningFlags Flags related to job signals
		KillWarningFlags *[]SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags `json:"kill_warning_flags,omitempty"`

		// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
		KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`

		// MailType Mail event type(s)
		MailType *[]SlurmV0041PostJobAllocateJSONBodyJobMailType `json:"mail_type,omitempty"`

		// MailUser User to receive email notifications
		MailUser *string `json:"mail_user,omitempty"`

		// MaximumCpus Maximum number of CPUs required
		MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

		// MaximumNodes Maximum node count
		MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

		// McsLabel Multi-Category Security label on the job
		McsLabel *string `json:"mcs_label,omitempty"`

		// MemoryBinding Binding map for map/mask_cpu
		MemoryBinding *string `json:"memory_binding,omitempty"`

		// MemoryBindingType Method for binding tasks to memory
		MemoryBindingType *[]SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType `json:"memory_binding_type,omitempty"`

		// MemoryPerCpu Minimum memory in megabytes per allocated CPU
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Minimum memory in megabytes per allocated CPU
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`

		// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
		MemoryPerTres *string `json:"memory_per_tres,omitempty"`

		// MinimumBoardsPerNode Boards per node required
		MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

		// MinimumCpus Minimum number of CPUs required
		MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

		// MinimumCpusPerNode Minimum number of CPUs per node
		MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

		// MinimumNodes Minimum node count
		MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

		// MinimumSocketsPerBoard Sockets per board required
		MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Network Network specs for job step
		Network *string `json:"network,omitempty"`

		// Nice Requested job priority change
		Nice *int32 `json:"nice,omitempty"`

		// Nodes Node count range specification (e.g. 1-15:4)
		Nodes *string `json:"nodes,omitempty"`

		// NtasksPerTres Number of tasks that can access each GPU
		NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

		// OpenMode Open mode used for stdout and stderr files
		OpenMode *[]SlurmV0041PostJobAllocateJSONBodyJobOpenMode `json:"open_mode,omitempty"`

		// Overcommit Overcommit resources
		Overcommit *bool `json:"overcommit,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Oversubscribe *bool `json:"oversubscribe,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		PowerFlags *[]interface{} `json:"power_flags,omitempty"`

		// Prefer Comma separated list of features that are preferred but not required
		Prefer *string `json:"prefer,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Profile Profile used by the acct_gather_profile plugin
		Profile *[]SlurmV0041PostJobAllocateJSONBodyJobProfile `json:"profile,omitempty"`

		// Qos Quality of Service assigned to the job
		Qos *string `json:"qos,omitempty"`

		// Reboot Node reboot requested before start
		Reboot *bool `json:"reboot,omitempty"`

		// Requeue Determines whether the job may be requeued
		Requeue *bool `json:"requeue,omitempty"`

		// RequiredNodes Comma separated list of required nodes
		RequiredNodes *[]string `json:"required_nodes,omitempty"`

		// RequiredSwitches Maximum number of switches
		RequiredSwitches *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"required_switches,omitempty"`

		// Reservation Name of reservation to use
		Reservation *string `json:"reservation,omitempty"`

		// ReservePorts Port to send various notification msg to
		ReservePorts *int32 `json:"reserve_ports,omitempty"`

		// ResvMpiPorts Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
		ResvMpiPorts *int32 `json:"resv_mpi_ports,omitempty"`
		Rlimits      *struct {
			// As Address space limit.
			As *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"as,omitempty"`

			// Core Largest core file that can be created, in bytes.
			Core *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"core,omitempty"`

			// Cpu Per-process CPU limit, in seconds.
			Cpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu,omitempty"`

			// Data Maximum size of data segment, in bytes.
			Data *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"data,omitempty"`

			// Fsize Largest file that can be created, in bytes.
			Fsize *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"fsize,omitempty"`

			// Memlock Locked-in-memory address space
			Memlock *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memlock,omitempty"`

			// Nofile Number of open files.
			Nofile *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nofile,omitempty"`

			// Nproc Number of processes.
			Nproc *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nproc,omitempty"`

			// Rss Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size will be more likely to have physical memory taken from them.
			Rss *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"rss,omitempty"`

			// Stack Maximum size of stack segment, in bytes.
			Stack *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"stack,omitempty"`
		} `json:"rlimits,omitempty"`

		// Script Job batch script; only the first component in a HetJob is populated or honored
		Script *string `json:"script,omitempty"`

		// SegmentSize Segment size for topology/block
		SegmentSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"segment_size,omitempty"`

		// SelinuxContext SELinux context
		SelinuxContext *string `json:"selinux_context,omitempty"`

		// Shared How the job can share resources with other jobs, if at all
		Shared *[]SlurmV0041PostJobAllocateJSONBodyJobShared `json:"shared,omitempty"`

		// SiteFactor Site-specific priority factor
		SiteFactor *int32 `json:"site_factor,omitempty"`

		// SocketsPerNode Sockets per node required
		SocketsPerNode *int32 `json:"sockets_per_node,omitempty"`

		// SpankEnvironment Environment variables for job prolog/epilog scripts as set by SPANK plugins
		SpankEnvironment *[]string `json:"spank_environment,omitempty"`

		// StandardError Path to stderr file
		StandardError *string `json:"standard_error,omitempty"`

		// StandardInput Path to stdin file
		StandardInput *string `json:"standard_input,omitempty"`

		// StandardOutput Path to stdout file
		StandardOutput *string `json:"standard_output,omitempty"`

		// Tasks Number of tasks
		Tasks *int32 `json:"tasks,omitempty"`

		// TasksPerBoard Number of tasks to invoke on each board
		TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

		// TasksPerCore Number of tasks to invoke on each core
		TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

		// TasksPerNode Number of tasks to invoke on each node
		TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

		// TasksPerSocket Number of tasks to invoke on each socket
		TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

		// TemporaryDiskPerNode Minimum tmp disk space required per node
		TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

		// ThreadSpecification Specialized thread count
		ThreadSpecification *int32 `json:"thread_specification,omitempty"`

		// ThreadsPerCore Threads per core required
		ThreadsPerCore *int32 `json:"threads_per_core,omitempty"`

		// TimeLimit Maximum run time in minutes
		TimeLimit *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Minimum run time in minutes
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`

		// TresBind Task to TRES binding directives
		TresBind *string `json:"tres_bind,omitempty"`

		// TresFreq TRES frequency directives
		TresFreq *string `json:"tres_freq,omitempty"`

		// TresPerJob Comma separated list of TRES=# values to be allocated for every job
		TresPerJob *string `json:"tres_per_job,omitempty"`

		// TresPerNode Comma separated list of TRES=# values to be allocated for every node
		TresPerNode *string `json:"tres_per_node,omitempty"`

		// TresPerSocket Comma separated list of TRES=# values to be allocated for every socket
		TresPerSocket *string `json:"tres_per_socket,omitempty"`

		// TresPerTask Comma separated list of TRES=# values to be allocated for every task
		TresPerTask *string `json:"tres_per_task,omitempty"`

		// UserId User ID that owns the job
		UserId *string `json:"user_id,omitempty"`

		// WaitAllNodes If true, wait to start until after all nodes have booted
		WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

		// WaitForSwitch Maximum time to wait for switches in seconds
		WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

		// Wckey Workload characterization key
		Wckey *string `json:"wckey,omitempty"`

		// X11 X11 forwarding options
		X11 *[]SlurmV0041PostJobAllocateJSONBodyJobX11 `json:"x11,omitempty"`

		// X11MagicCookie Magic cookie for X11 forwarding
		X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

		// X11TargetHost Hostname or UNIX socket if x11_target_port=0
		X11TargetHost *string `json:"x11_target_host,omitempty"`

		// X11TargetPort TCP port
		X11TargetPort *int32 `json:"x11_target_port,omitempty"`
	} `json:"job,omitempty"`
}

// SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobCpuBindingFlags string

// SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobCrontabFlags string

// SlurmV0041PostJobAllocateJSONBodyHetjobExclusive defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobExclusive string

// SlurmV0041PostJobAllocateJSONBodyHetjobFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobFlags string

// SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobKillWarningFlags string

// SlurmV0041PostJobAllocateJSONBodyHetjobMailType defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobMailType string

// SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobMemoryBindingType string

// SlurmV0041PostJobAllocateJSONBodyHetjobOpenMode defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobOpenMode string

// SlurmV0041PostJobAllocateJSONBodyHetjobProfile defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobProfile string

// SlurmV0041PostJobAllocateJSONBodyHetjobShared defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobShared string

// SlurmV0041PostJobAllocateJSONBodyHetjobX11 defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyHetjobX11 string

// SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobCpuBindingFlags string

// SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobCrontabFlags string

// SlurmV0041PostJobAllocateJSONBodyJobExclusive defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobExclusive string

// SlurmV0041PostJobAllocateJSONBodyJobFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobFlags string

// SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobKillWarningFlags string

// SlurmV0041PostJobAllocateJSONBodyJobMailType defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobMailType string

// SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobMemoryBindingType string

// SlurmV0041PostJobAllocateJSONBodyJobOpenMode defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobOpenMode string

// SlurmV0041PostJobAllocateJSONBodyJobProfile defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobProfile string

// SlurmV0041PostJobAllocateJSONBodyJobShared defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobShared string

// SlurmV0041PostJobAllocateJSONBodyJobX11 defines parameters for SlurmV0041PostJobAllocate.
type SlurmV0041PostJobAllocateJSONBodyJobX11 string

// SlurmV0041PostJobSubmitJSONBody defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBody struct {
	// Job Job description
	Job *struct {
		// Account Account associated with the job
		Account *string `json:"account,omitempty"`

		// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
		AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

		// AdminComment Arbitrary comment made by administrator
		AdminComment *string `json:"admin_comment,omitempty"`

		// AllocationNodeList Local node making the resource allocation
		AllocationNodeList *string `json:"allocation_node_list,omitempty"`

		// AllocationNodePort Port to send allocation confirmation to
		AllocationNodePort *int32 `json:"allocation_node_port,omitempty"`

		// Argv Arguments to the script
		Argv *[]string `json:"argv,omitempty"`

		// Array Job array index value specification
		Array *string `json:"array,omitempty"`

		// BatchFeatures Features required for batch script's node
		BatchFeatures *string `json:"batch_features,omitempty"`

		// BeginTime Defer the allocation of the job until the specified time (UNIX timestamp)
		BeginTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"begin_time,omitempty"`

		// BurstBuffer Burst buffer specifications
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
		ClusterConstraint *string `json:"cluster_constraint,omitempty"`

		// Clusters Clusters that a federated job can run on
		Clusters *string `json:"clusters,omitempty"`

		// Comment Arbitrary comment made by user
		Comment *string `json:"comment,omitempty"`

		// Constraints Comma separated list of features that are required
		Constraints *string `json:"constraints,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// ContainerId OCI container ID
		ContainerId *string `json:"container_id,omitempty"`

		// Contiguous True if job requires contiguous nodes
		Contiguous *bool `json:"contiguous,omitempty"`

		// CoreSpecification Specialized core count
		CoreSpecification *int32 `json:"core_specification,omitempty"`

		// CpuBinding Method for binding tasks to allocated CPUs
		CpuBinding *string `json:"cpu_binding,omitempty"`

		// CpuBindingFlags Flags for CPU binding
		CpuBindingFlags *[]SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

		// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
		CpuFrequency *string `json:"cpu_frequency,omitempty"`

		// CpusPerTask Number of CPUs required by each task
		CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

		// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
		CpusPerTres *string `json:"cpus_per_tres,omitempty"`

		// Crontab Specification for scrontab job
		Crontab *struct {
			// Command Command to run
			Command *string `json:"command,omitempty"`

			// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
			DayOfMonth *string `json:"day_of_month,omitempty"`

			// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
			DayOfWeek *string `json:"day_of_week,omitempty"`

			// Flags Flags
			Flags *[]SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags `json:"flags,omitempty"`

			// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
			Hour *string `json:"hour,omitempty"`
			Line *struct {
				// End End of this entry in file
				End *int32 `json:"end,omitempty"`

				// Start Start of this entry in file
				Start *int32 `json:"start,omitempty"`
			} `json:"line,omitempty"`

			// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
			Minute *string `json:"minute,omitempty"`

			// Month Ranged string specifying eligible month values (e.g. 0-5,12)
			Month *string `json:"month,omitempty"`

			// Specification Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
			Specification *string `json:"specification,omitempty"`
		} `json:"crontab,omitempty"`

		// CurrentWorkingDirectory Working directory to use for the job
		CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

		// Deadline Latest time that the job may start (UNIX timestamp)
		Deadline *int64 `json:"deadline,omitempty"`

		// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
		DelayBoot *int32 `json:"delay_boot,omitempty"`

		// Dependency Other jobs that must meet certain criteria before this job can start
		Dependency *string `json:"dependency,omitempty"`

		// Distribution Layout
		Distribution *string `json:"distribution,omitempty"`

		// DistributionPlaneSize Plane size specification when distribution specifies plane
		DistributionPlaneSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"distribution_plane_size,omitempty"`

		// EndTime Expected end time (UNIX timestamp)
		EndTime *int64 `json:"end_time,omitempty"`

		// Environment Environment variables to be set for the job
		Environment *[]string `json:"environment,omitempty"`

		// ExcludedNodes Comma separated list of nodes that may not be used
		ExcludedNodes *[]string `json:"excluded_nodes,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Exclusive *[]SlurmV0041PostJobSubmitJSONBodyJobExclusive `json:"exclusive,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// Flags Job flags
		Flags *[]SlurmV0041PostJobSubmitJSONBodyJobFlags `json:"flags,omitempty"`

		// GroupId Group ID of the user that owns the job
		GroupId *string `json:"group_id,omitempty"`

		// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
		HetjobGroup *int32 `json:"hetjob_group,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// Immediate If true, exit if resources are not available within the time period specified
		Immediate *bool `json:"immediate,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// KillOnNodeFail If true, kill job on node failure
		KillOnNodeFail *bool `json:"kill_on_node_fail,omitempty"`

		// KillWarningDelay Number of seconds before end time to send the warning signal
		KillWarningDelay *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"kill_warning_delay,omitempty"`

		// KillWarningFlags Flags related to job signals
		KillWarningFlags *[]SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags `json:"kill_warning_flags,omitempty"`

		// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
		KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`

		// MailType Mail event type(s)
		MailType *[]SlurmV0041PostJobSubmitJSONBodyJobMailType `json:"mail_type,omitempty"`

		// MailUser User to receive email notifications
		MailUser *string `json:"mail_user,omitempty"`

		// MaximumCpus Maximum number of CPUs required
		MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

		// MaximumNodes Maximum node count
		MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

		// McsLabel Multi-Category Security label on the job
		McsLabel *string `json:"mcs_label,omitempty"`

		// MemoryBinding Binding map for map/mask_cpu
		MemoryBinding *string `json:"memory_binding,omitempty"`

		// MemoryBindingType Method for binding tasks to memory
		MemoryBindingType *[]SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType `json:"memory_binding_type,omitempty"`

		// MemoryPerCpu Minimum memory in megabytes per allocated CPU
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Minimum memory in megabytes per allocated CPU
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`

		// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
		MemoryPerTres *string `json:"memory_per_tres,omitempty"`

		// MinimumBoardsPerNode Boards per node required
		MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

		// MinimumCpus Minimum number of CPUs required
		MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

		// MinimumCpusPerNode Minimum number of CPUs per node
		MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

		// MinimumNodes Minimum node count
		MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

		// MinimumSocketsPerBoard Sockets per board required
		MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Network Network specs for job step
		Network *string `json:"network,omitempty"`

		// Nice Requested job priority change
		Nice *int32 `json:"nice,omitempty"`

		// Nodes Node count range specification (e.g. 1-15:4)
		Nodes *string `json:"nodes,omitempty"`

		// NtasksPerTres Number of tasks that can access each GPU
		NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

		// OpenMode Open mode used for stdout and stderr files
		OpenMode *[]SlurmV0041PostJobSubmitJSONBodyJobOpenMode `json:"open_mode,omitempty"`

		// Overcommit Overcommit resources
		Overcommit *bool `json:"overcommit,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Oversubscribe *bool `json:"oversubscribe,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		PowerFlags *[]interface{} `json:"power_flags,omitempty"`

		// Prefer Comma separated list of features that are preferred but not required
		Prefer *string `json:"prefer,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Profile Profile used by the acct_gather_profile plugin
		Profile *[]SlurmV0041PostJobSubmitJSONBodyJobProfile `json:"profile,omitempty"`

		// Qos Quality of Service assigned to the job
		Qos *string `json:"qos,omitempty"`

		// Reboot Node reboot requested before start
		Reboot *bool `json:"reboot,omitempty"`

		// Requeue Determines whether the job may be requeued
		Requeue *bool `json:"requeue,omitempty"`

		// RequiredNodes Comma separated list of required nodes
		RequiredNodes *[]string `json:"required_nodes,omitempty"`

		// RequiredSwitches Maximum number of switches
		RequiredSwitches *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"required_switches,omitempty"`

		// Reservation Name of reservation to use
		Reservation *string `json:"reservation,omitempty"`

		// ReservePorts Port to send various notification msg to
		ReservePorts *int32 `json:"reserve_ports,omitempty"`

		// ResvMpiPorts Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
		ResvMpiPorts *int32 `json:"resv_mpi_ports,omitempty"`
		Rlimits      *struct {
			// As Address space limit.
			As *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"as,omitempty"`

			// Core Largest core file that can be created, in bytes.
			Core *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"core,omitempty"`

			// Cpu Per-process CPU limit, in seconds.
			Cpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu,omitempty"`

			// Data Maximum size of data segment, in bytes.
			Data *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"data,omitempty"`

			// Fsize Largest file that can be created, in bytes.
			Fsize *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"fsize,omitempty"`

			// Memlock Locked-in-memory address space
			Memlock *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memlock,omitempty"`

			// Nofile Number of open files.
			Nofile *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nofile,omitempty"`

			// Nproc Number of processes.
			Nproc *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nproc,omitempty"`

			// Rss Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size will be more likely to have physical memory taken from them.
			Rss *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"rss,omitempty"`

			// Stack Maximum size of stack segment, in bytes.
			Stack *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"stack,omitempty"`
		} `json:"rlimits,omitempty"`

		// Script Job batch script; only the first component in a HetJob is populated or honored
		Script *string `json:"script,omitempty"`

		// SegmentSize Segment size for topology/block
		SegmentSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"segment_size,omitempty"`

		// SelinuxContext SELinux context
		SelinuxContext *string `json:"selinux_context,omitempty"`

		// Shared How the job can share resources with other jobs, if at all
		Shared *[]SlurmV0041PostJobSubmitJSONBodyJobShared `json:"shared,omitempty"`

		// SiteFactor Site-specific priority factor
		SiteFactor *int32 `json:"site_factor,omitempty"`

		// SocketsPerNode Sockets per node required
		SocketsPerNode *int32 `json:"sockets_per_node,omitempty"`

		// SpankEnvironment Environment variables for job prolog/epilog scripts as set by SPANK plugins
		SpankEnvironment *[]string `json:"spank_environment,omitempty"`

		// StandardError Path to stderr file
		StandardError *string `json:"standard_error,omitempty"`

		// StandardInput Path to stdin file
		StandardInput *string `json:"standard_input,omitempty"`

		// StandardOutput Path to stdout file
		StandardOutput *string `json:"standard_output,omitempty"`

		// Tasks Number of tasks
		Tasks *int32 `json:"tasks,omitempty"`

		// TasksPerBoard Number of tasks to invoke on each board
		TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

		// TasksPerCore Number of tasks to invoke on each core
		TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

		// TasksPerNode Number of tasks to invoke on each node
		TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

		// TasksPerSocket Number of tasks to invoke on each socket
		TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

		// TemporaryDiskPerNode Minimum tmp disk space required per node
		TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

		// ThreadSpecification Specialized thread count
		ThreadSpecification *int32 `json:"thread_specification,omitempty"`

		// ThreadsPerCore Threads per core required
		ThreadsPerCore *int32 `json:"threads_per_core,omitempty"`

		// TimeLimit Maximum run time in minutes
		TimeLimit *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Minimum run time in minutes
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`

		// TresBind Task to TRES binding directives
		TresBind *string `json:"tres_bind,omitempty"`

		// TresFreq TRES frequency directives
		TresFreq *string `json:"tres_freq,omitempty"`

		// TresPerJob Comma separated list of TRES=# values to be allocated for every job
		TresPerJob *string `json:"tres_per_job,omitempty"`

		// TresPerNode Comma separated list of TRES=# values to be allocated for every node
		TresPerNode *string `json:"tres_per_node,omitempty"`

		// TresPerSocket Comma separated list of TRES=# values to be allocated for every socket
		TresPerSocket *string `json:"tres_per_socket,omitempty"`

		// TresPerTask Comma separated list of TRES=# values to be allocated for every task
		TresPerTask *string `json:"tres_per_task,omitempty"`

		// UserId User ID that owns the job
		UserId *string `json:"user_id,omitempty"`

		// WaitAllNodes If true, wait to start until after all nodes have booted
		WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

		// WaitForSwitch Maximum time to wait for switches in seconds
		WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

		// Wckey Workload characterization key
		Wckey *string `json:"wckey,omitempty"`

		// X11 X11 forwarding options
		X11 *[]SlurmV0041PostJobSubmitJSONBodyJobX11 `json:"x11,omitempty"`

		// X11MagicCookie Magic cookie for X11 forwarding
		X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

		// X11TargetHost Hostname or UNIX socket if x11_target_port=0
		X11TargetHost *string `json:"x11_target_host,omitempty"`

		// X11TargetPort TCP port
		X11TargetPort *int32 `json:"x11_target_port,omitempty"`
	} `json:"job,omitempty"`

	// Jobs HetJob description
	Jobs *[]struct {
		// Account Account associated with the job
		Account *string `json:"account,omitempty"`

		// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
		AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

		// AdminComment Arbitrary comment made by administrator
		AdminComment *string `json:"admin_comment,omitempty"`

		// AllocationNodeList Local node making the resource allocation
		AllocationNodeList *string `json:"allocation_node_list,omitempty"`

		// AllocationNodePort Port to send allocation confirmation to
		AllocationNodePort *int32 `json:"allocation_node_port,omitempty"`

		// Argv Arguments to the script
		Argv *[]string `json:"argv,omitempty"`

		// Array Job array index value specification
		Array *string `json:"array,omitempty"`

		// BatchFeatures Features required for batch script's node
		BatchFeatures *string `json:"batch_features,omitempty"`

		// BeginTime Defer the allocation of the job until the specified time (UNIX timestamp)
		BeginTime *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"begin_time,omitempty"`

		// BurstBuffer Burst buffer specifications
		BurstBuffer *string `json:"burst_buffer,omitempty"`

		// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
		ClusterConstraint *string `json:"cluster_constraint,omitempty"`

		// Clusters Clusters that a federated job can run on
		Clusters *string `json:"clusters,omitempty"`

		// Comment Arbitrary comment made by user
		Comment *string `json:"comment,omitempty"`

		// Constraints Comma separated list of features that are required
		Constraints *string `json:"constraints,omitempty"`

		// Container Absolute path to OCI container bundle
		Container *string `json:"container,omitempty"`

		// ContainerId OCI container ID
		ContainerId *string `json:"container_id,omitempty"`

		// Contiguous True if job requires contiguous nodes
		Contiguous *bool `json:"contiguous,omitempty"`

		// CoreSpecification Specialized core count
		CoreSpecification *int32 `json:"core_specification,omitempty"`

		// CpuBinding Method for binding tasks to allocated CPUs
		CpuBinding *string `json:"cpu_binding,omitempty"`

		// CpuBindingFlags Flags for CPU binding
		CpuBindingFlags *[]SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

		// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
		CpuFrequency *string `json:"cpu_frequency,omitempty"`

		// CpusPerTask Number of CPUs required by each task
		CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

		// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
		CpusPerTres *string `json:"cpus_per_tres,omitempty"`

		// Crontab Specification for scrontab job
		Crontab *struct {
			// Command Command to run
			Command *string `json:"command,omitempty"`

			// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
			DayOfMonth *string `json:"day_of_month,omitempty"`

			// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
			DayOfWeek *string `json:"day_of_week,omitempty"`

			// Flags Flags
			Flags *[]SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags `json:"flags,omitempty"`

			// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
			Hour *string `json:"hour,omitempty"`
			Line *struct {
				// End End of this entry in file
				End *int32 `json:"end,omitempty"`

				// Start Start of this entry in file
				Start *int32 `json:"start,omitempty"`
			} `json:"line,omitempty"`

			// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
			Minute *string `json:"minute,omitempty"`

			// Month Ranged string specifying eligible month values (e.g. 0-5,12)
			Month *string `json:"month,omitempty"`

			// Specification Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
			Specification *string `json:"specification,omitempty"`
		} `json:"crontab,omitempty"`

		// CurrentWorkingDirectory Working directory to use for the job
		CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

		// Deadline Latest time that the job may start (UNIX timestamp)
		Deadline *int64 `json:"deadline,omitempty"`

		// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
		DelayBoot *int32 `json:"delay_boot,omitempty"`

		// Dependency Other jobs that must meet certain criteria before this job can start
		Dependency *string `json:"dependency,omitempty"`

		// Distribution Layout
		Distribution *string `json:"distribution,omitempty"`

		// DistributionPlaneSize Plane size specification when distribution specifies plane
		DistributionPlaneSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"distribution_plane_size,omitempty"`

		// EndTime Expected end time (UNIX timestamp)
		EndTime *int64 `json:"end_time,omitempty"`

		// Environment Environment variables to be set for the job
		Environment *[]string `json:"environment,omitempty"`

		// ExcludedNodes Comma separated list of nodes that may not be used
		ExcludedNodes *[]string `json:"excluded_nodes,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Exclusive *[]SlurmV0041PostJobSubmitJSONBodyJobsExclusive `json:"exclusive,omitempty"`

		// Extra Arbitrary string used for node filtering if extra constraints are enabled
		Extra *string `json:"extra,omitempty"`

		// Flags Job flags
		Flags *[]SlurmV0041PostJobSubmitJSONBodyJobsFlags `json:"flags,omitempty"`

		// GroupId Group ID of the user that owns the job
		GroupId *string `json:"group_id,omitempty"`

		// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
		HetjobGroup *int32 `json:"hetjob_group,omitempty"`

		// Hold Hold (true) or release (false) job
		Hold *bool `json:"hold,omitempty"`

		// Immediate If true, exit if resources are not available within the time period specified
		Immediate *bool `json:"immediate,omitempty"`

		// JobId Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// KillOnNodeFail If true, kill job on node failure
		KillOnNodeFail *bool `json:"kill_on_node_fail,omitempty"`

		// KillWarningDelay Number of seconds before end time to send the warning signal
		KillWarningDelay *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"kill_warning_delay,omitempty"`

		// KillWarningFlags Flags related to job signals
		KillWarningFlags *[]SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags `json:"kill_warning_flags,omitempty"`

		// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
		KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

		// Licenses License(s) required by the job
		Licenses *string `json:"licenses,omitempty"`

		// MailType Mail event type(s)
		MailType *[]SlurmV0041PostJobSubmitJSONBodyJobsMailType `json:"mail_type,omitempty"`

		// MailUser User to receive email notifications
		MailUser *string `json:"mail_user,omitempty"`

		// MaximumCpus Maximum number of CPUs required
		MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

		// MaximumNodes Maximum node count
		MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

		// McsLabel Multi-Category Security label on the job
		McsLabel *string `json:"mcs_label,omitempty"`

		// MemoryBinding Binding map for map/mask_cpu
		MemoryBinding *string `json:"memory_binding,omitempty"`

		// MemoryBindingType Method for binding tasks to memory
		MemoryBindingType *[]SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType `json:"memory_binding_type,omitempty"`

		// MemoryPerCpu Minimum memory in megabytes per allocated CPU
		MemoryPerCpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_cpu,omitempty"`

		// MemoryPerNode Minimum memory in megabytes per allocated CPU
		MemoryPerNode *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memory_per_node,omitempty"`

		// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
		MemoryPerTres *string `json:"memory_per_tres,omitempty"`

		// MinimumBoardsPerNode Boards per node required
		MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

		// MinimumCpus Minimum number of CPUs required
		MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

		// MinimumCpusPerNode Minimum number of CPUs per node
		MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

		// MinimumNodes Minimum node count
		MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

		// MinimumSocketsPerBoard Sockets per board required
		MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

		// Name Job name
		Name *string `json:"name,omitempty"`

		// Network Network specs for job step
		Network *string `json:"network,omitempty"`

		// Nice Requested job priority change
		Nice *int32 `json:"nice,omitempty"`

		// Nodes Node count range specification (e.g. 1-15:4)
		Nodes *string `json:"nodes,omitempty"`

		// NtasksPerTres Number of tasks that can access each GPU
		NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

		// OpenMode Open mode used for stdout and stderr files
		OpenMode *[]SlurmV0041PostJobSubmitJSONBodyJobsOpenMode `json:"open_mode,omitempty"`

		// Overcommit Overcommit resources
		Overcommit *bool `json:"overcommit,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Oversubscribe *bool `json:"oversubscribe,omitempty"`

		// Partition Partition assigned to the job
		Partition *string `json:"partition,omitempty"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		PowerFlags *[]interface{} `json:"power_flags,omitempty"`

		// Prefer Comma separated list of features that are preferred but not required
		Prefer *string `json:"prefer,omitempty"`

		// Priority Request specific job priority
		Priority *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"priority,omitempty"`

		// Profile Profile used by the acct_gather_profile plugin
		Profile *[]SlurmV0041PostJobSubmitJSONBodyJobsProfile `json:"profile,omitempty"`

		// Qos Quality of Service assigned to the job
		Qos *string `json:"qos,omitempty"`

		// Reboot Node reboot requested before start
		Reboot *bool `json:"reboot,omitempty"`

		// Requeue Determines whether the job may be requeued
		Requeue *bool `json:"requeue,omitempty"`

		// RequiredNodes Comma separated list of required nodes
		RequiredNodes *[]string `json:"required_nodes,omitempty"`

		// RequiredSwitches Maximum number of switches
		RequiredSwitches *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"required_switches,omitempty"`

		// Reservation Name of reservation to use
		Reservation *string `json:"reservation,omitempty"`

		// ReservePorts Port to send various notification msg to
		ReservePorts *int32 `json:"reserve_ports,omitempty"`

		// ResvMpiPorts Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
		ResvMpiPorts *int32 `json:"resv_mpi_ports,omitempty"`
		Rlimits      *struct {
			// As Address space limit.
			As *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"as,omitempty"`

			// Core Largest core file that can be created, in bytes.
			Core *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"core,omitempty"`

			// Cpu Per-process CPU limit, in seconds.
			Cpu *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"cpu,omitempty"`

			// Data Maximum size of data segment, in bytes.
			Data *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"data,omitempty"`

			// Fsize Largest file that can be created, in bytes.
			Fsize *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"fsize,omitempty"`

			// Memlock Locked-in-memory address space
			Memlock *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"memlock,omitempty"`

			// Nofile Number of open files.
			Nofile *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nofile,omitempty"`

			// Nproc Number of processes.
			Nproc *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"nproc,omitempty"`

			// Rss Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size will be more likely to have physical memory taken from them.
			Rss *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"rss,omitempty"`

			// Stack Maximum size of stack segment, in bytes.
			Stack *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"stack,omitempty"`
		} `json:"rlimits,omitempty"`

		// Script Job batch script; only the first component in a HetJob is populated or honored
		Script *string `json:"script,omitempty"`

		// SegmentSize Segment size for topology/block
		SegmentSize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"segment_size,omitempty"`

		// SelinuxContext SELinux context
		SelinuxContext *string `json:"selinux_context,omitempty"`

		// Shared How the job can share resources with other jobs, if at all
		Shared *[]SlurmV0041PostJobSubmitJSONBodyJobsShared `json:"shared,omitempty"`

		// SiteFactor Site-specific priority factor
		SiteFactor *int32 `json:"site_factor,omitempty"`

		// SocketsPerNode Sockets per node required
		SocketsPerNode *int32 `json:"sockets_per_node,omitempty"`

		// SpankEnvironment Environment variables for job prolog/epilog scripts as set by SPANK plugins
		SpankEnvironment *[]string `json:"spank_environment,omitempty"`

		// StandardError Path to stderr file
		StandardError *string `json:"standard_error,omitempty"`

		// StandardInput Path to stdin file
		StandardInput *string `json:"standard_input,omitempty"`

		// StandardOutput Path to stdout file
		StandardOutput *string `json:"standard_output,omitempty"`

		// Tasks Number of tasks
		Tasks *int32 `json:"tasks,omitempty"`

		// TasksPerBoard Number of tasks to invoke on each board
		TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

		// TasksPerCore Number of tasks to invoke on each core
		TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

		// TasksPerNode Number of tasks to invoke on each node
		TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

		// TasksPerSocket Number of tasks to invoke on each socket
		TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

		// TemporaryDiskPerNode Minimum tmp disk space required per node
		TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

		// ThreadSpecification Specialized thread count
		ThreadSpecification *int32 `json:"thread_specification,omitempty"`

		// ThreadsPerCore Threads per core required
		ThreadsPerCore *int32 `json:"threads_per_core,omitempty"`

		// TimeLimit Maximum run time in minutes
		TimeLimit *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_limit,omitempty"`

		// TimeMinimum Minimum run time in minutes
		TimeMinimum *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int32 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"time_minimum,omitempty"`

		// TresBind Task to TRES binding directives
		TresBind *string `json:"tres_bind,omitempty"`

		// TresFreq TRES frequency directives
		TresFreq *string `json:"tres_freq,omitempty"`

		// TresPerJob Comma separated list of TRES=# values to be allocated for every job
		TresPerJob *string `json:"tres_per_job,omitempty"`

		// TresPerNode Comma separated list of TRES=# values to be allocated for every node
		TresPerNode *string `json:"tres_per_node,omitempty"`

		// TresPerSocket Comma separated list of TRES=# values to be allocated for every socket
		TresPerSocket *string `json:"tres_per_socket,omitempty"`

		// TresPerTask Comma separated list of TRES=# values to be allocated for every task
		TresPerTask *string `json:"tres_per_task,omitempty"`

		// UserId User ID that owns the job
		UserId *string `json:"user_id,omitempty"`

		// WaitAllNodes If true, wait to start until after all nodes have booted
		WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

		// WaitForSwitch Maximum time to wait for switches in seconds
		WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

		// Wckey Workload characterization key
		Wckey *string `json:"wckey,omitempty"`

		// X11 X11 forwarding options
		X11 *[]SlurmV0041PostJobSubmitJSONBodyJobsX11 `json:"x11,omitempty"`

		// X11MagicCookie Magic cookie for X11 forwarding
		X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

		// X11TargetHost Hostname or UNIX socket if x11_target_port=0
		X11TargetHost *string `json:"x11_target_host,omitempty"`

		// X11TargetPort TCP port
		X11TargetPort *int32 `json:"x11_target_port,omitempty"`
	} `json:"jobs,omitempty"`

	// Script Deprecated; Populate script field in jobs[0] or job
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Script *string `json:"script,omitempty"`
}

// SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobCpuBindingFlags string

// SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobCrontabFlags string

// SlurmV0041PostJobSubmitJSONBodyJobExclusive defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobExclusive string

// SlurmV0041PostJobSubmitJSONBodyJobFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobFlags string

// SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobKillWarningFlags string

// SlurmV0041PostJobSubmitJSONBodyJobMailType defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobMailType string

// SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobMemoryBindingType string

// SlurmV0041PostJobSubmitJSONBodyJobOpenMode defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobOpenMode string

// SlurmV0041PostJobSubmitJSONBodyJobProfile defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobProfile string

// SlurmV0041PostJobSubmitJSONBodyJobShared defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobShared string

// SlurmV0041PostJobSubmitJSONBodyJobX11 defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobX11 string

// SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsCpuBindingFlags string

// SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsCrontabFlags string

// SlurmV0041PostJobSubmitJSONBodyJobsExclusive defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsExclusive string

// SlurmV0041PostJobSubmitJSONBodyJobsFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsFlags string

// SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsKillWarningFlags string

// SlurmV0041PostJobSubmitJSONBodyJobsMailType defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsMailType string

// SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsMemoryBindingType string

// SlurmV0041PostJobSubmitJSONBodyJobsOpenMode defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsOpenMode string

// SlurmV0041PostJobSubmitJSONBodyJobsProfile defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsProfile string

// SlurmV0041PostJobSubmitJSONBodyJobsShared defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsShared string

// SlurmV0041PostJobSubmitJSONBodyJobsX11 defines parameters for SlurmV0041PostJobSubmit.
type SlurmV0041PostJobSubmitJSONBodyJobsX11 string

// SlurmV0041DeleteJobParams defines parameters for SlurmV0041DeleteJob.
type SlurmV0041DeleteJobParams struct {
	// Signal Signal to send to Job
	Signal *string `form:"signal,omitempty" json:"signal,omitempty"`

	// Flags Signalling flags
	Flags *SlurmV0041DeleteJobParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041DeleteJobParamsFlags defines parameters for SlurmV0041DeleteJob.
type SlurmV0041DeleteJobParamsFlags string

// SlurmV0041GetJobParams defines parameters for SlurmV0041GetJob.
type SlurmV0041GetJobParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetJobParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetJobParamsFlags defines parameters for SlurmV0041GetJob.
type SlurmV0041GetJobParamsFlags string

// SlurmV0041PostJobJSONBody defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBody struct {
	// Account Account associated with the job
	Account *string `json:"account,omitempty"`

	// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
	AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

	// AdminComment Arbitrary comment made by administrator
	AdminComment *string `json:"admin_comment,omitempty"`

	// AllocationNodeList Local node making the resource allocation
	AllocationNodeList *string `json:"allocation_node_list,omitempty"`

	// AllocationNodePort Port to send allocation confirmation to
	AllocationNodePort *int32 `json:"allocation_node_port,omitempty"`

	// Argv Arguments to the script
	Argv *[]string `json:"argv,omitempty"`

	// Array Job array index value specification
	Array *string `json:"array,omitempty"`

	// BatchFeatures Features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// BeginTime Defer the allocation of the job until the specified time (UNIX timestamp)
	BeginTime *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"begin_time,omitempty"`

	// BurstBuffer Burst buffer specifications
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
	ClusterConstraint *string `json:"cluster_constraint,omitempty"`

	// Clusters Clusters that a federated job can run on
	Clusters *string `json:"clusters,omitempty"`

	// Comment Arbitrary comment made by user
	Comment *string `json:"comment,omitempty"`

	// Constraints Comma separated list of features that are required
	Constraints *string `json:"constraints,omitempty"`

	// Container Absolute path to OCI container bundle
	Container *string `json:"container,omitempty"`

	// ContainerId OCI container ID
	ContainerId *string `json:"container_id,omitempty"`

	// Contiguous True if job requires contiguous nodes
	Contiguous *bool `json:"contiguous,omitempty"`

	// CoreSpecification Specialized core count
	CoreSpecification *int32 `json:"core_specification,omitempty"`

	// CpuBinding Method for binding tasks to allocated CPUs
	CpuBinding *string `json:"cpu_binding,omitempty"`

	// CpuBindingFlags Flags for CPU binding
	CpuBindingFlags *[]SlurmV0041PostJobJSONBodyCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

	// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
	CpuFrequency *string `json:"cpu_frequency,omitempty"`

	// CpusPerTask Number of CPUs required by each task
	CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

	// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
	CpusPerTres *string `json:"cpus_per_tres,omitempty"`

	// Crontab Specification for scrontab job
	Crontab *struct {
		// Command Command to run
		Command *string `json:"command,omitempty"`

		// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
		DayOfMonth *string `json:"day_of_month,omitempty"`

		// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
		DayOfWeek *string `json:"day_of_week,omitempty"`

		// Flags Flags
		Flags *[]SlurmV0041PostJobJSONBodyCrontabFlags `json:"flags,omitempty"`

		// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
		Hour *string `json:"hour,omitempty"`
		Line *struct {
			// End End of this entry in file
			End *int32 `json:"end,omitempty"`

			// Start Start of this entry in file
			Start *int32 `json:"start,omitempty"`
		} `json:"line,omitempty"`

		// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
		Minute *string `json:"minute,omitempty"`

		// Month Ranged string specifying eligible month values (e.g. 0-5,12)
		Month *string `json:"month,omitempty"`

		// Specification Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
		Specification *string `json:"specification,omitempty"`
	} `json:"crontab,omitempty"`

	// CurrentWorkingDirectory Working directory to use for the job
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Deadline Latest time that the job may start (UNIX timestamp)
	Deadline *int64 `json:"deadline,omitempty"`

	// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
	DelayBoot *int32 `json:"delay_boot,omitempty"`

	// Dependency Other jobs that must meet certain criteria before this job can start
	Dependency *string `json:"dependency,omitempty"`

	// Distribution Layout
	Distribution *string `json:"distribution,omitempty"`

	// DistributionPlaneSize Plane size specification when distribution specifies plane
	DistributionPlaneSize *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"distribution_plane_size,omitempty"`

	// EndTime Expected end time (UNIX timestamp)
	EndTime *int64 `json:"end_time,omitempty"`

	// Environment Environment variables to be set for the job
	Environment *[]string `json:"environment,omitempty"`

	// ExcludedNodes Comma separated list of nodes that may not be used
	ExcludedNodes *[]string `json:"excluded_nodes,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Exclusive *[]SlurmV0041PostJobJSONBodyExclusive `json:"exclusive,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// Flags Job flags
	Flags *[]SlurmV0041PostJobJSONBodyFlags `json:"flags,omitempty"`

	// GroupId Group ID of the user that owns the job
	GroupId *string `json:"group_id,omitempty"`

	// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
	HetjobGroup *int32 `json:"hetjob_group,omitempty"`

	// Hold Hold (true) or release (false) job
	Hold *bool `json:"hold,omitempty"`

	// Immediate If true, exit if resources are not available within the time period specified
	Immediate *bool `json:"immediate,omitempty"`

	// JobId Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// KillOnNodeFail If true, kill job on node failure
	KillOnNodeFail *bool `json:"kill_on_node_fail,omitempty"`

	// KillWarningDelay Number of seconds before end time to send the warning signal
	KillWarningDelay *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"kill_warning_delay,omitempty"`

	// KillWarningFlags Flags related to job signals
	KillWarningFlags *[]SlurmV0041PostJobJSONBodyKillWarningFlags `json:"kill_warning_flags,omitempty"`

	// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
	KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

	// Licenses License(s) required by the job
	Licenses *string `json:"licenses,omitempty"`

	// MailType Mail event type(s)
	MailType *[]SlurmV0041PostJobJSONBodyMailType `json:"mail_type,omitempty"`

	// MailUser User to receive email notifications
	MailUser *string `json:"mail_user,omitempty"`

	// MaximumCpus Maximum number of CPUs required
	MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

	// MaximumNodes Maximum node count
	MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

	// McsLabel Multi-Category Security label on the job
	McsLabel *string `json:"mcs_label,omitempty"`

	// MemoryBinding Binding map for map/mask_cpu
	MemoryBinding *string `json:"memory_binding,omitempty"`

	// MemoryBindingType Method for binding tasks to memory
	MemoryBindingType *[]SlurmV0041PostJobJSONBodyMemoryBindingType `json:"memory_binding_type,omitempty"`

	// MemoryPerCpu Minimum memory in megabytes per allocated CPU
	MemoryPerCpu *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"memory_per_cpu,omitempty"`

	// MemoryPerNode Minimum memory in megabytes per allocated CPU
	MemoryPerNode *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int64 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"memory_per_node,omitempty"`

	// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
	MemoryPerTres *string `json:"memory_per_tres,omitempty"`

	// MinimumBoardsPerNode Boards per node required
	MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

	// MinimumCpus Minimum number of CPUs required
	MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

	// MinimumCpusPerNode Minimum number of CPUs per node
	MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

	// MinimumNodes Minimum node count
	MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

	// MinimumSocketsPerBoard Sockets per board required
	MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

	// Name Job name
	Name *string `json:"name,omitempty"`

	// Network Network specs for job step
	Network *string `json:"network,omitempty"`

	// Nice Requested job priority change
	Nice *int32 `json:"nice,omitempty"`

	// Nodes Node count range specification (e.g. 1-15:4)
	Nodes *string `json:"nodes,omitempty"`

	// NtasksPerTres Number of tasks that can access each GPU
	NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

	// OpenMode Open mode used for stdout and stderr files
	OpenMode *[]SlurmV0041PostJobJSONBodyOpenMode `json:"open_mode,omitempty"`

	// Overcommit Overcommit resources
	Overcommit *bool `json:"overcommit,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Oversubscribe *bool `json:"oversubscribe,omitempty"`

	// Partition Partition assigned to the job
	Partition *string `json:"partition,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	PowerFlags *[]interface{} `json:"power_flags,omitempty"`

	// Prefer Comma separated list of features that are preferred but not required
	Prefer *string `json:"prefer,omitempty"`

	// Priority Request specific job priority
	Priority *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"priority,omitempty"`

	// Profile Profile used by the acct_gather_profile plugin
	Profile *[]SlurmV0041PostJobJSONBodyProfile `json:"profile,omitempty"`

	// Qos Quality of Service assigned to the job
	Qos *string `json:"qos,omitempty"`

	// Reboot Node reboot requested before start
	Reboot *bool `json:"reboot,omitempty"`

	// Requeue Determines whether the job may be requeued
	Requeue *bool `json:"requeue,omitempty"`

	// RequiredNodes Comma separated list of required nodes
	RequiredNodes *[]string `json:"required_nodes,omitempty"`

	// RequiredSwitches Maximum number of switches
	RequiredSwitches *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"required_switches,omitempty"`

	// Reservation Name of reservation to use
	Reservation *string `json:"reservation,omitempty"`

	// ReservePorts Port to send various notification msg to
	ReservePorts *int32 `json:"reserve_ports,omitempty"`

	// ResvMpiPorts Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
	ResvMpiPorts *int32 `json:"resv_mpi_ports,omitempty"`
	Rlimits      *struct {
		// As Address space limit.
		As *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"as,omitempty"`

		// Core Largest core file that can be created, in bytes.
		Core *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"core,omitempty"`

		// Cpu Per-process CPU limit, in seconds.
		Cpu *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"cpu,omitempty"`

		// Data Maximum size of data segment, in bytes.
		Data *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"data,omitempty"`

		// Fsize Largest file that can be created, in bytes.
		Fsize *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"fsize,omitempty"`

		// Memlock Locked-in-memory address space
		Memlock *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"memlock,omitempty"`

		// Nofile Number of open files.
		Nofile *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"nofile,omitempty"`

		// Nproc Number of processes.
		Nproc *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"nproc,omitempty"`

		// Rss Largest resident set size, in bytes. This affects swapping; processes that are exceeding their resident set size will be more likely to have physical memory taken from them.
		Rss *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"rss,omitempty"`

		// Stack Maximum size of stack segment, in bytes.
		Stack *struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"stack,omitempty"`
	} `json:"rlimits,omitempty"`

	// Script Job batch script; only the first component in a HetJob is populated or honored
	Script *string `json:"script,omitempty"`

	// SegmentSize Segment size for topology/block
	SegmentSize *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"segment_size,omitempty"`

	// SelinuxContext SELinux context
	SelinuxContext *string `json:"selinux_context,omitempty"`

	// Shared How the job can share resources with other jobs, if at all
	Shared *[]SlurmV0041PostJobJSONBodyShared `json:"shared,omitempty"`

	// SiteFactor Site-specific priority factor
	SiteFactor *int32 `json:"site_factor,omitempty"`

	// SocketsPerNode Sockets per node required
	SocketsPerNode *int32 `json:"sockets_per_node,omitempty"`

	// SpankEnvironment Environment variables for job prolog/epilog scripts as set by SPANK plugins
	SpankEnvironment *[]string `json:"spank_environment,omitempty"`

	// StandardError Path to stderr file
	StandardError *string `json:"standard_error,omitempty"`

	// StandardInput Path to stdin file
	StandardInput *string `json:"standard_input,omitempty"`

	// StandardOutput Path to stdout file
	StandardOutput *string `json:"standard_output,omitempty"`

	// Tasks Number of tasks
	Tasks *int32 `json:"tasks,omitempty"`

	// TasksPerBoard Number of tasks to invoke on each board
	TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

	// TasksPerCore Number of tasks to invoke on each core
	TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

	// TasksPerNode Number of tasks to invoke on each node
	TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

	// TasksPerSocket Number of tasks to invoke on each socket
	TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

	// TemporaryDiskPerNode Minimum tmp disk space required per node
	TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

	// ThreadSpecification Specialized thread count
	ThreadSpecification *int32 `json:"thread_specification,omitempty"`

	// ThreadsPerCore Threads per core required
	ThreadsPerCore *int32 `json:"threads_per_core,omitempty"`

	// TimeLimit Maximum run time in minutes
	TimeLimit *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"time_limit,omitempty"`

	// TimeMinimum Minimum run time in minutes
	TimeMinimum *struct {
		// Infinite True if number has been set to infinite; "set" and "number" will be ignored
		Infinite *bool `json:"infinite,omitempty"`

		// Number If "set" is True the number will be set with value; otherwise ignore number contents
		Number *int32 `json:"number,omitempty"`

		// Set True if number has been set; False if number is unset
		Set *bool `json:"set,omitempty"`
	} `json:"time_minimum,omitempty"`

	// TresBind Task to TRES binding directives
	TresBind *string `json:"tres_bind,omitempty"`

	// TresFreq TRES frequency directives
	TresFreq *string `json:"tres_freq,omitempty"`

	// TresPerJob Comma separated list of TRES=# values to be allocated for every job
	TresPerJob *string `json:"tres_per_job,omitempty"`

	// TresPerNode Comma separated list of TRES=# values to be allocated for every node
	TresPerNode *string `json:"tres_per_node,omitempty"`

	// TresPerSocket Comma separated list of TRES=# values to be allocated for every socket
	TresPerSocket *string `json:"tres_per_socket,omitempty"`

	// TresPerTask Comma separated list of TRES=# values to be allocated for every task
	TresPerTask *string `json:"tres_per_task,omitempty"`

	// UserId User ID that owns the job
	UserId *string `json:"user_id,omitempty"`

	// WaitAllNodes If true, wait to start until after all nodes have booted
	WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

	// WaitForSwitch Maximum time to wait for switches in seconds
	WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

	// Wckey Workload characterization key
	Wckey *string `json:"wckey,omitempty"`

	// X11 X11 forwarding options
	X11 *[]SlurmV0041PostJobJSONBodyX11 `json:"x11,omitempty"`

	// X11MagicCookie Magic cookie for X11 forwarding
	X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

	// X11TargetHost Hostname or UNIX socket if x11_target_port=0
	X11TargetHost *string `json:"x11_target_host,omitempty"`

	// X11TargetPort TCP port
	X11TargetPort *int32 `json:"x11_target_port,omitempty"`
}

// SlurmV0041PostJobJSONBodyCpuBindingFlags defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyCpuBindingFlags string

// SlurmV0041PostJobJSONBodyCrontabFlags defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyCrontabFlags string

// SlurmV0041PostJobJSONBodyExclusive defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyExclusive string

// SlurmV0041PostJobJSONBodyFlags defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyFlags string

// SlurmV0041PostJobJSONBodyKillWarningFlags defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyKillWarningFlags string

// SlurmV0041PostJobJSONBodyMailType defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyMailType string

// SlurmV0041PostJobJSONBodyMemoryBindingType defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyMemoryBindingType string

// SlurmV0041PostJobJSONBodyOpenMode defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyOpenMode string

// SlurmV0041PostJobJSONBodyProfile defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyProfile string

// SlurmV0041PostJobJSONBodyShared defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyShared string

// SlurmV0041PostJobJSONBodyX11 defines parameters for SlurmV0041PostJob.
type SlurmV0041PostJobJSONBodyX11 string

// SlurmV0041DeleteJobsJSONBody defines parameters for SlurmV0041DeleteJobs.
type SlurmV0041DeleteJobsJSONBody struct {
	// Account Filter jobs to a specific account
	Account *string `json:"account,omitempty"`

	// Flags Filter jobs according to flags
	Flags *[]SlurmV0041DeleteJobsJSONBodyFlags `json:"flags,omitempty"`

	// JobName Filter jobs to a specific name
	JobName *string `json:"job_name,omitempty"`

	// JobState Filter jobs to a specific state
	JobState *[]SlurmV0041DeleteJobsJSONBodyJobState `json:"job_state,omitempty"`

	// Jobs List of jobs to signal
	Jobs *[]string `json:"jobs,omitempty"`

	// Nodes Filter jobs to a set of nodes
	Nodes *[]string `json:"nodes,omitempty"`

	// Partition Filter jobs to a specific partition
	Partition *string `json:"partition,omitempty"`

	// Qos Filter jobs to a specific QOS
	Qos *string `json:"qos,omitempty"`

	// Reservation Filter jobs to a specific reservation
	Reservation *string `json:"reservation,omitempty"`

	// Signal Signal to send to jobs
	Signal *string `json:"signal,omitempty"`

	// UserId Filter jobs to a specific numeric user id
	UserId *string `json:"user_id,omitempty"`

	// UserName Filter jobs to a specific user name
	UserName *string `json:"user_name,omitempty"`

	// Wckey Filter jobs to a specific wckey
	Wckey *string `json:"wckey,omitempty"`
}

// SlurmV0041DeleteJobsJSONBodyFlags defines parameters for SlurmV0041DeleteJobs.
type SlurmV0041DeleteJobsJSONBodyFlags string

// SlurmV0041DeleteJobsJSONBodyJobState defines parameters for SlurmV0041DeleteJobs.
type SlurmV0041DeleteJobsJSONBodyJobState string

// SlurmV0041GetJobsParams defines parameters for SlurmV0041GetJobs.
type SlurmV0041GetJobsParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetJobsParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetJobsParamsFlags defines parameters for SlurmV0041GetJobs.
type SlurmV0041GetJobsParamsFlags string

// SlurmV0041GetJobsStateParams defines parameters for SlurmV0041GetJobsState.
type SlurmV0041GetJobsStateParams struct {
	// JobId Search for CSV list of Job IDs
	JobId *string `form:"job_id,omitempty" json:"job_id,omitempty"`
}

// SlurmV0041GetNodeParams defines parameters for SlurmV0041GetNode.
type SlurmV0041GetNodeParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetNodeParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetNodeParamsFlags defines parameters for SlurmV0041GetNode.
type SlurmV0041GetNodeParamsFlags string

// SlurmV0041GetNodesParams defines parameters for SlurmV0041GetNodes.
type SlurmV0041GetNodesParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetNodesParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetNodesParamsFlags defines parameters for SlurmV0041GetNodes.
type SlurmV0041GetNodesParamsFlags string

// SlurmV0041GetPartitionParams defines parameters for SlurmV0041GetPartition.
type SlurmV0041GetPartitionParams struct {
	// UpdateTime Filter partitions since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetPartitionParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetPartitionParamsFlags defines parameters for SlurmV0041GetPartition.
type SlurmV0041GetPartitionParamsFlags string

// SlurmV0041GetPartitionsParams defines parameters for SlurmV0041GetPartitions.
type SlurmV0041GetPartitionsParams struct {
	// UpdateTime Filter partitions since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetPartitionsParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetPartitionsParamsFlags defines parameters for SlurmV0041GetPartitions.
type SlurmV0041GetPartitionsParamsFlags string

// SlurmV0041GetReservationParams defines parameters for SlurmV0041GetReservation.
type SlurmV0041GetReservationParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0041GetReservationsParams defines parameters for SlurmV0041GetReservations.
type SlurmV0041GetReservationsParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0041GetSharesParams defines parameters for SlurmV0041GetShares.
type SlurmV0041GetSharesParams struct {
	// Accounts Accounts to query
	Accounts *string `form:"accounts,omitempty" json:"accounts,omitempty"`

	// Users Users to query
	Users *string `form:"users,omitempty" json:"users,omitempty"`
}

// SlurmdbV0041GetAccountParams defines parameters for SlurmdbV0041GetAccount.
type SlurmdbV0041GetAccountParams struct {
	// WithAssocs Include associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords Include coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithDeleted Include deleted
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041GetAccountsParams defines parameters for SlurmdbV0041GetAccounts.
type SlurmdbV0041GetAccountsParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// DELETED include deleted associations
	DELETED *string `form:"DELETED,omitempty" json:"DELETED,omitempty"`

	// WithAssociations query includes associations
	WithAssociations *string `form:"WithAssociations,omitempty" json:"WithAssociations,omitempty"`

	// WithCoordinators query includes coordinators
	WithCoordinators *string `form:"WithCoordinators,omitempty" json:"WithCoordinators,omitempty"`

	// NoUsersAreCoords remove users as coordinators
	NoUsersAreCoords *string `form:"NoUsersAreCoords,omitempty" json:"NoUsersAreCoords,omitempty"`

	// UsersAreCoords users are coordinators
	UsersAreCoords *string `form:"UsersAreCoords,omitempty" json:"UsersAreCoords,omitempty"`
}

// SlurmdbV0041PostAccountsAssociationJSONBody defines parameters for SlurmdbV0041PostAccountsAssociation.
type SlurmdbV0041PostAccountsAssociationJSONBody struct {
	// Account Account organization and description
	Account *struct {
		// Description Arbitrary string describing the account
		Description *string `json:"description,omitempty"`

		// Organization Organization to which the account belongs
		Organization *string `json:"organization,omitempty"`
	} `json:"account,omitempty"`

	// AssociationCondition CSV list of accounts, association limits and options, CSV list of clusters
	AssociationCondition *struct {
		// Accounts CSV accounts list
		Accounts []string `json:"accounts"`

		// Association Association limits and options
		Association *struct {
			// Comment Arbitrary comment
			Comment *string `json:"comment,omitempty"`

			// Defaultqos Default QOS
			Defaultqos *string `json:"defaultqos,omitempty"`

			// Fairshare Allocated shares used for fairshare calculation
			Fairshare *int32 `json:"fairshare,omitempty"`

			// Grpjobs Maximum number of running jobs in this association and its children
			Grpjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpjobs,omitempty"`

			// Grpjobsaccrue Maximum number of pending jobs able to accrue age priority in this association and its children
			Grpjobsaccrue *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpjobsaccrue,omitempty"`

			// Grpsubmitjobs Maximum number of jobs which can be in a pending or running state at any time in this association and its children
			Grpsubmitjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpsubmitjobs,omitempty"`

			// Grptres Maximum number of TRES able to be allocated by running jobs in this association and its children
			Grptres *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptres,omitempty"`

			// Grptresmins Total number of TRES minutes that can possibly be used by past, present and future jobs in this association and its children
			Grptresmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptresmins,omitempty"`

			// Grptresrunmins Maximum number of TRES minutes able to be allocated by running jobs in this association and its children
			Grptresrunmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptresrunmins,omitempty"`

			// Grpwall Maximum wall clock time in minutes able to be allocated by running jobs in this association and its children
			Grpwall *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpwall,omitempty"`

			// Maxjobs Maximum number of running jobs per user in this association
			Maxjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxjobs,omitempty"`

			// Maxjobsaccrue Maximum number of pending jobs able to accrue age priority at any given time in this association
			Maxjobsaccrue *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxjobsaccrue,omitempty"`

			// Maxsubmitjobs Maximum number of jobs which can be in a pending or running state at any time in this association
			Maxsubmitjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxsubmitjobs,omitempty"`

			// Maxtresminsperjob Maximum number of TRES minutes each job is able to use in this association
			Maxtresminsperjob *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresminsperjob,omitempty"`

			// Maxtresperjob Maximum number of TRES each job is able to use in this association
			Maxtresperjob *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresperjob,omitempty"`

			// Maxtrespernode Maximum number of TRES each node is able to use
			Maxtrespernode *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtrespernode,omitempty"`

			// Maxtresrunmins Maximum number of TRES minutes able to be allocated by running jobs in this association
			Maxtresrunmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresrunmins,omitempty"`

			// Maxwalldurationperjob Maximum wall clock time each job is able to use in this association
			Maxwalldurationperjob *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxwalldurationperjob,omitempty"`

			// Minpriothresh Minimum priority required to reserve resources when scheduling
			Minpriothresh *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minpriothresh,omitempty"`

			// Parent Name of parent account
			Parent *string `json:"parent,omitempty"`

			// Priority Association priority factor
			Priority *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority,omitempty"`

			// Qoslevel List of available QOS names
			Qoslevel *[]string `json:"qoslevel,omitempty"`
		} `json:"association,omitempty"`

		// Clusters CSV clusters list
		Clusters *[]string `json:"clusters,omitempty"`
	} `json:"association_condition,omitempty"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// SlurmdbV0041DeleteAssociationParams defines parameters for SlurmdbV0041DeleteAssociation.
type SlurmdbV0041DeleteAssociationParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041GetAssociationParams defines parameters for SlurmdbV0041GetAssociation.
type SlurmdbV0041GetAssociationParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041DeleteAssociationsParams defines parameters for SlurmdbV0041DeleteAssociations.
type SlurmdbV0041DeleteAssociationsParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041GetAssociationsParams defines parameters for SlurmdbV0041GetAssociations.
type SlurmdbV0041GetAssociationsParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041DeleteClusterParams defines parameters for SlurmdbV0041DeleteCluster.
type SlurmdbV0041DeleteClusterParams struct {
	// Classification Type of machine
	Classification *SlurmdbV0041DeleteClusterParamsClassification `form:"classification,omitempty" json:"classification,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Federation CSV federation list
	Federation *string `form:"federation,omitempty" json:"federation,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0041DeleteClusterParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// RpcVersion CSV RPC version list
	RpcVersion *string `form:"rpc_version,omitempty" json:"rpc_version,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// WithDeleted Include deleted clusters
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`
}

// SlurmdbV0041DeleteClusterParamsClassification defines parameters for SlurmdbV0041DeleteCluster.
type SlurmdbV0041DeleteClusterParamsClassification string

// SlurmdbV0041DeleteClusterParamsFlags defines parameters for SlurmdbV0041DeleteCluster.
type SlurmdbV0041DeleteClusterParamsFlags string

// SlurmdbV0041GetClusterParams defines parameters for SlurmdbV0041GetCluster.
type SlurmdbV0041GetClusterParams struct {
	// Classification Type of machine
	Classification *SlurmdbV0041GetClusterParamsClassification `form:"classification,omitempty" json:"classification,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Federation CSV federation list
	Federation *string `form:"federation,omitempty" json:"federation,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0041GetClusterParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// RpcVersion CSV RPC version list
	RpcVersion *string `form:"rpc_version,omitempty" json:"rpc_version,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// WithDeleted Include deleted clusters
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`
}

// SlurmdbV0041GetClusterParamsClassification defines parameters for SlurmdbV0041GetCluster.
type SlurmdbV0041GetClusterParamsClassification string

// SlurmdbV0041GetClusterParamsFlags defines parameters for SlurmdbV0041GetCluster.
type SlurmdbV0041GetClusterParamsFlags string

// SlurmdbV0041GetClustersParams defines parameters for SlurmdbV0041GetClusters.
type SlurmdbV0041GetClustersParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmdbV0041PostClustersParams defines parameters for SlurmdbV0041PostClusters.
type SlurmdbV0041PostClustersParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmdbV0041GetInstanceParams defines parameters for SlurmdbV0041GetInstance.
type SlurmdbV0041GetInstanceParams struct {
	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Extra CSV extra list
	Extra *string `form:"extra,omitempty" json:"extra,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// InstanceId CSV instance_id list
	InstanceId *string `form:"instance_id,omitempty" json:"instance_id,omitempty"`

	// InstanceType CSV instance_type list
	InstanceType *string `form:"instance_type,omitempty" json:"instance_type,omitempty"`

	// NodeList Ranged node string
	NodeList *string `form:"node_list,omitempty" json:"node_list,omitempty"`

	// TimeEnd Time end (UNIX timestamp)
	TimeEnd *string `form:"time_end,omitempty" json:"time_end,omitempty"`

	// TimeStart Time start (UNIX timestamp)
	TimeStart *string `form:"time_start,omitempty" json:"time_start,omitempty"`
}

// SlurmdbV0041GetInstancesParams defines parameters for SlurmdbV0041GetInstances.
type SlurmdbV0041GetInstancesParams struct {
	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Extra CSV extra list
	Extra *string `form:"extra,omitempty" json:"extra,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// InstanceId CSV instance_id list
	InstanceId *string `form:"instance_id,omitempty" json:"instance_id,omitempty"`

	// InstanceType CSV instance_type list
	InstanceType *string `form:"instance_type,omitempty" json:"instance_type,omitempty"`

	// NodeList Ranged node string
	NodeList *string `form:"node_list,omitempty" json:"node_list,omitempty"`

	// TimeEnd Time end (UNIX timestamp)
	TimeEnd *string `form:"time_end,omitempty" json:"time_end,omitempty"`

	// TimeStart Time start (UNIX timestamp)
	TimeStart *string `form:"time_start,omitempty" json:"time_start,omitempty"`
}

// SlurmdbV0041GetJobsParams defines parameters for SlurmdbV0041GetJobs.
type SlurmdbV0041GetJobsParams struct {
	// Account CSV account list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Association CSV association list
	Association *string `form:"association,omitempty" json:"association,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Constraints CSV constraint list
	Constraints *string `form:"constraints,omitempty" json:"constraints,omitempty"`

	// SchedulerUnset Schedule bits not set
	SchedulerUnset *string `form:"scheduler_unset,omitempty" json:"scheduler_unset,omitempty"`

	// ScheduledOnSubmit Job was started on submit
	ScheduledOnSubmit *string `form:"scheduled_on_submit,omitempty" json:"scheduled_on_submit,omitempty"`

	// ScheduledByMain Job was started from main scheduler
	ScheduledByMain *string `form:"scheduled_by_main,omitempty" json:"scheduled_by_main,omitempty"`

	// ScheduledByBackfill Job was started from backfill
	ScheduledByBackfill *string `form:"scheduled_by_backfill,omitempty" json:"scheduled_by_backfill,omitempty"`

	// JobStarted Job start RPC was received
	JobStarted *string `form:"job_started,omitempty" json:"job_started,omitempty"`

	// ExitCode Job exit code (numeric)
	ExitCode *string `form:"exit_code,omitempty" json:"exit_code,omitempty"`

	// ShowDuplicates Include duplicate job entries
	ShowDuplicates *string `form:"show_duplicates,omitempty" json:"show_duplicates,omitempty"`

	// SkipSteps Exclude job step details
	SkipSteps *string `form:"skip_steps,omitempty" json:"skip_steps,omitempty"`

	// DisableTruncateUsageTime Do not truncate the time to usage_start and usage_end
	DisableTruncateUsageTime *string `form:"disable_truncate_usage_time,omitempty" json:"disable_truncate_usage_time,omitempty"`

	// WholeHetjob Include details on all hetjob components
	WholeHetjob *string `form:"whole_hetjob,omitempty" json:"whole_hetjob,omitempty"`

	// DisableWholeHetjob Only show details on specified hetjob components
	DisableWholeHetjob *string `form:"disable_whole_hetjob,omitempty" json:"disable_whole_hetjob,omitempty"`

	// DisableWaitForResult Tell dbd not to wait for the result
	DisableWaitForResult *string `form:"disable_wait_for_result,omitempty" json:"disable_wait_for_result,omitempty"`

	// UsageTimeAsSubmitTime Use usage_time as the submit_time of the job
	UsageTimeAsSubmitTime *string `form:"usage_time_as_submit_time,omitempty" json:"usage_time_as_submit_time,omitempty"`

	// ShowBatchScript Include job script
	ShowBatchScript *string `form:"show_batch_script,omitempty" json:"show_batch_script,omitempty"`

	// ShowJobEnvironment Include job environment
	ShowJobEnvironment *string `form:"show_job_environment,omitempty" json:"show_job_environment,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Groups CSV group list
	Groups *string `form:"groups,omitempty" json:"groups,omitempty"`

	// JobName CSV job name list
	JobName *string `form:"job_name,omitempty" json:"job_name,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS name list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// Reason CSV reason list
	Reason *string `form:"reason,omitempty" json:"reason,omitempty"`

	// Reservation CSV reservation name list
	Reservation *string `form:"reservation,omitempty" json:"reservation,omitempty"`

	// ReservationId CSV reservation ID list
	ReservationId *string `form:"reservation_id,omitempty" json:"reservation_id,omitempty"`

	// State CSV state list
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Step CSV step id list
	Step *string `form:"step,omitempty" json:"step,omitempty"`

	// EndTime Usage end (UNIX timestamp)
	EndTime *string `form:"end_time,omitempty" json:"end_time,omitempty"`

	// StartTime Usage start (UNIX timestamp)
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty"`

	// Node Ranged node string where jobs ran
	Node *string `form:"node,omitempty" json:"node,omitempty"`

	// Users CSV user name list
	Users *string `form:"users,omitempty" json:"users,omitempty"`

	// Wckey CSV wckey list
	Wckey *string `form:"wckey,omitempty" json:"wckey,omitempty"`
}

// SlurmdbV0041GetQosParams defines parameters for SlurmdbV0041GetQos.
type SlurmdbV0041GetQosParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Id CSV QOS id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Name CSV QOS name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PreemptMode PreemptMode used when jobs in this QOS are preempted
	PreemptMode *SlurmdbV0041GetQosParamsPreemptMode `form:"preempt_mode,omitempty" json:"preempt_mode,omitempty"`

	// WithDeleted Include deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041GetQosParamsPreemptMode defines parameters for SlurmdbV0041GetQos.
type SlurmdbV0041GetQosParamsPreemptMode string

// SlurmdbV0041PostQosParams defines parameters for SlurmdbV0041PostQos.
type SlurmdbV0041PostQosParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Id CSV QOS id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Name CSV QOS name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PreemptMode PreemptMode used when jobs in this QOS are preempted
	PreemptMode *SlurmdbV0041PostQosParamsPreemptMode `form:"preempt_mode,omitempty" json:"preempt_mode,omitempty"`

	// WithDeleted Include deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041PostQosParamsPreemptMode defines parameters for SlurmdbV0041PostQos.
type SlurmdbV0041PostQosParamsPreemptMode string

// SlurmdbV0041GetSingleQosParams defines parameters for SlurmdbV0041GetSingleQos.
type SlurmdbV0041GetSingleQosParams struct {
	// WithDeleted Query includes deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041GetUserParams defines parameters for SlurmdbV0041GetUser.
type SlurmdbV0041GetUserParams struct {
	// WithDeleted Include deleted users
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithAssocs Include associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords Include coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithWckeys Include wckeys
	WithWckeys *string `form:"with_wckeys,omitempty" json:"with_wckeys,omitempty"`
}

// SlurmdbV0041GetUsersParams defines parameters for SlurmdbV0041GetUsers.
type SlurmdbV0041GetUsersParams struct {
	// AdminLevel Administrator level
	AdminLevel *SlurmdbV0041GetUsersParamsAdminLevel `form:"admin_level,omitempty" json:"admin_level,omitempty"`

	// DefaultAccount CSV default account list
	DefaultAccount *string `form:"default_account,omitempty" json:"default_account,omitempty"`

	// DefaultWckey CSV default wckey list
	DefaultWckey *string `form:"default_wckey,omitempty" json:"default_wckey,omitempty"`

	// WithAssocs With associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords With coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithDeleted With deleted
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithWckeys With wckeys
	WithWckeys *string `form:"with_wckeys,omitempty" json:"with_wckeys,omitempty"`

	// WithoutDefaults Exclude defaults
	WithoutDefaults *string `form:"without_defaults,omitempty" json:"without_defaults,omitempty"`
}

// SlurmdbV0041GetUsersParamsAdminLevel defines parameters for SlurmdbV0041GetUsers.
type SlurmdbV0041GetUsersParamsAdminLevel string

// SlurmdbV0041PostUsersAssociationJSONBody defines parameters for SlurmdbV0041PostUsersAssociation.
type SlurmdbV0041PostUsersAssociationJSONBody struct {
	// AssociationCondition Filters to select associations for users
	AssociationCondition struct {
		// Accounts CSV accounts list
		Accounts *[]string `json:"accounts,omitempty"`

		// Association Association limits and options
		Association *struct {
			// Comment Arbitrary comment
			Comment *string `json:"comment,omitempty"`

			// Defaultqos Default QOS
			Defaultqos *string `json:"defaultqos,omitempty"`

			// Fairshare Allocated shares used for fairshare calculation
			Fairshare *int32 `json:"fairshare,omitempty"`

			// Grpjobs Maximum number of running jobs in this association and its children
			Grpjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpjobs,omitempty"`

			// Grpjobsaccrue Maximum number of pending jobs able to accrue age priority in this association and its children
			Grpjobsaccrue *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpjobsaccrue,omitempty"`

			// Grpsubmitjobs Maximum number of jobs which can be in a pending or running state at any time in this association and its children
			Grpsubmitjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpsubmitjobs,omitempty"`

			// Grptres Maximum number of TRES able to be allocated by running jobs in this association and its children
			Grptres *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptres,omitempty"`

			// Grptresmins Total number of TRES minutes that can possibly be used by past, present and future jobs in this association and its children
			Grptresmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptresmins,omitempty"`

			// Grptresrunmins Maximum number of TRES minutes able to be allocated by running jobs in this association and its children
			Grptresrunmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"grptresrunmins,omitempty"`

			// Grpwall Maximum wall clock time in minutes able to be allocated by running jobs in this association and its children
			Grpwall *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"grpwall,omitempty"`

			// Maxjobs Maximum number of running jobs per user in this association
			Maxjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxjobs,omitempty"`

			// Maxjobsaccrue Maximum number of pending jobs able to accrue age priority at any given time in this association
			Maxjobsaccrue *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxjobsaccrue,omitempty"`

			// Maxsubmitjobs Maximum number of jobs which can be in a pending or running state at any time in this association
			Maxsubmitjobs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxsubmitjobs,omitempty"`

			// Maxtresminsperjob Maximum number of TRES minutes each job is able to use in this association
			Maxtresminsperjob *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresminsperjob,omitempty"`

			// Maxtresperjob Maximum number of TRES each job is able to use in this association
			Maxtresperjob *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresperjob,omitempty"`

			// Maxtrespernode Maximum number of TRES each node is able to use
			Maxtrespernode *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtrespernode,omitempty"`

			// Maxtresrunmins Maximum number of TRES minutes able to be allocated by running jobs in this association
			Maxtresrunmins *[]struct {
				// Count TRES count (0 if listed generically)
				Count *int64 `json:"count,omitempty"`

				// Id ID used in database
				Id *int32 `json:"id,omitempty"`

				// Name TRES name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type TRES type (CPU, MEM, etc)
				Type string `json:"type"`
			} `json:"maxtresrunmins,omitempty"`

			// Maxwalldurationperjob Maximum wall clock time each job is able to use in this association
			Maxwalldurationperjob *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"maxwalldurationperjob,omitempty"`

			// Minpriothresh Minimum priority required to reserve resources when scheduling
			Minpriothresh *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"minpriothresh,omitempty"`

			// Parent Name of parent account
			Parent *string `json:"parent,omitempty"`

			// Priority Association priority factor
			Priority *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"priority,omitempty"`

			// Qoslevel List of available QOS names
			Qoslevel *[]string `json:"qoslevel,omitempty"`
		} `json:"association,omitempty"`

		// Clusters CSV clusters list
		Clusters *[]string `json:"clusters,omitempty"`

		// Partitions CSV partitions list
		Partitions *[]string `json:"partitions,omitempty"`

		// Users CSV users list
		Users []string `json:"users"`

		// Wckeys CSV WCKeys list
		Wckeys *[]string `json:"wckeys,omitempty"`
	} `json:"association_condition"`

	// Errors Query errors
	Errors *[]struct {
		// Description Long form error description
		Description *string `json:"description,omitempty"`

		// Error Short form error description
		Error *string `json:"error,omitempty"`

		// ErrorNumber Slurm numeric error identifier
		ErrorNumber *int32 `json:"error_number,omitempty"`

		// Source Source of error or where error was first detected
		Source *string `json:"source,omitempty"`
	} `json:"errors,omitempty"`

	// Meta Slurm meta values
	Meta *struct {
		Client *struct {
			// Group Client group (if known)
			Group *string `json:"group,omitempty"`

			// Source Client source description
			Source *string `json:"source,omitempty"`

			// User Client user (if known)
			User *string `json:"user,omitempty"`
		} `json:"client,omitempty"`

		// Command CLI command (if applicable)
		Command *[]string `json:"command,omitempty"`
		Plugin  *struct {
			// AccountingStorage Slurm accounting plugin
			AccountingStorage *string `json:"accounting_storage,omitempty"`

			// DataParser Slurm data_parser plugin
			DataParser *string `json:"data_parser,omitempty"`

			// Name Slurm plugin name (if applicable)
			Name *string `json:"name,omitempty"`

			// Type Slurm plugin type (if applicable)
			Type *string `json:"type,omitempty"`
		} `json:"plugin,omitempty"`
		Slurm *struct {
			// Cluster Slurm cluster name
			Cluster *string `json:"cluster,omitempty"`

			// Release Slurm release string
			Release *string `json:"release,omitempty"`
			Version *struct {
				// Major Slurm release major version
				Major *string `json:"major,omitempty"`

				// Micro Slurm release micro version
				Micro *string `json:"micro,omitempty"`

				// Minor Slurm release minor version
				Minor *string `json:"minor,omitempty"`
			} `json:"version,omitempty"`
		} `json:"slurm,omitempty"`
	} `json:"meta,omitempty"`

	// User Admin level of user, DefaultAccount, DefaultWCKey
	User struct {
		// Adminlevel AdminLevel granted to the user
		Adminlevel *[]SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel `json:"adminlevel,omitempty"`

		// Defaultaccount Default account
		Defaultaccount *string `json:"defaultaccount,omitempty"`

		// Defaultwckey Default WCKey
		Defaultwckey *string `json:"defaultwckey,omitempty"`
	} `json:"user"`

	// Warnings Query warnings
	Warnings *[]struct {
		// Description Long form warning description
		Description *string `json:"description,omitempty"`

		// Source Source of warning or where warning was first detected
		Source *string `json:"source,omitempty"`
	} `json:"warnings,omitempty"`
}

// SlurmdbV0041PostUsersAssociationParams defines parameters for SlurmdbV0041PostUsersAssociation.
type SlurmdbV0041PostUsersAssociationParams struct {
	// UpdateTime Filter partitions since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0041PostUsersAssociationParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmdbV0041PostUsersAssociationParamsFlags defines parameters for SlurmdbV0041PostUsersAssociation.
type SlurmdbV0041PostUsersAssociationParamsFlags string

// SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel defines parameters for SlurmdbV0041PostUsersAssociation.
type SlurmdbV0041PostUsersAssociationJSONBodyUserAdminlevel string

// SlurmdbV0041GetWckeysParams defines parameters for SlurmdbV0041GetWckeys.
type SlurmdbV0041GetWckeysParams struct {
	// Cluster CSV cluster name list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name CSV name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// OnlyDefaults Only query defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted wckeys
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041PostWckeysParams defines parameters for SlurmdbV0041PostWckeys.
type SlurmdbV0041PostWckeysParams struct {
	// Cluster CSV cluster name list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Format Ignored; process JSON manually to control output format
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name CSV name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// OnlyDefaults Only query defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted wckeys
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmV0041PostJobAllocateJSONRequestBody defines body for SlurmV0041PostJobAllocate for application/json ContentType.
type SlurmV0041PostJobAllocateJSONRequestBody SlurmV0041PostJobAllocateJSONBody

// SlurmV0041PostJobSubmitJSONRequestBody defines body for SlurmV0041PostJobSubmit for application/json ContentType.
type SlurmV0041PostJobSubmitJSONRequestBody SlurmV0041PostJobSubmitJSONBody

// SlurmV0041PostJobJSONRequestBody defines body for SlurmV0041PostJob for application/json ContentType.
type SlurmV0041PostJobJSONRequestBody SlurmV0041PostJobJSONBody

// SlurmV0041DeleteJobsJSONRequestBody defines body for SlurmV0041DeleteJobs for application/json ContentType.
type SlurmV0041DeleteJobsJSONRequestBody SlurmV0041DeleteJobsJSONBody

// SlurmV0041PostNodeJSONRequestBody defines body for SlurmV0041PostNode for application/json ContentType.
type SlurmV0041PostNodeJSONRequestBody = V0041UpdateNodeMsg

// SlurmV0041PostNodesJSONRequestBody defines body for SlurmV0041PostNodes for application/json ContentType.
type SlurmV0041PostNodesJSONRequestBody = V0041UpdateNodeMsg

// SlurmdbV0041PostAccountsJSONRequestBody defines body for SlurmdbV0041PostAccounts for application/json ContentType.
type SlurmdbV0041PostAccountsJSONRequestBody = V0041OpenapiAccountsResp

// SlurmdbV0041PostAccountsAssociationJSONRequestBody defines body for SlurmdbV0041PostAccountsAssociation for application/json ContentType.
type SlurmdbV0041PostAccountsAssociationJSONRequestBody SlurmdbV0041PostAccountsAssociationJSONBody

// SlurmdbV0041PostAssociationsJSONRequestBody defines body for SlurmdbV0041PostAssociations for application/json ContentType.
type SlurmdbV0041PostAssociationsJSONRequestBody = V0041OpenapiAssocsResp

// SlurmdbV0041PostClustersJSONRequestBody defines body for SlurmdbV0041PostClusters for application/json ContentType.
type SlurmdbV0041PostClustersJSONRequestBody = V0041OpenapiClustersResp

// SlurmdbV0041PostConfigJSONRequestBody defines body for SlurmdbV0041PostConfig for application/json ContentType.
type SlurmdbV0041PostConfigJSONRequestBody = V0041OpenapiSlurmdbdConfigResp

// SlurmdbV0041PostQosJSONRequestBody defines body for SlurmdbV0041PostQos for application/json ContentType.
type SlurmdbV0041PostQosJSONRequestBody = V0041OpenapiSlurmdbdQosResp

// SlurmdbV0041PostTresJSONRequestBody defines body for SlurmdbV0041PostTres for application/json ContentType.
type SlurmdbV0041PostTresJSONRequestBody = V0041OpenapiTresResp

// SlurmdbV0041PostUsersJSONRequestBody defines body for SlurmdbV0041PostUsers for application/json ContentType.
type SlurmdbV0041PostUsersJSONRequestBody = V0041OpenapiUsersResp

// SlurmdbV0041PostUsersAssociationJSONRequestBody defines body for SlurmdbV0041PostUsersAssociation for application/json ContentType.
type SlurmdbV0041PostUsersAssociationJSONRequestBody SlurmdbV0041PostUsersAssociationJSONBody

// SlurmdbV0041PostWckeysJSONRequestBody defines body for SlurmdbV0041PostWckeys for application/json ContentType.
type SlurmdbV0041PostWckeysJSONRequestBody = V0041OpenapiWckeyResp

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SlurmV0041GetDiag request
	SlurmV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostJobAllocateWithBody request with any body
	SlurmV0041PostJobAllocateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostJobAllocate(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostJobSubmitWithBody request with any body
	SlurmV0041PostJobSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostJobSubmit(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteJob request
	SlurmV0041DeleteJob(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetJob request
	SlurmV0041GetJob(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostJobWithBody request with any body
	SlurmV0041PostJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostJob(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteJobsWithBody request with any body
	SlurmV0041DeleteJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041DeleteJobs(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetJobs request
	SlurmV0041GetJobs(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetJobsState request
	SlurmV0041GetJobsState(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetLicenses request
	SlurmV0041GetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteNode request
	SlurmV0041DeleteNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetNode request
	SlurmV0041GetNode(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostNodeWithBody request with any body
	SlurmV0041PostNodeWithBody(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostNode(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetNodes request
	SlurmV0041GetNodes(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostNodesWithBody request with any body
	SlurmV0041PostNodesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostNodes(ctx context.Context, body SlurmV0041PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetPartition request
	SlurmV0041GetPartition(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetPartitions request
	SlurmV0041GetPartitions(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetPing request
	SlurmV0041GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetReconfigure request
	SlurmV0041GetReconfigure(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetReservation request
	SlurmV0041GetReservation(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetReservations request
	SlurmV0041GetReservations(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetShares request
	SlurmV0041GetShares(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteAccount request
	SlurmdbV0041DeleteAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAccount request
	SlurmdbV0041GetAccount(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAccounts request
	SlurmdbV0041GetAccounts(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostAccountsWithBody request with any body
	SlurmdbV0041PostAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostAccounts(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostAccountsAssociationWithBody request with any body
	SlurmdbV0041PostAccountsAssociationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostAccountsAssociation(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteAssociation request
	SlurmdbV0041DeleteAssociation(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAssociation request
	SlurmdbV0041GetAssociation(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteAssociations request
	SlurmdbV0041DeleteAssociations(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAssociations request
	SlurmdbV0041GetAssociations(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostAssociationsWithBody request with any body
	SlurmdbV0041PostAssociationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostAssociations(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteCluster request
	SlurmdbV0041DeleteCluster(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetCluster request
	SlurmdbV0041GetCluster(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetClusters request
	SlurmdbV0041GetClusters(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostClustersWithBody request with any body
	SlurmdbV0041PostClustersWithBody(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostClusters(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetConfig request
	SlurmdbV0041GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostConfigWithBody request with any body
	SlurmdbV0041PostConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostConfig(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetDiag request
	SlurmdbV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetInstance request
	SlurmdbV0041GetInstance(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetInstances request
	SlurmdbV0041GetInstances(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetJob request
	SlurmdbV0041GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetJobs request
	SlurmdbV0041GetJobs(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetQos request
	SlurmdbV0041GetQos(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostQosWithBody request with any body
	SlurmdbV0041PostQosWithBody(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostQos(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteSingleQos request
	SlurmdbV0041DeleteSingleQos(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetSingleQos request
	SlurmdbV0041GetSingleQos(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetTres request
	SlurmdbV0041GetTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostTresWithBody request with any body
	SlurmdbV0041PostTresWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostTres(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteUser request
	SlurmdbV0041DeleteUser(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetUser request
	SlurmdbV0041GetUser(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetUsers request
	SlurmdbV0041GetUsers(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostUsersWithBody request with any body
	SlurmdbV0041PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostUsers(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostUsersAssociationWithBody request with any body
	SlurmdbV0041PostUsersAssociationWithBody(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostUsersAssociation(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteWckey request
	SlurmdbV0041DeleteWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetWckey request
	SlurmdbV0041GetWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetWckeys request
	SlurmdbV0041GetWckeys(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostWckeysWithBody request with any body
	SlurmdbV0041PostWckeysWithBody(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostWckeys(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SlurmV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobAllocateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobAllocateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobAllocate(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobAllocateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobSubmitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobSubmit(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobSubmitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteJob(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetJob(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJob(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteJobs(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetJobs(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetJobsState(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetJobsStateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetLicensesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteNodeRequest(c.Server, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetNode(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetNodeRequest(c.Server, nodeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNodeWithBody(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodeRequestWithBody(c.Server, nodeName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNode(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodeRequest(c.Server, nodeName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetNodes(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetNodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNodesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNodes(ctx context.Context, body SlurmV0041PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetPartition(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetPartitionRequest(c.Server, partitionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetPartitions(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetPartitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetReconfigure(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetReconfigureRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetReservation(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetReservationRequest(c.Server, reservationName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetReservations(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetReservationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetShares(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetSharesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteAccountRequest(c.Server, accountName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAccount(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAccountRequest(c.Server, accountName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAccounts(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccounts(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccountsAssociationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsAssociationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccountsAssociation(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsAssociationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteAssociation(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteAssociationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAssociation(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAssociationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteAssociations(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAssociations(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAssociationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAssociationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAssociations(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAssociationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteCluster(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteClusterRequest(c.Server, clusterName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetCluster(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetClusterRequest(c.Server, clusterName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetClusters(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostClustersWithBody(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostClustersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostClusters(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostClustersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostConfig(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetInstance(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetInstanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetInstances(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetInstancesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetJobs(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetQos(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetQosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostQosWithBody(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostQosRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostQos(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostQosRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteSingleQos(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteSingleQosRequest(c.Server, qos)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetSingleQos(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetSingleQosRequest(c.Server, qos, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetTresRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostTresWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostTresRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostTres(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostTresRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteUser(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteUserRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetUser(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetUserRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetUsers(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsers(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsersAssociationWithBody(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersAssociationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsersAssociation(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersAssociationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteWckeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetWckeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetWckeys(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetWckeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostWckeysWithBody(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostWckeysRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostWckeys(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostWckeysRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSlurmV0041GetDiagRequest generates requests for SlurmV0041GetDiag
func NewSlurmV0041GetDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/diag/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostJobAllocateRequest calls the generic SlurmV0041PostJobAllocate builder with application/json body
func NewSlurmV0041PostJobAllocateRequest(server string, body SlurmV0041PostJobAllocateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostJobAllocateRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041PostJobAllocateRequestWithBody generates requests for SlurmV0041PostJobAllocate with any type of body
func NewSlurmV0041PostJobAllocateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/allocate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041PostJobSubmitRequest calls the generic SlurmV0041PostJobSubmit builder with application/json body
func NewSlurmV0041PostJobSubmitRequest(server string, body SlurmV0041PostJobSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostJobSubmitRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041PostJobSubmitRequestWithBody generates requests for SlurmV0041PostJobSubmit with any type of body
func NewSlurmV0041PostJobSubmitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041DeleteJobRequest generates requests for SlurmV0041DeleteJob
func NewSlurmV0041DeleteJobRequest(server string, jobId string, params *SlurmV0041DeleteJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Signal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "signal", runtime.ParamLocationQuery, *params.Signal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetJobRequest generates requests for SlurmV0041GetJob
func NewSlurmV0041GetJobRequest(server string, jobId string, params *SlurmV0041GetJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostJobRequest calls the generic SlurmV0041PostJob builder with application/json body
func NewSlurmV0041PostJobRequest(server string, jobId string, body SlurmV0041PostJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostJobRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewSlurmV0041PostJobRequestWithBody generates requests for SlurmV0041PostJob with any type of body
func NewSlurmV0041PostJobRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041DeleteJobsRequest calls the generic SlurmV0041DeleteJobs builder with application/json body
func NewSlurmV0041DeleteJobsRequest(server string, body SlurmV0041DeleteJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041DeleteJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041DeleteJobsRequestWithBody generates requests for SlurmV0041DeleteJobs with any type of body
func NewSlurmV0041DeleteJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041GetJobsRequest generates requests for SlurmV0041GetJobs
func NewSlurmV0041GetJobsRequest(server string, params *SlurmV0041GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetJobsStateRequest generates requests for SlurmV0041GetJobsState
func NewSlurmV0041GetJobsStateRequest(server string, params *SlurmV0041GetJobsStateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/jobs/state/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.JobId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_id", runtime.ParamLocationQuery, *params.JobId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetLicensesRequest generates requests for SlurmV0041GetLicenses
func NewSlurmV0041GetLicensesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/licenses/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041DeleteNodeRequest generates requests for SlurmV0041DeleteNode
func NewSlurmV0041DeleteNodeRequest(server string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetNodeRequest generates requests for SlurmV0041GetNode
func NewSlurmV0041GetNodeRequest(server string, nodeName string, params *SlurmV0041GetNodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostNodeRequest calls the generic SlurmV0041PostNode builder with application/json body
func NewSlurmV0041PostNodeRequest(server string, nodeName string, body SlurmV0041PostNodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostNodeRequestWithBody(server, nodeName, "application/json", bodyReader)
}

// NewSlurmV0041PostNodeRequestWithBody generates requests for SlurmV0041PostNode with any type of body
func NewSlurmV0041PostNodeRequestWithBody(server string, nodeName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041GetNodesRequest generates requests for SlurmV0041GetNodes
func NewSlurmV0041GetNodesRequest(server string, params *SlurmV0041GetNodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/nodes/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostNodesRequest calls the generic SlurmV0041PostNodes builder with application/json body
func NewSlurmV0041PostNodesRequest(server string, body SlurmV0041PostNodesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostNodesRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041PostNodesRequestWithBody generates requests for SlurmV0041PostNodes with any type of body
func NewSlurmV0041PostNodesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/nodes/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041GetPartitionRequest generates requests for SlurmV0041GetPartition
func NewSlurmV0041GetPartitionRequest(server string, partitionName string, params *SlurmV0041GetPartitionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "partition_name", runtime.ParamLocationPath, partitionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/partition/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetPartitionsRequest generates requests for SlurmV0041GetPartitions
func NewSlurmV0041GetPartitionsRequest(server string, params *SlurmV0041GetPartitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/partitions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetPingRequest generates requests for SlurmV0041GetPing
func NewSlurmV0041GetPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/ping/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetReconfigureRequest generates requests for SlurmV0041GetReconfigure
func NewSlurmV0041GetReconfigureRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reconfigure/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetReservationRequest generates requests for SlurmV0041GetReservation
func NewSlurmV0041GetReservationRequest(server string, reservationName string, params *SlurmV0041GetReservationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservation_name", runtime.ParamLocationPath, reservationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetReservationsRequest generates requests for SlurmV0041GetReservations
func NewSlurmV0041GetReservationsRequest(server string, params *SlurmV0041GetReservationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reservations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetSharesRequest generates requests for SlurmV0041GetShares
func NewSlurmV0041GetSharesRequest(server string, params *SlurmV0041GetSharesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/shares")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "accounts", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Users != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "users", runtime.ParamLocationQuery, *params.Users); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041DeleteAccountRequest generates requests for SlurmdbV0041DeleteAccount
func NewSlurmdbV0041DeleteAccountRequest(server string, accountName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_name", runtime.ParamLocationPath, accountName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAccountRequest generates requests for SlurmdbV0041GetAccount
func NewSlurmdbV0041GetAccountRequest(server string, accountName string, params *SlurmdbV0041GetAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_name", runtime.ParamLocationPath, accountName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAccountsRequest generates requests for SlurmdbV0041GetAccounts
func NewSlurmdbV0041GetAccountsRequest(server string, params *SlurmdbV0041GetAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/accounts/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DELETED != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "DELETED", runtime.ParamLocationQuery, *params.DELETED); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssociations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "WithAssociations", runtime.ParamLocationQuery, *params.WithAssociations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoordinators != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "WithCoordinators", runtime.ParamLocationQuery, *params.WithCoordinators); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoUsersAreCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "NoUsersAreCoords", runtime.ParamLocationQuery, *params.NoUsersAreCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsersAreCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "UsersAreCoords", runtime.ParamLocationQuery, *params.UsersAreCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostAccountsRequest calls the generic SlurmdbV0041PostAccounts builder with application/json body
func NewSlurmdbV0041PostAccountsRequest(server string, body SlurmdbV0041PostAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostAccountsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostAccountsRequestWithBody generates requests for SlurmdbV0041PostAccounts with any type of body
func NewSlurmdbV0041PostAccountsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/accounts/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041PostAccountsAssociationRequest calls the generic SlurmdbV0041PostAccountsAssociation builder with application/json body
func NewSlurmdbV0041PostAccountsAssociationRequest(server string, body SlurmdbV0041PostAccountsAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostAccountsAssociationRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostAccountsAssociationRequestWithBody generates requests for SlurmdbV0041PostAccountsAssociation with any type of body
func NewSlurmdbV0041PostAccountsAssociationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/accounts_association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteAssociationRequest generates requests for SlurmdbV0041DeleteAssociation
func NewSlurmdbV0041DeleteAssociationRequest(server string, params *SlurmdbV0041DeleteAssociationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAssociationRequest generates requests for SlurmdbV0041GetAssociation
func NewSlurmdbV0041GetAssociationRequest(server string, params *SlurmdbV0041GetAssociationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041DeleteAssociationsRequest generates requests for SlurmdbV0041DeleteAssociations
func NewSlurmdbV0041DeleteAssociationsRequest(server string, params *SlurmdbV0041DeleteAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAssociationsRequest generates requests for SlurmdbV0041GetAssociations
func NewSlurmdbV0041GetAssociationsRequest(server string, params *SlurmdbV0041GetAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostAssociationsRequest calls the generic SlurmdbV0041PostAssociations builder with application/json body
func NewSlurmdbV0041PostAssociationsRequest(server string, body SlurmdbV0041PostAssociationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostAssociationsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostAssociationsRequestWithBody generates requests for SlurmdbV0041PostAssociations with any type of body
func NewSlurmdbV0041PostAssociationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteClusterRequest generates requests for SlurmdbV0041DeleteCluster
func NewSlurmdbV0041DeleteClusterRequest(server string, clusterName string, params *SlurmdbV0041DeleteClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_name", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Classification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "classification", runtime.ParamLocationQuery, *params.Classification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Federation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "federation", runtime.ParamLocationQuery, *params.Federation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RpcVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rpc_version", runtime.ParamLocationQuery, *params.RpcVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetClusterRequest generates requests for SlurmdbV0041GetCluster
func NewSlurmdbV0041GetClusterRequest(server string, clusterName string, params *SlurmdbV0041GetClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_name", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Classification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "classification", runtime.ParamLocationQuery, *params.Classification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Federation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "federation", runtime.ParamLocationQuery, *params.Federation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RpcVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rpc_version", runtime.ParamLocationQuery, *params.RpcVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetClustersRequest generates requests for SlurmdbV0041GetClusters
func NewSlurmdbV0041GetClustersRequest(server string, params *SlurmdbV0041GetClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/clusters/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostClustersRequest calls the generic SlurmdbV0041PostClusters builder with application/json body
func NewSlurmdbV0041PostClustersRequest(server string, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostClustersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostClustersRequestWithBody generates requests for SlurmdbV0041PostClusters with any type of body
func NewSlurmdbV0041PostClustersRequestWithBody(server string, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/clusters/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041GetConfigRequest generates requests for SlurmdbV0041GetConfig
func NewSlurmdbV0041GetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostConfigRequest calls the generic SlurmdbV0041PostConfig builder with application/json body
func NewSlurmdbV0041PostConfigRequest(server string, body SlurmdbV0041PostConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostConfigRequestWithBody generates requests for SlurmdbV0041PostConfig with any type of body
func NewSlurmdbV0041PostConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041GetDiagRequest generates requests for SlurmdbV0041GetDiag
func NewSlurmdbV0041GetDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/diag/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetInstanceRequest generates requests for SlurmdbV0041GetInstance
func NewSlurmdbV0041GetInstanceRequest(server string, params *SlurmdbV0041GetInstanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/instance/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Extra != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "extra", runtime.ParamLocationQuery, *params.Extra); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_id", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_type", runtime.ParamLocationQuery, *params.InstanceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodeList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node_list", runtime.ParamLocationQuery, *params.NodeList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_end", runtime.ParamLocationQuery, *params.TimeEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_start", runtime.ParamLocationQuery, *params.TimeStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetInstancesRequest generates requests for SlurmdbV0041GetInstances
func NewSlurmdbV0041GetInstancesRequest(server string, params *SlurmdbV0041GetInstancesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/instances/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Extra != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "extra", runtime.ParamLocationQuery, *params.Extra); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_id", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_type", runtime.ParamLocationQuery, *params.InstanceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodeList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node_list", runtime.ParamLocationQuery, *params.NodeList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_end", runtime.ParamLocationQuery, *params.TimeEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_start", runtime.ParamLocationQuery, *params.TimeStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetJobRequest generates requests for SlurmdbV0041GetJob
func NewSlurmdbV0041GetJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetJobsRequest generates requests for SlurmdbV0041GetJobs
func NewSlurmdbV0041GetJobsRequest(server string, params *SlurmdbV0041GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Association != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "association", runtime.ParamLocationQuery, *params.Association); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Constraints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "constraints", runtime.ParamLocationQuery, *params.Constraints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchedulerUnset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduler_unset", runtime.ParamLocationQuery, *params.SchedulerUnset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledOnSubmit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_on_submit", runtime.ParamLocationQuery, *params.ScheduledOnSubmit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledByMain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_by_main", runtime.ParamLocationQuery, *params.ScheduledByMain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledByBackfill != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_by_backfill", runtime.ParamLocationQuery, *params.ScheduledByBackfill); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobStarted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_started", runtime.ParamLocationQuery, *params.JobStarted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExitCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exit_code", runtime.ParamLocationQuery, *params.ExitCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowDuplicates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_duplicates", runtime.ParamLocationQuery, *params.ShowDuplicates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipSteps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "skip_steps", runtime.ParamLocationQuery, *params.SkipSteps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableTruncateUsageTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_truncate_usage_time", runtime.ParamLocationQuery, *params.DisableTruncateUsageTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WholeHetjob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "whole_hetjob", runtime.ParamLocationQuery, *params.WholeHetjob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableWholeHetjob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_whole_hetjob", runtime.ParamLocationQuery, *params.DisableWholeHetjob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableWaitForResult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_wait_for_result", runtime.ParamLocationQuery, *params.DisableWaitForResult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageTimeAsSubmitTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_time_as_submit_time", runtime.ParamLocationQuery, *params.UsageTimeAsSubmitTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowBatchScript != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_batch_script", runtime.ParamLocationQuery, *params.ShowBatchScript); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowJobEnvironment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_job_environment", runtime.ParamLocationQuery, *params.ShowJobEnvironment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Groups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "groups", runtime.ParamLocationQuery, *params.Groups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_name", runtime.ParamLocationQuery, *params.JobName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reason", runtime.ParamLocationQuery, *params.Reason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reservation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reservation", runtime.ParamLocationQuery, *params.Reservation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReservationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reservation_id", runtime.ParamLocationQuery, *params.ReservationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Step != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "step", runtime.ParamLocationQuery, *params.Step); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Node != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node", runtime.ParamLocationQuery, *params.Node); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Users != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "users", runtime.ParamLocationQuery, *params.Users); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Wckey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "wckey", runtime.ParamLocationQuery, *params.Wckey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetQosRequest generates requests for SlurmdbV0041GetQos
func NewSlurmdbV0041GetQosRequest(server string, params *SlurmdbV0041GetQosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreemptMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "preempt_mode", runtime.ParamLocationQuery, *params.PreemptMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostQosRequest calls the generic SlurmdbV0041PostQos builder with application/json body
func NewSlurmdbV0041PostQosRequest(server string, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostQosRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostQosRequestWithBody generates requests for SlurmdbV0041PostQos with any type of body
func NewSlurmdbV0041PostQosRequestWithBody(server string, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreemptMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "preempt_mode", runtime.ParamLocationQuery, *params.PreemptMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteSingleQosRequest generates requests for SlurmdbV0041DeleteSingleQos
func NewSlurmdbV0041DeleteSingleQosRequest(server string, qos string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "qos", runtime.ParamLocationPath, qos)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetSingleQosRequest generates requests for SlurmdbV0041GetSingleQos
func NewSlurmdbV0041GetSingleQosRequest(server string, qos string, params *SlurmdbV0041GetSingleQosParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "qos", runtime.ParamLocationPath, qos)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetTresRequest generates requests for SlurmdbV0041GetTres
func NewSlurmdbV0041GetTresRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/tres/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostTresRequest calls the generic SlurmdbV0041PostTres builder with application/json body
func NewSlurmdbV0041PostTresRequest(server string, body SlurmdbV0041PostTresJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostTresRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostTresRequestWithBody generates requests for SlurmdbV0041PostTres with any type of body
func NewSlurmdbV0041PostTresRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/tres/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteUserRequest generates requests for SlurmdbV0041DeleteUser
func NewSlurmdbV0041DeleteUserRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetUserRequest generates requests for SlurmdbV0041GetUser
func NewSlurmdbV0041GetUserRequest(server string, name string, params *SlurmdbV0041GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWckeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_wckeys", runtime.ParamLocationQuery, *params.WithWckeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetUsersRequest generates requests for SlurmdbV0041GetUsers
func NewSlurmdbV0041GetUsersRequest(server string, params *SlurmdbV0041GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/users/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AdminLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "admin_level", runtime.ParamLocationQuery, *params.AdminLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_account", runtime.ParamLocationQuery, *params.DefaultAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultWckey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_wckey", runtime.ParamLocationQuery, *params.DefaultWckey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWckeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_wckeys", runtime.ParamLocationQuery, *params.WithWckeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_defaults", runtime.ParamLocationQuery, *params.WithoutDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostUsersRequest calls the generic SlurmdbV0041PostUsers builder with application/json body
func NewSlurmdbV0041PostUsersRequest(server string, body SlurmdbV0041PostUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostUsersRequestWithBody generates requests for SlurmdbV0041PostUsers with any type of body
func NewSlurmdbV0041PostUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/users/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041PostUsersAssociationRequest calls the generic SlurmdbV0041PostUsersAssociation builder with application/json body
func NewSlurmdbV0041PostUsersAssociationRequest(server string, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostUsersAssociationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostUsersAssociationRequestWithBody generates requests for SlurmdbV0041PostUsersAssociation with any type of body
func NewSlurmdbV0041PostUsersAssociationRequestWithBody(server string, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/users_association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteWckeyRequest generates requests for SlurmdbV0041DeleteWckey
func NewSlurmdbV0041DeleteWckeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetWckeyRequest generates requests for SlurmdbV0041GetWckey
func NewSlurmdbV0041GetWckeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetWckeysRequest generates requests for SlurmdbV0041GetWckeys
func NewSlurmdbV0041GetWckeysRequest(server string, params *SlurmdbV0041GetWckeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckeys/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostWckeysRequest calls the generic SlurmdbV0041PostWckeys builder with application/json body
func NewSlurmdbV0041PostWckeysRequest(server string, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostWckeysRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostWckeysRequestWithBody generates requests for SlurmdbV0041PostWckeys with any type of body
func NewSlurmdbV0041PostWckeysRequestWithBody(server string, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckeys/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SlurmV0041GetDiagWithResponse request
	SlurmV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetDiagResponse, error)

	// SlurmV0041PostJobAllocateWithBodyWithResponse request with any body
	SlurmV0041PostJobAllocateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error)

	SlurmV0041PostJobAllocateWithResponse(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error)

	// SlurmV0041PostJobSubmitWithBodyWithResponse request with any body
	SlurmV0041PostJobSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error)

	SlurmV0041PostJobSubmitWithResponse(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error)

	// SlurmV0041DeleteJobWithResponse request
	SlurmV0041DeleteJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobResponse, error)

	// SlurmV0041GetJobWithResponse request
	SlurmV0041GetJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobResponse, error)

	// SlurmV0041PostJobWithBodyWithResponse request with any body
	SlurmV0041PostJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error)

	SlurmV0041PostJobWithResponse(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error)

	// SlurmV0041DeleteJobsWithBodyWithResponse request with any body
	SlurmV0041DeleteJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error)

	SlurmV0041DeleteJobsWithResponse(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error)

	// SlurmV0041GetJobsWithResponse request
	SlurmV0041GetJobsWithResponse(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsResponse, error)

	// SlurmV0041GetJobsStateWithResponse request
	SlurmV0041GetJobsStateWithResponse(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsStateResponse, error)

	// SlurmV0041GetLicensesWithResponse request
	SlurmV0041GetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetLicensesResponse, error)

	// SlurmV0041DeleteNodeWithResponse request
	SlurmV0041DeleteNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteNodeResponse, error)

	// SlurmV0041GetNodeWithResponse request
	SlurmV0041GetNodeWithResponse(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodeResponse, error)

	// SlurmV0041PostNodeWithBodyWithResponse request with any body
	SlurmV0041PostNodeWithBodyWithResponse(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error)

	SlurmV0041PostNodeWithResponse(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error)

	// SlurmV0041GetNodesWithResponse request
	SlurmV0041GetNodesWithResponse(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodesResponse, error)

	// SlurmV0041PostNodesWithBodyWithResponse request with any body
	SlurmV0041PostNodesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodesResponse, error)

	SlurmV0041PostNodesWithResponse(ctx context.Context, body SlurmV0041PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodesResponse, error)

	// SlurmV0041GetPartitionWithResponse request
	SlurmV0041GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionResponse, error)

	// SlurmV0041GetPartitionsWithResponse request
	SlurmV0041GetPartitionsWithResponse(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionsResponse, error)

	// SlurmV0041GetPingWithResponse request
	SlurmV0041GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetPingResponse, error)

	// SlurmV0041GetReconfigureWithResponse request
	SlurmV0041GetReconfigureWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetReconfigureResponse, error)

	// SlurmV0041GetReservationWithResponse request
	SlurmV0041GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationResponse, error)

	// SlurmV0041GetReservationsWithResponse request
	SlurmV0041GetReservationsWithResponse(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationsResponse, error)

	// SlurmV0041GetSharesWithResponse request
	SlurmV0041GetSharesWithResponse(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetSharesResponse, error)

	// SlurmdbV0041DeleteAccountWithResponse request
	SlurmdbV0041DeleteAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAccountResponse, error)

	// SlurmdbV0041GetAccountWithResponse request
	SlurmdbV0041GetAccountWithResponse(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountResponse, error)

	// SlurmdbV0041GetAccountsWithResponse request
	SlurmdbV0041GetAccountsWithResponse(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountsResponse, error)

	// SlurmdbV0041PostAccountsWithBodyWithResponse request with any body
	SlurmdbV0041PostAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error)

	SlurmdbV0041PostAccountsWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error)

	// SlurmdbV0041PostAccountsAssociationWithBodyWithResponse request with any body
	SlurmdbV0041PostAccountsAssociationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error)

	SlurmdbV0041PostAccountsAssociationWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error)

	// SlurmdbV0041DeleteAssociationWithResponse request
	SlurmdbV0041DeleteAssociationWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationResponse, error)

	// SlurmdbV0041GetAssociationWithResponse request
	SlurmdbV0041GetAssociationWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationResponse, error)

	// SlurmdbV0041DeleteAssociationsWithResponse request
	SlurmdbV0041DeleteAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationsResponse, error)

	// SlurmdbV0041GetAssociationsWithResponse request
	SlurmdbV0041GetAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationsResponse, error)

	// SlurmdbV0041PostAssociationsWithBodyWithResponse request with any body
	SlurmdbV0041PostAssociationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error)

	SlurmdbV0041PostAssociationsWithResponse(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error)

	// SlurmdbV0041DeleteClusterWithResponse request
	SlurmdbV0041DeleteClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteClusterResponse, error)

	// SlurmdbV0041GetClusterWithResponse request
	SlurmdbV0041GetClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClusterResponse, error)

	// SlurmdbV0041GetClustersWithResponse request
	SlurmdbV0041GetClustersWithResponse(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClustersResponse, error)

	// SlurmdbV0041PostClustersWithBodyWithResponse request with any body
	SlurmdbV0041PostClustersWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error)

	SlurmdbV0041PostClustersWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error)

	// SlurmdbV0041GetConfigWithResponse request
	SlurmdbV0041GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetConfigResponse, error)

	// SlurmdbV0041PostConfigWithBodyWithResponse request with any body
	SlurmdbV0041PostConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error)

	SlurmdbV0041PostConfigWithResponse(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error)

	// SlurmdbV0041GetDiagWithResponse request
	SlurmdbV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetDiagResponse, error)

	// SlurmdbV0041GetInstanceWithResponse request
	SlurmdbV0041GetInstanceWithResponse(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstanceResponse, error)

	// SlurmdbV0041GetInstancesWithResponse request
	SlurmdbV0041GetInstancesWithResponse(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstancesResponse, error)

	// SlurmdbV0041GetJobWithResponse request
	SlurmdbV0041GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobResponse, error)

	// SlurmdbV0041GetJobsWithResponse request
	SlurmdbV0041GetJobsWithResponse(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobsResponse, error)

	// SlurmdbV0041GetQosWithResponse request
	SlurmdbV0041GetQosWithResponse(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetQosResponse, error)

	// SlurmdbV0041PostQosWithBodyWithResponse request with any body
	SlurmdbV0041PostQosWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error)

	SlurmdbV0041PostQosWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error)

	// SlurmdbV0041DeleteSingleQosWithResponse request
	SlurmdbV0041DeleteSingleQosWithResponse(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteSingleQosResponse, error)

	// SlurmdbV0041GetSingleQosWithResponse request
	SlurmdbV0041GetSingleQosWithResponse(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetSingleQosResponse, error)

	// SlurmdbV0041GetTresWithResponse request
	SlurmdbV0041GetTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetTresResponse, error)

	// SlurmdbV0041PostTresWithBodyWithResponse request with any body
	SlurmdbV0041PostTresWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error)

	SlurmdbV0041PostTresWithResponse(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error)

	// SlurmdbV0041DeleteUserWithResponse request
	SlurmdbV0041DeleteUserWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteUserResponse, error)

	// SlurmdbV0041GetUserWithResponse request
	SlurmdbV0041GetUserWithResponse(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUserResponse, error)

	// SlurmdbV0041GetUsersWithResponse request
	SlurmdbV0041GetUsersWithResponse(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUsersResponse, error)

	// SlurmdbV0041PostUsersWithBodyWithResponse request with any body
	SlurmdbV0041PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error)

	SlurmdbV0041PostUsersWithResponse(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error)

	// SlurmdbV0041PostUsersAssociationWithBodyWithResponse request with any body
	SlurmdbV0041PostUsersAssociationWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error)

	SlurmdbV0041PostUsersAssociationWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error)

	// SlurmdbV0041DeleteWckeyWithResponse request
	SlurmdbV0041DeleteWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteWckeyResponse, error)

	// SlurmdbV0041GetWckeyWithResponse request
	SlurmdbV0041GetWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeyResponse, error)

	// SlurmdbV0041GetWckeysWithResponse request
	SlurmdbV0041GetWckeysWithResponse(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeysResponse, error)

	// SlurmdbV0041PostWckeysWithBodyWithResponse request with any body
	SlurmdbV0041PostWckeysWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error)

	SlurmdbV0041PostWckeysWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error)
}

type SlurmV0041GetDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Statistics statistics
		Statistics struct {
			// AgentCount Number of agent threads
			AgentCount *int32 `json:"agent_count,omitempty"`

			// AgentQueueSize Number of enqueued outgoing RPC requests in an internal retry list
			AgentQueueSize *int32 `json:"agent_queue_size,omitempty"`

			// AgentThreadCount Total number of active threads created by all agent threads
			AgentThreadCount *int32 `json:"agent_thread_count,omitempty"`

			// BfActive Backfill scheduler currently running
			BfActive *bool `json:"bf_active,omitempty"`

			// BfBackfilledHetJobs Number of heterogeneous job components started through backfilling since last Slurm start
			BfBackfilledHetJobs *int32 `json:"bf_backfilled_het_jobs,omitempty"`

			// BfBackfilledJobs Number of jobs started through backfilling since last slurm start
			BfBackfilledJobs *int32 `json:"bf_backfilled_jobs,omitempty"`

			// BfCycleCounter Number of backfill scheduling cycles since last reset
			BfCycleCounter *int32 `json:"bf_cycle_counter,omitempty"`

			// BfCycleLast Execution time in microseconds of last backfill scheduling cycle
			BfCycleLast *int32 `json:"bf_cycle_last,omitempty"`

			// BfCycleMax Execution time in microseconds of longest backfill scheduling cycle
			BfCycleMax *int32 `json:"bf_cycle_max,omitempty"`

			// BfCycleMean Mean time in microseconds of backfilling scheduling cycles since last reset
			BfCycleMean *int64 `json:"bf_cycle_mean,omitempty"`

			// BfCycleSum Total time in microseconds of backfilling scheduling cycles since last reset
			BfCycleSum *int64 `json:"bf_cycle_sum,omitempty"`

			// BfDepthMean Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
			BfDepthMean *int64 `json:"bf_depth_mean,omitempty"`

			// BfDepthMeanTry The subset of Depth Mean that the backfill scheduler attempted to schedule
			BfDepthMeanTry *int64 `json:"bf_depth_mean_try,omitempty"`

			// BfDepthSum Total number of jobs processed during all backfilling scheduling cycles since last reset
			BfDepthSum *int32 `json:"bf_depth_sum,omitempty"`

			// BfDepthTrySum Subset of bf_depth_sum that the backfill scheduler attempted to schedule
			BfDepthTrySum *int32 `json:"bf_depth_try_sum,omitempty"`

			// BfExit Reasons for which the backfill scheduling cycle exited since last reset
			BfExit *struct {
				// BfMaxJobStart Reached number of jobs allowed to start
				BfMaxJobStart *int32 `json:"bf_max_job_start,omitempty"`

				// BfMaxJobTest Reached number of jobs allowed to be tested
				BfMaxJobTest *int32 `json:"bf_max_job_test,omitempty"`

				// BfMaxTime Reached maximum allowed scheduler time
				BfMaxTime *int32 `json:"bf_max_time,omitempty"`

				// BfNodeSpaceSize Reached table size limit
				BfNodeSpaceSize *int32 `json:"bf_node_space_size,omitempty"`

				// EndJobQueue Reached end of queue
				EndJobQueue *int32 `json:"end_job_queue,omitempty"`

				// StateChanged System state changed
				StateChanged *int32 `json:"state_changed,omitempty"`
			} `json:"bf_exit,omitempty"`

			// BfLastBackfilledJobs Number of jobs started through backfilling since last reset
			BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`

			// BfLastDepth Number of processed jobs during last backfilling scheduling cycle
			BfLastDepth *int32 `json:"bf_last_depth,omitempty"`

			// BfLastDepthTry Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
			BfLastDepthTry *int32 `json:"bf_last_depth_try,omitempty"`

			// BfQueueLen Number of jobs pending to be processed by backfilling algorithm
			BfQueueLen *int32 `json:"bf_queue_len,omitempty"`

			// BfQueueLenMean Mean number of jobs pending to be processed by backfilling algorithm
			BfQueueLenMean *int64 `json:"bf_queue_len_mean,omitempty"`

			// BfQueueLenSum Total number of jobs pending to be processed by backfilling algorithm since last reset
			BfQueueLenSum *int32 `json:"bf_queue_len_sum,omitempty"`

			// BfTableSize Number of different time slots tested by the backfill scheduler in its last iteration
			BfTableSize *int32 `json:"bf_table_size,omitempty"`

			// BfTableSizeMean Mean number of different time slots tested by the backfill scheduler
			BfTableSizeMean *int64 `json:"bf_table_size_mean,omitempty"`

			// BfTableSizeSum Total number of different time slots tested by the backfill scheduler
			BfTableSizeSum *int32 `json:"bf_table_size_sum,omitempty"`

			// BfWhenLastCycle When the last backfill scheduling cycle happened (UNIX timestamp)
			BfWhenLastCycle *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"bf_when_last_cycle,omitempty"`

			// DbdAgentQueueSize Number of messages for SlurmDBD that are queued
			DbdAgentQueueSize *int32 `json:"dbd_agent_queue_size,omitempty"`

			// GettimeofdayLatency Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
			GettimeofdayLatency *int32 `json:"gettimeofday_latency,omitempty"`

			// JobStatesTs When the job state counts were gathered (UNIX timestamp)
			JobStatesTs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"job_states_ts,omitempty"`

			// JobsCanceled Number of jobs canceled since the last reset
			JobsCanceled *int32 `json:"jobs_canceled,omitempty"`

			// JobsCompleted Number of jobs completed since last reset
			JobsCompleted *int32 `json:"jobs_completed,omitempty"`

			// JobsFailed Number of jobs failed due to slurmd or other internal issues since last reset
			JobsFailed *int32 `json:"jobs_failed,omitempty"`

			// JobsPending Number of jobs pending at the time of listed in job_state_ts
			JobsPending *int32 `json:"jobs_pending,omitempty"`

			// JobsRunning Number of jobs running at the time of listed in job_state_ts
			JobsRunning *int32 `json:"jobs_running,omitempty"`

			// JobsStarted Number of jobs started since last reset
			JobsStarted *int32 `json:"jobs_started,omitempty"`

			// JobsSubmitted Number of jobs submitted since last reset
			JobsSubmitted *int32 `json:"jobs_submitted,omitempty"`

			// PartsPacked Zero if only RPC statistic included
			PartsPacked *int32 `json:"parts_packed,omitempty"`

			// PendingRpcs Pending RPC statistics
			PendingRpcs *[]struct {
				// Count Number of pending RPCs queued
				Count int32 `json:"count"`

				// MessageType Message type as string
				MessageType string `json:"message_type"`

				// TypeId Message type as integer
				TypeId int32 `json:"type_id"`
			} `json:"pending_rpcs,omitempty"`

			// PendingRpcsByHostlist Pending RPCs hostlists
			PendingRpcsByHostlist *[]struct {
				// Count Number of RPCs received
				Count []string `json:"count"`

				// MessageType Message type as string
				MessageType string `json:"message_type"`

				// TypeId Message type as integer
				TypeId int32 `json:"type_id"`
			} `json:"pending_rpcs_by_hostlist,omitempty"`

			// ReqTime When the request was made (UNIX timestamp)
			ReqTime *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"req_time,omitempty"`

			// ReqTimeStart When the data in the report started (UNIX timestamp)
			ReqTimeStart *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"req_time_start,omitempty"`

			// RpcsByMessageType Most frequently issued remote procedure calls (RPCs)
			RpcsByMessageType *[]struct {
				// AverageTime Average time spent processing RPC in seconds
				AverageTime struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"average_time"`

				// Count Number of RPCs received
				Count int32 `json:"count"`

				// CycleLast Number of RPCs processed within the last RPC queue cycle
				CycleLast int32 `json:"cycle_last"`

				// CycleMax Maximum number of RPCs processed within a RPC queue cycle since start
				CycleMax int32 `json:"cycle_max"`

				// Dropped Number of RPCs dropped
				Dropped int64 `json:"dropped"`

				// MessageType Message type as string
				MessageType string `json:"message_type"`

				// Queued Number of RPCs queued
				Queued int32 `json:"queued"`

				// TotalTime Total time spent processing RPC in seconds
				TotalTime int64 `json:"total_time"`

				// TypeId Message type as integer
				TypeId int32 `json:"type_id"`
			} `json:"rpcs_by_message_type,omitempty"`

			// RpcsByUser RPCs issued by user ID
			RpcsByUser *[]struct {
				// AverageTime Average time spent processing RPC in seconds
				AverageTime struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"average_time"`

				// Count Number of RPCs received
				Count int32 `json:"count"`

				// TotalTime Total time spent processing RPC in seconds
				TotalTime int64 `json:"total_time"`

				// User User name
				User string `json:"user"`

				// UserId User ID (numeric)
				UserId int32 `json:"user_id"`
			} `json:"rpcs_by_user,omitempty"`

			// ScheduleCycleDepth Total number of jobs processed in scheduling cycles
			ScheduleCycleDepth *int32 `json:"schedule_cycle_depth,omitempty"`

			// ScheduleCycleLast Time in microseconds for last scheduling cycle
			ScheduleCycleLast *int32 `json:"schedule_cycle_last,omitempty"`

			// ScheduleCycleMax Max time of any scheduling cycle in microseconds since last reset
			ScheduleCycleMax *int32 `json:"schedule_cycle_max,omitempty"`

			// ScheduleCycleMean Mean time in microseconds for all scheduling cycles since last reset
			ScheduleCycleMean *int64 `json:"schedule_cycle_mean,omitempty"`

			// ScheduleCycleMeanDepth Mean of the number of jobs processed in a scheduling cycle
			ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`

			// ScheduleCyclePerMinute Number of scheduling executions per minute
			ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`

			// ScheduleCycleSum Total run time in microseconds for all scheduling cycles since last reset
			ScheduleCycleSum *int32 `json:"schedule_cycle_sum,omitempty"`

			// ScheduleCycleTotal Number of scheduling cycles since last reset
			ScheduleCycleTotal *int32 `json:"schedule_cycle_total,omitempty"`

			// ScheduleExit Reasons for which the scheduling cycle exited since last reset
			ScheduleExit *struct {
				// DefaultQueueDepth Reached number of jobs allowed to be tested
				DefaultQueueDepth *int32 `json:"default_queue_depth,omitempty"`

				// EndJobQueue Reached end of queue
				EndJobQueue *int32 `json:"end_job_queue,omitempty"`

				// Licenses Blocked on licenses
				Licenses *int32 `json:"licenses,omitempty"`

				// MaxJobStart Reached number of jobs allowed to start
				MaxJobStart *int32 `json:"max_job_start,omitempty"`

				// MaxRpcCnt Reached RPC limit
				MaxRpcCnt *int32 `json:"max_rpc_cnt,omitempty"`

				// MaxSchedTime Reached maximum allowed scheduler time
				MaxSchedTime *int32 `json:"max_sched_time,omitempty"`
			} `json:"schedule_exit,omitempty"`

			// ScheduleQueueLength Number of jobs pending in queue
			ScheduleQueueLength *int32 `json:"schedule_queue_length,omitempty"`

			// ServerThreadCount Number of current active slurmctld threads
			ServerThreadCount *int32 `json:"server_thread_count,omitempty"`
		} `json:"statistics"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Statistics statistics
		Statistics struct {
			// AgentCount Number of agent threads
			AgentCount *int32 `json:"agent_count,omitempty"`

			// AgentQueueSize Number of enqueued outgoing RPC requests in an internal retry list
			AgentQueueSize *int32 `json:"agent_queue_size,omitempty"`

			// AgentThreadCount Total number of active threads created by all agent threads
			AgentThreadCount *int32 `json:"agent_thread_count,omitempty"`

			// BfActive Backfill scheduler currently running
			BfActive *bool `json:"bf_active,omitempty"`

			// BfBackfilledHetJobs Number of heterogeneous job components started through backfilling since last Slurm start
			BfBackfilledHetJobs *int32 `json:"bf_backfilled_het_jobs,omitempty"`

			// BfBackfilledJobs Number of jobs started through backfilling since last slurm start
			BfBackfilledJobs *int32 `json:"bf_backfilled_jobs,omitempty"`

			// BfCycleCounter Number of backfill scheduling cycles since last reset
			BfCycleCounter *int32 `json:"bf_cycle_counter,omitempty"`

			// BfCycleLast Execution time in microseconds of last backfill scheduling cycle
			BfCycleLast *int32 `json:"bf_cycle_last,omitempty"`

			// BfCycleMax Execution time in microseconds of longest backfill scheduling cycle
			BfCycleMax *int32 `json:"bf_cycle_max,omitempty"`

			// BfCycleMean Mean time in microseconds of backfilling scheduling cycles since last reset
			BfCycleMean *int64 `json:"bf_cycle_mean,omitempty"`

			// BfCycleSum Total time in microseconds of backfilling scheduling cycles since last reset
			BfCycleSum *int64 `json:"bf_cycle_sum,omitempty"`

			// BfDepthMean Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
			BfDepthMean *int64 `json:"bf_depth_mean,omitempty"`

			// BfDepthMeanTry The subset of Depth Mean that the backfill scheduler attempted to schedule
			BfDepthMeanTry *int64 `json:"bf_depth_mean_try,omitempty"`

			// BfDepthSum Total number of jobs processed during all backfilling scheduling cycles since last reset
			BfDepthSum *int32 `json:"bf_depth_sum,omitempty"`

			// BfDepthTrySum Subset of bf_depth_sum that the backfill scheduler attempted to schedule
			BfDepthTrySum *int32 `json:"bf_depth_try_sum,omitempty"`

			// BfExit Reasons for which the backfill scheduling cycle exited since last reset
			BfExit *struct {
				// BfMaxJobStart Reached number of jobs allowed to start
				BfMaxJobStart *int32 `json:"bf_max_job_start,omitempty"`

				// BfMaxJobTest Reached number of jobs allowed to be tested
				BfMaxJobTest *int32 `json:"bf_max_job_test,omitempty"`

				// BfMaxTime Reached maximum allowed scheduler time
				BfMaxTime *int32 `json:"bf_max_time,omitempty"`

				// BfNodeSpaceSize Reached table size limit
				BfNodeSpaceSize *int32 `json:"bf_node_space_size,omitempty"`

				// EndJobQueue Reached end of queue
				EndJobQueue *int32 `json:"end_job_queue,omitempty"`

				// StateChanged System state changed
				StateChanged *int32 `json:"state_changed,omitempty"`
			} `json:"bf_exit,omitempty"`

			// BfLastBackfilledJobs Number of jobs started through backfilling since last reset
			BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`

			// BfLastDepth Number of processed jobs during last backfilling scheduling cycle
			BfLastDepth *int32 `json:"bf_last_depth,omitempty"`

			// BfLastDepthTry Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
			BfLastDepthTry *int32 `json:"bf_last_depth_try,omitempty"`

			// BfQueueLen Number of jobs pending to be processed by backfilling algorithm
			BfQueueLen *int32 `json:"bf_queue_len,omitempty"`

			// BfQueueLenMean Mean number of jobs pending to be processed by backfilling algorithm
			BfQueueLenMean *int64 `json:"bf_queue_len_mean,omitempty"`

			// BfQueueLenSum Total number of jobs pending to be processed by backfilling algorithm since last reset
			BfQueueLenSum *int32 `json:"bf_queue_len_sum,omitempty"`

			// BfTableSize Number of different time slots tested by the backfill scheduler in its last iteration
			BfTableSize *int32 `json:"bf_table_size,omitempty"`

			// BfTableSizeMean Mean number of different time slots tested by the backfill scheduler
			BfTableSizeMean *int64 `json:"bf_table_size_mean,omitempty"`

			// BfTableSizeSum Total number of different time slots tested by the backfill scheduler
			BfTableSizeSum *int32 `json:"bf_table_size_sum,omitempty"`

			// BfWhenLastCycle When the last backfill scheduling cycle happened (UNIX timestamp)
			BfWhenLastCycle *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"bf_when_last_cycle,omitempty"`

			// DbdAgentQueueSize Number of messages for SlurmDBD that are queued
			DbdAgentQueueSize *int32 `json:"dbd_agent_queue_size,omitempty"`

			// GettimeofdayLatency Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
			GettimeofdayLatency *int32 `json:"gettimeofday_latency,omitempty"`

			// JobStatesTs When the job state counts were gathered (UNIX timestamp)
			JobStatesTs *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"job_states_ts,omitempty"`

			// JobsCanceled Number of jobs canceled since the last reset
			JobsCanceled *int32 `json:"jobs_canceled,omitempty"`

			// JobsCompleted Number of jobs completed since last reset
			JobsCompleted *int32 `json:"jobs_completed,omitempty"`

			// JobsFailed Number of jobs failed due to slurmd or other internal issues since last reset
			JobsFailed *int32 `json:"jobs_failed,omitempty"`

			// JobsPending Number of jobs pending at the time of listed in job_state_ts
			JobsPending *int32 `json:"jobs_pending,omitempty"`

			// JobsRunning Number of jobs running at the time of listed in job_state_ts
			JobsRunning *int32 `json:"jobs_running,omitempty"`

			// JobsStarted Number of jobs started since last reset
			JobsStarted *int32 `json:"jobs_started,omitempty"`

			// JobsSubmitted Number of jobs submitted since last reset
			JobsSubmitted *int32 `json:"jobs_submitted,omitempty"`

			// PartsPacked Zero if only RPC statistic included
			PartsPacked *int32 `json:"parts_packed,omitempty"`

			// PendingRpcs Pending RPC statistics
			PendingRpcs *[]struct {
				// Count Number of pending RPCs queued
				Count int32 `json:"count"`

				// MessageType Message type as string
				MessageType string `json:"message_type"`

				// TypeId Message type as integer
				TypeId int32 `json:"type_id"`
			} `json:"pending_rpcs,omitempty"`

			// PendingRpcsByHostlist Pending RPCs hostlists
			PendingRpcsByHostlist *[]struct {
				// Count Number of RPCs received
				Count []string `json:"count"`

				// MessageType Message type as string
				MessageType string `json:"message_type"`

				// TypeId Message type as integer
				TypeId int32 `json:"type_id"`
			} `json:"pending_rpcs_by_hostlist,omitempty"`

			// ReqTime When the request was made (UNIX timestamp)
			ReqTime *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"req_time,omitempty"`

			// ReqTimeStart When the data in the report started (UNIX timestamp)
			ReqTimeStart *struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"req_time_start,omitempty"`

			// RpcsByMessageType Most frequently issued remote procedure calls (RPCs)
			RpcsByMessageType *[]struct {
				// AverageTime Average time spent processing RPC in seconds
				AverageTime struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"average_time"`

				// Count Number of RPCs received
				Count int32 `json:"count"`

				// CycleLast Number of RPCs processed within the last RPC queue cycle
				CycleLast int32 `json:"cycle_last"`

				// CycleMax Maximum number of RPCs processed within a RPC queue cycle since start
				CycleMax int32 `json:"cycle_max"`

				// Dropped Number of RPCs dropped
				Dropped int64 `json:"dropped"`

				// MessageType Message type as string
				MessageType string `json:"message_type"`

				// Queued Number of RPCs queued
				Queued int32 `json:"queued"`

				// TotalTime Total time spent processing RPC in seconds
				TotalTime int64 `json:"total_time"`

				// TypeId Message type as integer
				TypeId int32 `json:"type_id"`
			} `json:"rpcs_by_message_type,omitempty"`

			// RpcsByUser RPCs issued by user ID
			RpcsByUser *[]struct {
				// AverageTime Average time spent processing RPC in seconds
				AverageTime struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"average_time"`

				// Count Number of RPCs received
				Count int32 `json:"count"`

				// TotalTime Total time spent processing RPC in seconds
				TotalTime int64 `json:"total_time"`

				// User User name
				User string `json:"user"`

				// UserId User ID (numeric)
				UserId int32 `json:"user_id"`
			} `json:"rpcs_by_user,omitempty"`

			// ScheduleCycleDepth Total number of jobs processed in scheduling cycles
			ScheduleCycleDepth *int32 `json:"schedule_cycle_depth,omitempty"`

			// ScheduleCycleLast Time in microseconds for last scheduling cycle
			ScheduleCycleLast *int32 `json:"schedule_cycle_last,omitempty"`

			// ScheduleCycleMax Max time of any scheduling cycle in microseconds since last reset
			ScheduleCycleMax *int32 `json:"schedule_cycle_max,omitempty"`

			// ScheduleCycleMean Mean time in microseconds for all scheduling cycles since last reset
			ScheduleCycleMean *int64 `json:"schedule_cycle_mean,omitempty"`

			// ScheduleCycleMeanDepth Mean of the number of jobs processed in a scheduling cycle
			ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`

			// ScheduleCyclePerMinute Number of scheduling executions per minute
			ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`

			// ScheduleCycleSum Total run time in microseconds for all scheduling cycles since last reset
			ScheduleCycleSum *int32 `json:"schedule_cycle_sum,omitempty"`

			// ScheduleCycleTotal Number of scheduling cycles since last reset
			ScheduleCycleTotal *int32 `json:"schedule_cycle_total,omitempty"`

			// ScheduleExit Reasons for which the scheduling cycle exited since last reset
			ScheduleExit *struct {
				// DefaultQueueDepth Reached number of jobs allowed to be tested
				DefaultQueueDepth *int32 `json:"default_queue_depth,omitempty"`

				// EndJobQueue Reached end of queue
				EndJobQueue *int32 `json:"end_job_queue,omitempty"`

				// Licenses Blocked on licenses
				Licenses *int32 `json:"licenses,omitempty"`

				// MaxJobStart Reached number of jobs allowed to start
				MaxJobStart *int32 `json:"max_job_start,omitempty"`

				// MaxRpcCnt Reached RPC limit
				MaxRpcCnt *int32 `json:"max_rpc_cnt,omitempty"`

				// MaxSchedTime Reached maximum allowed scheduler time
				MaxSchedTime *int32 `json:"max_sched_time,omitempty"`
			} `json:"schedule_exit,omitempty"`

			// ScheduleQueueLength Number of jobs pending in queue
			ScheduleQueueLength *int32 `json:"schedule_queue_length,omitempty"`

			// ServerThreadCount Number of current active slurmctld threads
			ServerThreadCount *int32 `json:"server_thread_count,omitempty"`
		} `json:"statistics"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostJobAllocateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId Submitted Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// JobSubmitUserMsg Job submission user message
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId Submitted Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// JobSubmitUserMsg Job submission user message
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostJobAllocateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostJobAllocateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostJobSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId Submitted Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// JobSubmitUserMsg Job submission user message
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Result Job submission
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Result *struct {
			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorCode Error code
			ErrorCode *int32 `json:"error_code,omitempty"`

			// JobId New job ID
			JobId *int32 `json:"job_id,omitempty"`

			// JobSubmitUserMsg Message to user from job_submit plugin
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// StepId New job step ID
			StepId *string `json:"step_id,omitempty"`
		} `json:"result,omitempty"`

		// StepId Submitted Step ID
		StepId *string `json:"step_id,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId Submitted Job ID
		JobId *int32 `json:"job_id,omitempty"`

		// JobSubmitUserMsg Job submission user message
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Result Job submission
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Result *struct {
			// Error Error message
			Error *string `json:"error,omitempty"`

			// ErrorCode Error code
			ErrorCode *int32 `json:"error_code,omitempty"`

			// JobId New job ID
			JobId *int32 `json:"job_id,omitempty"`

			// JobSubmitUserMsg Message to user from job_submit plugin
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// StepId New job step ID
			StepId *string `json:"step_id,omitempty"`
		} `json:"result,omitempty"`

		// StepId Submitted Step ID
		StepId *string `json:"step_id,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostJobSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostJobSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobInfoResp
	JSONDefault  *V0041OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId First updated Job ID - Use results instead
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		JobId *string `json:"job_id,omitempty"`

		// JobSubmitUserMsg First updated Job submission user message - Use results instead
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Results Job update results
		Results *[]struct {
			// Error Verbose update status or error
			Error *string `json:"error,omitempty"`

			// ErrorCode Verbose update status or error
			ErrorCode *int32 `json:"error_code,omitempty"`

			// JobId Job ID for updated job
			JobId *int32 `json:"job_id,omitempty"`

			// StepId Step ID for updated job
			StepId *string `json:"step_id,omitempty"`

			// Why Update response message
			Why *string `json:"why,omitempty"`
		} `json:"results,omitempty"`

		// StepId First updated Step ID - Use results instead
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		StepId *string `json:"step_id,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// JobId First updated Job ID - Use results instead
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		JobId *string `json:"job_id,omitempty"`

		// JobSubmitUserMsg First updated Job submission user message - Use results instead
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Results Job update results
		Results *[]struct {
			// Error Verbose update status or error
			Error *string `json:"error,omitempty"`

			// ErrorCode Verbose update status or error
			ErrorCode *int32 `json:"error_code,omitempty"`

			// JobId Job ID for updated job
			JobId *int32 `json:"job_id,omitempty"`

			// StepId Step ID for updated job
			StepId *string `json:"step_id,omitempty"`

			// Why Update response message
			Why *string `json:"why,omitempty"`
		} `json:"results,omitempty"`

		// StepId First updated Step ID - Use results instead
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		StepId *string `json:"step_id,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Status resultant status of signal request
		Status []struct {
			Error *struct {
				// Code Numeric error encountered signaling job
				Code *int32 `json:"code,omitempty"`

				// Message Error message why signaling job failed
				Message *string `json:"message,omitempty"`

				// String String error encountered signaling job
				String *string `json:"string,omitempty"`
			} `json:"error,omitempty"`
			Federation *struct {
				// Sibling Name of federation sibling (may be empty for non-federation)
				Sibling *string `json:"sibling,omitempty"`
			} `json:"federation,omitempty"`

			// JobId Job ID that signaling failed
			JobId struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"job_id"`

			// StepId Job or Step ID that signaling failed
			StepId string `json:"step_id"`
		} `json:"status"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Status resultant status of signal request
		Status []struct {
			Error *struct {
				// Code Numeric error encountered signaling job
				Code *int32 `json:"code,omitempty"`

				// Message Error message why signaling job failed
				Message *string `json:"message,omitempty"`

				// String String error encountered signaling job
				String *string `json:"string,omitempty"`
			} `json:"error,omitempty"`
			Federation *struct {
				// Sibling Name of federation sibling (may be empty for non-federation)
				Sibling *string `json:"sibling,omitempty"`
			} `json:"federation,omitempty"`

			// JobId Job ID that signaling failed
			JobId struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int32 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"job_id"`

			// StepId Job or Step ID that signaling failed
			StepId string `json:"step_id"`
		} `json:"status"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobInfoResp
	JSONDefault  *V0041OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetJobsStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobInfoResp
	JSONDefault  *V0041OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetJobsStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetJobsStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetLicensesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// LastUpdate Time of last licenses change (UNIX timestamp)
		LastUpdate struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"last_update"`

		// Licenses List of licenses
		Licenses []struct {
			// Free Number of licenses currently available
			Free *int32 `json:"Free,omitempty"`

			// LastConsumed Last known number of licenses that were consumed in the license manager (Remote Only)
			LastConsumed *int32 `json:"LastConsumed,omitempty"`

			// LastDeficit Number of "missing licenses" from the cluster's perspective
			LastDeficit *int32 `json:"LastDeficit,omitempty"`

			// LastUpdate When the license information was last updated (UNIX Timestamp)
			LastUpdate *int64 `json:"LastUpdate,omitempty"`

			// LicenseName Name of the license
			LicenseName *string `json:"LicenseName,omitempty"`

			// Remote Indicates whether licenses are served by the database
			Remote *bool `json:"Remote,omitempty"`

			// Reserved Number of licenses reserved
			Reserved *int32 `json:"Reserved,omitempty"`

			// Total Total number of licenses present
			Total *int32 `json:"Total,omitempty"`

			// Used Number of licenses in use
			Used *int32 `json:"Used,omitempty"`
		} `json:"licenses"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// LastUpdate Time of last licenses change (UNIX timestamp)
		LastUpdate struct {
			// Infinite True if number has been set to infinite; "set" and "number" will be ignored
			Infinite *bool `json:"infinite,omitempty"`

			// Number If "set" is True the number will be set with value; otherwise ignore number contents
			Number *int64 `json:"number,omitempty"`

			// Set True if number has been set; False if number is unset
			Set *bool `json:"set,omitempty"`
		} `json:"last_update"`

		// Licenses List of licenses
		Licenses []struct {
			// Free Number of licenses currently available
			Free *int32 `json:"Free,omitempty"`

			// LastConsumed Last known number of licenses that were consumed in the license manager (Remote Only)
			LastConsumed *int32 `json:"LastConsumed,omitempty"`

			// LastDeficit Number of "missing licenses" from the cluster's perspective
			LastDeficit *int32 `json:"LastDeficit,omitempty"`

			// LastUpdate When the license information was last updated (UNIX Timestamp)
			LastUpdate *int64 `json:"LastUpdate,omitempty"`

			// LicenseName Name of the license
			LicenseName *string `json:"LicenseName,omitempty"`

			// Remote Indicates whether licenses are served by the database
			Remote *bool `json:"Remote,omitempty"`

			// Reserved Number of licenses reserved
			Reserved *int32 `json:"Reserved,omitempty"`

			// Total Total number of licenses present
			Total *int32 `json:"Total,omitempty"`

			// Used Number of licenses in use
			Used *int32 `json:"Used,omitempty"`
		} `json:"licenses"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetLicensesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetLicensesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiNodesResp
	JSONDefault  *V0041OpenapiNodesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiNodesResp
	JSONDefault  *V0041OpenapiNodesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetPartitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiPartitionResp
	JSONDefault  *V0041OpenapiPartitionResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetPartitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetPartitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiPartitionResp
	JSONDefault  *V0041OpenapiPartitionResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Pings pings
		Pings []struct {
			// Hostname Target for ping
			Hostname *string `json:"hostname,omitempty"`

			// Latency Number of microseconds it took to successfully ping or timeout
			Latency *int64 `json:"latency,omitempty"`

			// Mode The operating mode of the responding slurmctld
			Mode *string `json:"mode,omitempty"`

			// Pinged Ping result
			Pinged *string `json:"pinged,omitempty"`
		} `json:"pings"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Pings pings
		Pings []struct {
			// Hostname Target for ping
			Hostname *string `json:"hostname,omitempty"`

			// Latency Number of microseconds it took to successfully ping or timeout
			Latency *int64 `json:"latency,omitempty"`

			// Mode The operating mode of the responding slurmctld
			Mode *string `json:"mode,omitempty"`

			// Pinged Ping result
			Pinged *string `json:"pinged,omitempty"`
		} `json:"pings"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetReconfigureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetReconfigureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetReconfigureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiReservationResp
	JSONDefault  *V0041OpenapiReservationResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiReservationResp
	JSONDefault  *V0041OpenapiReservationResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetSharesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSharesResp
	JSONDefault  *V0041OpenapiSharesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetSharesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetSharesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// RemovedAccounts removed_accounts
		RemovedAccounts []string `json:"removed_accounts"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// RemovedAccounts removed_accounts
		RemovedAccounts []string `json:"removed_accounts"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAccountsResp
	JSONDefault  *V0041OpenapiAccountsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAccountsResp
	JSONDefault  *V0041OpenapiAccountsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostAccountsAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AddedAccounts added_accounts
		AddedAccounts string `json:"added_accounts"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// AddedAccounts added_accounts
		AddedAccounts string `json:"added_accounts"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostAccountsAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostAccountsAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsRemovedResp
	JSONDefault  *V0041OpenapiAssocsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsResp
	JSONDefault  *V0041OpenapiAssocsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsRemovedResp
	JSONDefault  *V0041OpenapiAssocsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsResp
	JSONDefault  *V0041OpenapiAssocsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DeletedClusters deleted_clusters
		DeletedClusters []string `json:"deleted_clusters"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// DeletedClusters deleted_clusters
		DeletedClusters []string `json:"deleted_clusters"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiClustersResp
	JSONDefault  *V0041OpenapiClustersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiClustersResp
	JSONDefault  *V0041OpenapiClustersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdConfigResp
	JSONDefault  *V0041OpenapiSlurmdbdConfigResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Statistics statistics
		Statistics struct {
			// RPCs List of RPCs sent to the slurmdbd
			RPCs *[]struct {
				// Count Number of RPCs processed
				Count *int32 `json:"count,omitempty"`

				// Rpc RPC type
				Rpc  *string `json:"rpc,omitempty"`
				Time *struct {
					// Average Average RPC processing time in microseconds
					Average *int64 `json:"average,omitempty"`

					// Total Total RPC processing time in microseconds
					Total *int64 `json:"total,omitempty"`
				} `json:"time,omitempty"`
			} `json:"RPCs,omitempty"`

			// Rollups Rollup statistics
			Rollups *struct {
				Daily *struct {
					// Count Number of daily rollups since last_run
					Count    *int32 `json:"count,omitempty"`
					Duration *struct {
						// Last Total time spent doing daily daily rollup (seconds)
						Last *int64 `json:"last,omitempty"`

						// Max Longest daily rollup time (seconds)
						Max *int64 `json:"max,omitempty"`

						// Time Total time spent doing daily rollups (seconds)
						Time *int64 `json:"time,omitempty"`
					} `json:"duration,omitempty"`

					// LastRun Last time daily rollup ran (UNIX timestamp)
					LastRun *int64 `json:"last_run,omitempty"`
				} `json:"daily,omitempty"`
				Hourly *struct {
					// Count Number of hourly rollups since last_run
					Count    *int32 `json:"count,omitempty"`
					Duration *struct {
						// Last Total time spent doing last daily rollup (seconds)
						Last *int64 `json:"last,omitempty"`

						// Max Longest hourly rollup time (seconds)
						Max *int64 `json:"max,omitempty"`

						// Time Total time spent doing hourly rollups (seconds)
						Time *int64 `json:"time,omitempty"`
					} `json:"duration,omitempty"`

					// LastRun Last time hourly rollup ran (UNIX timestamp)
					LastRun *int64 `json:"last_run,omitempty"`
				} `json:"hourly,omitempty"`
				Monthly *struct {
					// Count Number of monthly rollups since last_run
					Count    *int32 `json:"count,omitempty"`
					Duration *struct {
						// Last Total time spent doing monthly daily rollup (seconds)
						Last *int64 `json:"last,omitempty"`

						// Max Longest monthly rollup time (seconds)
						Max *int64 `json:"max,omitempty"`

						// Time Total time spent doing monthly rollups (seconds)
						Time *int64 `json:"time,omitempty"`
					} `json:"duration,omitempty"`

					// LastRun Last time monthly rollup ran (UNIX timestamp)
					LastRun *int64 `json:"last_run,omitempty"`
				} `json:"monthly,omitempty"`
			} `json:"rollups,omitempty"`

			// TimeStart When data collection started (UNIX timestamp)
			TimeStart *int64 `json:"time_start,omitempty"`

			// Users List of users that issued RPCs
			Users *[]struct {
				// Count Number of RPCs processed
				Count *int32 `json:"count,omitempty"`
				Time  *struct {
					// Average Average RPC processing time in microseconds
					Average *int64 `json:"average,omitempty"`

					// Total Total RPC processing time in microseconds
					Total *int64 `json:"total,omitempty"`
				} `json:"time,omitempty"`

				// User User ID
				User *string `json:"user,omitempty"`
			} `json:"users,omitempty"`
		} `json:"statistics"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Statistics statistics
		Statistics struct {
			// RPCs List of RPCs sent to the slurmdbd
			RPCs *[]struct {
				// Count Number of RPCs processed
				Count *int32 `json:"count,omitempty"`

				// Rpc RPC type
				Rpc  *string `json:"rpc,omitempty"`
				Time *struct {
					// Average Average RPC processing time in microseconds
					Average *int64 `json:"average,omitempty"`

					// Total Total RPC processing time in microseconds
					Total *int64 `json:"total,omitempty"`
				} `json:"time,omitempty"`
			} `json:"RPCs,omitempty"`

			// Rollups Rollup statistics
			Rollups *struct {
				Daily *struct {
					// Count Number of daily rollups since last_run
					Count    *int32 `json:"count,omitempty"`
					Duration *struct {
						// Last Total time spent doing daily daily rollup (seconds)
						Last *int64 `json:"last,omitempty"`

						// Max Longest daily rollup time (seconds)
						Max *int64 `json:"max,omitempty"`

						// Time Total time spent doing daily rollups (seconds)
						Time *int64 `json:"time,omitempty"`
					} `json:"duration,omitempty"`

					// LastRun Last time daily rollup ran (UNIX timestamp)
					LastRun *int64 `json:"last_run,omitempty"`
				} `json:"daily,omitempty"`
				Hourly *struct {
					// Count Number of hourly rollups since last_run
					Count    *int32 `json:"count,omitempty"`
					Duration *struct {
						// Last Total time spent doing last daily rollup (seconds)
						Last *int64 `json:"last,omitempty"`

						// Max Longest hourly rollup time (seconds)
						Max *int64 `json:"max,omitempty"`

						// Time Total time spent doing hourly rollups (seconds)
						Time *int64 `json:"time,omitempty"`
					} `json:"duration,omitempty"`

					// LastRun Last time hourly rollup ran (UNIX timestamp)
					LastRun *int64 `json:"last_run,omitempty"`
				} `json:"hourly,omitempty"`
				Monthly *struct {
					// Count Number of monthly rollups since last_run
					Count    *int32 `json:"count,omitempty"`
					Duration *struct {
						// Last Total time spent doing monthly daily rollup (seconds)
						Last *int64 `json:"last,omitempty"`

						// Max Longest monthly rollup time (seconds)
						Max *int64 `json:"max,omitempty"`

						// Time Total time spent doing monthly rollups (seconds)
						Time *int64 `json:"time,omitempty"`
					} `json:"duration,omitempty"`

					// LastRun Last time monthly rollup ran (UNIX timestamp)
					LastRun *int64 `json:"last_run,omitempty"`
				} `json:"monthly,omitempty"`
			} `json:"rollups,omitempty"`

			// TimeStart When data collection started (UNIX timestamp)
			TimeStart *int64 `json:"time_start,omitempty"`

			// Users List of users that issued RPCs
			Users *[]struct {
				// Count Number of RPCs processed
				Count *int32 `json:"count,omitempty"`
				Time  *struct {
					// Average Average RPC processing time in microseconds
					Average *int64 `json:"average,omitempty"`

					// Total Total RPC processing time in microseconds
					Total *int64 `json:"total,omitempty"`
				} `json:"time,omitempty"`

				// User User ID
				User *string `json:"user,omitempty"`
			} `json:"users,omitempty"`
		} `json:"statistics"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiInstancesResp
	JSONDefault  *V0041OpenapiInstancesResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiInstancesResp
	JSONDefault  *V0041OpenapiInstancesResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdJobsResp
	JSONDefault  *V0041OpenapiSlurmdbdJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdJobsResp
	JSONDefault  *V0041OpenapiSlurmdbdJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdQosResp
	JSONDefault  *V0041OpenapiSlurmdbdQosResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteSingleQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// RemovedQos removed QOS
		RemovedQos []string `json:"removed_qos"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// RemovedQos removed QOS
		RemovedQos []string `json:"removed_qos"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteSingleQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteSingleQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetSingleQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdQosResp
	JSONDefault  *V0041OpenapiSlurmdbdQosResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetSingleQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetSingleQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetTresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiTresResp
	JSONDefault  *V0041OpenapiTresResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetTresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetTresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostTresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostTresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostTresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiUsersResp
	JSONDefault  *V0041OpenapiUsersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiUsersResp
	JSONDefault  *V0041OpenapiUsersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostUsersAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AddedUsers added_users
		AddedUsers string `json:"added_users"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// AddedUsers added_users
		AddedUsers string `json:"added_users"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostUsersAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostUsersAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteWckeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DeletedWckeys deleted wckeys
		DeletedWckeys []string `json:"deleted_wckeys"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
	JSONDefault *struct {
		// DeletedWckeys deleted wckeys
		DeletedWckeys []string `json:"deleted_wckeys"`

		// Errors Query errors
		Errors *[]struct {
			// Description Long form error description
			Description *string `json:"description,omitempty"`

			// Error Short form error description
			Error *string `json:"error,omitempty"`

			// ErrorNumber Slurm numeric error identifier
			ErrorNumber *int32 `json:"error_number,omitempty"`

			// Source Source of error or where error was first detected
			Source *string `json:"source,omitempty"`
		} `json:"errors,omitempty"`

		// Meta Slurm meta values
		Meta *struct {
			Client *struct {
				// Group Client group (if known)
				Group *string `json:"group,omitempty"`

				// Source Client source description
				Source *string `json:"source,omitempty"`

				// User Client user (if known)
				User *string `json:"user,omitempty"`
			} `json:"client,omitempty"`

			// Command CLI command (if applicable)
			Command *[]string `json:"command,omitempty"`
			Plugin  *struct {
				// AccountingStorage Slurm accounting plugin
				AccountingStorage *string `json:"accounting_storage,omitempty"`

				// DataParser Slurm data_parser plugin
				DataParser *string `json:"data_parser,omitempty"`

				// Name Slurm plugin name (if applicable)
				Name *string `json:"name,omitempty"`

				// Type Slurm plugin type (if applicable)
				Type *string `json:"type,omitempty"`
			} `json:"plugin,omitempty"`
			Slurm *struct {
				// Cluster Slurm cluster name
				Cluster *string `json:"cluster,omitempty"`

				// Release Slurm release string
				Release *string `json:"release,omitempty"`
				Version *struct {
					// Major Slurm release major version
					Major *string `json:"major,omitempty"`

					// Micro Slurm release micro version
					Micro *string `json:"micro,omitempty"`

					// Minor Slurm release minor version
					Minor *string `json:"minor,omitempty"`
				} `json:"version,omitempty"`
			} `json:"slurm,omitempty"`
		} `json:"meta,omitempty"`

		// Warnings Query warnings
		Warnings *[]struct {
			// Description Long form warning description
			Description *string `json:"description,omitempty"`

			// Source Source of warning or where warning was first detected
			Source *string `json:"source,omitempty"`
		} `json:"warnings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteWckeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteWckeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetWckeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiWckeyResp
	JSONDefault  *V0041OpenapiWckeyResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetWckeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetWckeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetWckeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiWckeyResp
	JSONDefault  *V0041OpenapiWckeyResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetWckeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetWckeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostWckeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostWckeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostWckeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SlurmV0041GetDiagWithResponse request returning *SlurmV0041GetDiagResponse
func (c *ClientWithResponses) SlurmV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetDiagResponse, error) {
	rsp, err := c.SlurmV0041GetDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetDiagResponse(rsp)
}

// SlurmV0041PostJobAllocateWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostJobAllocateResponse
func (c *ClientWithResponses) SlurmV0041PostJobAllocateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error) {
	rsp, err := c.SlurmV0041PostJobAllocateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobAllocateResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostJobAllocateWithResponse(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error) {
	rsp, err := c.SlurmV0041PostJobAllocate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobAllocateResponse(rsp)
}

// SlurmV0041PostJobSubmitWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostJobSubmitResponse
func (c *ClientWithResponses) SlurmV0041PostJobSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error) {
	rsp, err := c.SlurmV0041PostJobSubmitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobSubmitResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostJobSubmitWithResponse(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error) {
	rsp, err := c.SlurmV0041PostJobSubmit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobSubmitResponse(rsp)
}

// SlurmV0041DeleteJobWithResponse request returning *SlurmV0041DeleteJobResponse
func (c *ClientWithResponses) SlurmV0041DeleteJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobResponse, error) {
	rsp, err := c.SlurmV0041DeleteJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteJobResponse(rsp)
}

// SlurmV0041GetJobWithResponse request returning *SlurmV0041GetJobResponse
func (c *ClientWithResponses) SlurmV0041GetJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobResponse, error) {
	rsp, err := c.SlurmV0041GetJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetJobResponse(rsp)
}

// SlurmV0041PostJobWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostJobResponse
func (c *ClientWithResponses) SlurmV0041PostJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error) {
	rsp, err := c.SlurmV0041PostJobWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostJobWithResponse(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error) {
	rsp, err := c.SlurmV0041PostJob(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobResponse(rsp)
}

// SlurmV0041DeleteJobsWithBodyWithResponse request with arbitrary body returning *SlurmV0041DeleteJobsResponse
func (c *ClientWithResponses) SlurmV0041DeleteJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error) {
	rsp, err := c.SlurmV0041DeleteJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteJobsResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041DeleteJobsWithResponse(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error) {
	rsp, err := c.SlurmV0041DeleteJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteJobsResponse(rsp)
}

// SlurmV0041GetJobsWithResponse request returning *SlurmV0041GetJobsResponse
func (c *ClientWithResponses) SlurmV0041GetJobsWithResponse(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsResponse, error) {
	rsp, err := c.SlurmV0041GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetJobsResponse(rsp)
}

// SlurmV0041GetJobsStateWithResponse request returning *SlurmV0041GetJobsStateResponse
func (c *ClientWithResponses) SlurmV0041GetJobsStateWithResponse(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsStateResponse, error) {
	rsp, err := c.SlurmV0041GetJobsState(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetJobsStateResponse(rsp)
}

// SlurmV0041GetLicensesWithResponse request returning *SlurmV0041GetLicensesResponse
func (c *ClientWithResponses) SlurmV0041GetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetLicensesResponse, error) {
	rsp, err := c.SlurmV0041GetLicenses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetLicensesResponse(rsp)
}

// SlurmV0041DeleteNodeWithResponse request returning *SlurmV0041DeleteNodeResponse
func (c *ClientWithResponses) SlurmV0041DeleteNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteNodeResponse, error) {
	rsp, err := c.SlurmV0041DeleteNode(ctx, nodeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteNodeResponse(rsp)
}

// SlurmV0041GetNodeWithResponse request returning *SlurmV0041GetNodeResponse
func (c *ClientWithResponses) SlurmV0041GetNodeWithResponse(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodeResponse, error) {
	rsp, err := c.SlurmV0041GetNode(ctx, nodeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetNodeResponse(rsp)
}

// SlurmV0041PostNodeWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostNodeResponse
func (c *ClientWithResponses) SlurmV0041PostNodeWithBodyWithResponse(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error) {
	rsp, err := c.SlurmV0041PostNodeWithBody(ctx, nodeName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodeResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostNodeWithResponse(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error) {
	rsp, err := c.SlurmV0041PostNode(ctx, nodeName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodeResponse(rsp)
}

// SlurmV0041GetNodesWithResponse request returning *SlurmV0041GetNodesResponse
func (c *ClientWithResponses) SlurmV0041GetNodesWithResponse(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodesResponse, error) {
	rsp, err := c.SlurmV0041GetNodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetNodesResponse(rsp)
}

// SlurmV0041PostNodesWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostNodesResponse
func (c *ClientWithResponses) SlurmV0041PostNodesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodesResponse, error) {
	rsp, err := c.SlurmV0041PostNodesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodesResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostNodesWithResponse(ctx context.Context, body SlurmV0041PostNodesJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodesResponse, error) {
	rsp, err := c.SlurmV0041PostNodes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodesResponse(rsp)
}

// SlurmV0041GetPartitionWithResponse request returning *SlurmV0041GetPartitionResponse
func (c *ClientWithResponses) SlurmV0041GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionResponse, error) {
	rsp, err := c.SlurmV0041GetPartition(ctx, partitionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetPartitionResponse(rsp)
}

// SlurmV0041GetPartitionsWithResponse request returning *SlurmV0041GetPartitionsResponse
func (c *ClientWithResponses) SlurmV0041GetPartitionsWithResponse(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionsResponse, error) {
	rsp, err := c.SlurmV0041GetPartitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetPartitionsResponse(rsp)
}

// SlurmV0041GetPingWithResponse request returning *SlurmV0041GetPingResponse
func (c *ClientWithResponses) SlurmV0041GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetPingResponse, error) {
	rsp, err := c.SlurmV0041GetPing(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetPingResponse(rsp)
}

// SlurmV0041GetReconfigureWithResponse request returning *SlurmV0041GetReconfigureResponse
func (c *ClientWithResponses) SlurmV0041GetReconfigureWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetReconfigureResponse, error) {
	rsp, err := c.SlurmV0041GetReconfigure(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetReconfigureResponse(rsp)
}

// SlurmV0041GetReservationWithResponse request returning *SlurmV0041GetReservationResponse
func (c *ClientWithResponses) SlurmV0041GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationResponse, error) {
	rsp, err := c.SlurmV0041GetReservation(ctx, reservationName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetReservationResponse(rsp)
}

// SlurmV0041GetReservationsWithResponse request returning *SlurmV0041GetReservationsResponse
func (c *ClientWithResponses) SlurmV0041GetReservationsWithResponse(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationsResponse, error) {
	rsp, err := c.SlurmV0041GetReservations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetReservationsResponse(rsp)
}

// SlurmV0041GetSharesWithResponse request returning *SlurmV0041GetSharesResponse
func (c *ClientWithResponses) SlurmV0041GetSharesWithResponse(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetSharesResponse, error) {
	rsp, err := c.SlurmV0041GetShares(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetSharesResponse(rsp)
}

// SlurmdbV0041DeleteAccountWithResponse request returning *SlurmdbV0041DeleteAccountResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAccountResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteAccount(ctx, accountName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteAccountResponse(rsp)
}

// SlurmdbV0041GetAccountWithResponse request returning *SlurmdbV0041GetAccountResponse
func (c *ClientWithResponses) SlurmdbV0041GetAccountWithResponse(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountResponse, error) {
	rsp, err := c.SlurmdbV0041GetAccount(ctx, accountName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAccountResponse(rsp)
}

// SlurmdbV0041GetAccountsWithResponse request returning *SlurmdbV0041GetAccountsResponse
func (c *ClientWithResponses) SlurmdbV0041GetAccountsWithResponse(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountsResponse, error) {
	rsp, err := c.SlurmdbV0041GetAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAccountsResponse(rsp)
}

// SlurmdbV0041PostAccountsWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostAccountsResponse
func (c *ClientWithResponses) SlurmdbV0041PostAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccountsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostAccountsWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccounts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsResponse(rsp)
}

// SlurmdbV0041PostAccountsAssociationWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostAccountsAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041PostAccountsAssociationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccountsAssociationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsAssociationResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostAccountsAssociationWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccountsAssociation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsAssociationResponse(rsp)
}

// SlurmdbV0041DeleteAssociationWithResponse request returning *SlurmdbV0041DeleteAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteAssociationWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteAssociation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteAssociationResponse(rsp)
}

// SlurmdbV0041GetAssociationWithResponse request returning *SlurmdbV0041GetAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041GetAssociationWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041GetAssociation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAssociationResponse(rsp)
}

// SlurmdbV0041DeleteAssociationsWithResponse request returning *SlurmdbV0041DeleteAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteAssociationsResponse(rsp)
}

// SlurmdbV0041GetAssociationsWithResponse request returning *SlurmdbV0041GetAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0041GetAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041GetAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAssociationsResponse(rsp)
}

// SlurmdbV0041PostAssociationsWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0041PostAssociationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAssociationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAssociationsResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostAssociationsWithResponse(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAssociations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAssociationsResponse(rsp)
}

// SlurmdbV0041DeleteClusterWithResponse request returning *SlurmdbV0041DeleteClusterResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteClusterResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteCluster(ctx, clusterName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteClusterResponse(rsp)
}

// SlurmdbV0041GetClusterWithResponse request returning *SlurmdbV0041GetClusterResponse
func (c *ClientWithResponses) SlurmdbV0041GetClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClusterResponse, error) {
	rsp, err := c.SlurmdbV0041GetCluster(ctx, clusterName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetClusterResponse(rsp)
}

// SlurmdbV0041GetClustersWithResponse request returning *SlurmdbV0041GetClustersResponse
func (c *ClientWithResponses) SlurmdbV0041GetClustersWithResponse(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClustersResponse, error) {
	rsp, err := c.SlurmdbV0041GetClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetClustersResponse(rsp)
}

// SlurmdbV0041PostClustersWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostClustersResponse
func (c *ClientWithResponses) SlurmdbV0041PostClustersWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error) {
	rsp, err := c.SlurmdbV0041PostClustersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostClustersResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostClustersWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error) {
	rsp, err := c.SlurmdbV0041PostClusters(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostClustersResponse(rsp)
}

// SlurmdbV0041GetConfigWithResponse request returning *SlurmdbV0041GetConfigResponse
func (c *ClientWithResponses) SlurmdbV0041GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetConfigResponse, error) {
	rsp, err := c.SlurmdbV0041GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetConfigResponse(rsp)
}

// SlurmdbV0041PostConfigWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostConfigResponse
func (c *ClientWithResponses) SlurmdbV0041PostConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error) {
	rsp, err := c.SlurmdbV0041PostConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostConfigResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostConfigWithResponse(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error) {
	rsp, err := c.SlurmdbV0041PostConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostConfigResponse(rsp)
}

// SlurmdbV0041GetDiagWithResponse request returning *SlurmdbV0041GetDiagResponse
func (c *ClientWithResponses) SlurmdbV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetDiagResponse, error) {
	rsp, err := c.SlurmdbV0041GetDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetDiagResponse(rsp)
}

// SlurmdbV0041GetInstanceWithResponse request returning *SlurmdbV0041GetInstanceResponse
func (c *ClientWithResponses) SlurmdbV0041GetInstanceWithResponse(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstanceResponse, error) {
	rsp, err := c.SlurmdbV0041GetInstance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetInstanceResponse(rsp)
}

// SlurmdbV0041GetInstancesWithResponse request returning *SlurmdbV0041GetInstancesResponse
func (c *ClientWithResponses) SlurmdbV0041GetInstancesWithResponse(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstancesResponse, error) {
	rsp, err := c.SlurmdbV0041GetInstances(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetInstancesResponse(rsp)
}

// SlurmdbV0041GetJobWithResponse request returning *SlurmdbV0041GetJobResponse
func (c *ClientWithResponses) SlurmdbV0041GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobResponse, error) {
	rsp, err := c.SlurmdbV0041GetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetJobResponse(rsp)
}

// SlurmdbV0041GetJobsWithResponse request returning *SlurmdbV0041GetJobsResponse
func (c *ClientWithResponses) SlurmdbV0041GetJobsWithResponse(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobsResponse, error) {
	rsp, err := c.SlurmdbV0041GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetJobsResponse(rsp)
}

// SlurmdbV0041GetQosWithResponse request returning *SlurmdbV0041GetQosResponse
func (c *ClientWithResponses) SlurmdbV0041GetQosWithResponse(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetQosResponse, error) {
	rsp, err := c.SlurmdbV0041GetQos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetQosResponse(rsp)
}

// SlurmdbV0041PostQosWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostQosResponse
func (c *ClientWithResponses) SlurmdbV0041PostQosWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error) {
	rsp, err := c.SlurmdbV0041PostQosWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostQosResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostQosWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error) {
	rsp, err := c.SlurmdbV0041PostQos(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostQosResponse(rsp)
}

// SlurmdbV0041DeleteSingleQosWithResponse request returning *SlurmdbV0041DeleteSingleQosResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteSingleQosWithResponse(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteSingleQosResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteSingleQos(ctx, qos, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteSingleQosResponse(rsp)
}

// SlurmdbV0041GetSingleQosWithResponse request returning *SlurmdbV0041GetSingleQosResponse
func (c *ClientWithResponses) SlurmdbV0041GetSingleQosWithResponse(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetSingleQosResponse, error) {
	rsp, err := c.SlurmdbV0041GetSingleQos(ctx, qos, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetSingleQosResponse(rsp)
}

// SlurmdbV0041GetTresWithResponse request returning *SlurmdbV0041GetTresResponse
func (c *ClientWithResponses) SlurmdbV0041GetTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetTresResponse, error) {
	rsp, err := c.SlurmdbV0041GetTres(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetTresResponse(rsp)
}

// SlurmdbV0041PostTresWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostTresResponse
func (c *ClientWithResponses) SlurmdbV0041PostTresWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error) {
	rsp, err := c.SlurmdbV0041PostTresWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostTresResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostTresWithResponse(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error) {
	rsp, err := c.SlurmdbV0041PostTres(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostTresResponse(rsp)
}

// SlurmdbV0041DeleteUserWithResponse request returning *SlurmdbV0041DeleteUserResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteUserWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteUserResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteUser(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteUserResponse(rsp)
}

// SlurmdbV0041GetUserWithResponse request returning *SlurmdbV0041GetUserResponse
func (c *ClientWithResponses) SlurmdbV0041GetUserWithResponse(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUserResponse, error) {
	rsp, err := c.SlurmdbV0041GetUser(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetUserResponse(rsp)
}

// SlurmdbV0041GetUsersWithResponse request returning *SlurmdbV0041GetUsersResponse
func (c *ClientWithResponses) SlurmdbV0041GetUsersWithResponse(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUsersResponse, error) {
	rsp, err := c.SlurmdbV0041GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetUsersResponse(rsp)
}

// SlurmdbV0041PostUsersWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostUsersResponse
func (c *ClientWithResponses) SlurmdbV0041PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostUsersWithResponse(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersResponse(rsp)
}

// SlurmdbV0041PostUsersAssociationWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostUsersAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041PostUsersAssociationWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsersAssociationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersAssociationResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostUsersAssociationWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsersAssociation(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersAssociationResponse(rsp)
}

// SlurmdbV0041DeleteWckeyWithResponse request returning *SlurmdbV0041DeleteWckeyResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteWckeyResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteWckey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteWckeyResponse(rsp)
}

// SlurmdbV0041GetWckeyWithResponse request returning *SlurmdbV0041GetWckeyResponse
func (c *ClientWithResponses) SlurmdbV0041GetWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeyResponse, error) {
	rsp, err := c.SlurmdbV0041GetWckey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetWckeyResponse(rsp)
}

// SlurmdbV0041GetWckeysWithResponse request returning *SlurmdbV0041GetWckeysResponse
func (c *ClientWithResponses) SlurmdbV0041GetWckeysWithResponse(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeysResponse, error) {
	rsp, err := c.SlurmdbV0041GetWckeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetWckeysResponse(rsp)
}

// SlurmdbV0041PostWckeysWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostWckeysResponse
func (c *ClientWithResponses) SlurmdbV0041PostWckeysWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error) {
	rsp, err := c.SlurmdbV0041PostWckeysWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostWckeysResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostWckeysWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error) {
	rsp, err := c.SlurmdbV0041PostWckeys(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostWckeysResponse(rsp)
}

// ParseSlurmV0041GetDiagResponse parses an HTTP response from a SlurmV0041GetDiagWithResponse call
func ParseSlurmV0041GetDiagResponse(rsp *http.Response) (*SlurmV0041GetDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Statistics statistics
			Statistics struct {
				// AgentCount Number of agent threads
				AgentCount *int32 `json:"agent_count,omitempty"`

				// AgentQueueSize Number of enqueued outgoing RPC requests in an internal retry list
				AgentQueueSize *int32 `json:"agent_queue_size,omitempty"`

				// AgentThreadCount Total number of active threads created by all agent threads
				AgentThreadCount *int32 `json:"agent_thread_count,omitempty"`

				// BfActive Backfill scheduler currently running
				BfActive *bool `json:"bf_active,omitempty"`

				// BfBackfilledHetJobs Number of heterogeneous job components started through backfilling since last Slurm start
				BfBackfilledHetJobs *int32 `json:"bf_backfilled_het_jobs,omitempty"`

				// BfBackfilledJobs Number of jobs started through backfilling since last slurm start
				BfBackfilledJobs *int32 `json:"bf_backfilled_jobs,omitempty"`

				// BfCycleCounter Number of backfill scheduling cycles since last reset
				BfCycleCounter *int32 `json:"bf_cycle_counter,omitempty"`

				// BfCycleLast Execution time in microseconds of last backfill scheduling cycle
				BfCycleLast *int32 `json:"bf_cycle_last,omitempty"`

				// BfCycleMax Execution time in microseconds of longest backfill scheduling cycle
				BfCycleMax *int32 `json:"bf_cycle_max,omitempty"`

				// BfCycleMean Mean time in microseconds of backfilling scheduling cycles since last reset
				BfCycleMean *int64 `json:"bf_cycle_mean,omitempty"`

				// BfCycleSum Total time in microseconds of backfilling scheduling cycles since last reset
				BfCycleSum *int64 `json:"bf_cycle_sum,omitempty"`

				// BfDepthMean Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
				BfDepthMean *int64 `json:"bf_depth_mean,omitempty"`

				// BfDepthMeanTry The subset of Depth Mean that the backfill scheduler attempted to schedule
				BfDepthMeanTry *int64 `json:"bf_depth_mean_try,omitempty"`

				// BfDepthSum Total number of jobs processed during all backfilling scheduling cycles since last reset
				BfDepthSum *int32 `json:"bf_depth_sum,omitempty"`

				// BfDepthTrySum Subset of bf_depth_sum that the backfill scheduler attempted to schedule
				BfDepthTrySum *int32 `json:"bf_depth_try_sum,omitempty"`

				// BfExit Reasons for which the backfill scheduling cycle exited since last reset
				BfExit *struct {
					// BfMaxJobStart Reached number of jobs allowed to start
					BfMaxJobStart *int32 `json:"bf_max_job_start,omitempty"`

					// BfMaxJobTest Reached number of jobs allowed to be tested
					BfMaxJobTest *int32 `json:"bf_max_job_test,omitempty"`

					// BfMaxTime Reached maximum allowed scheduler time
					BfMaxTime *int32 `json:"bf_max_time,omitempty"`

					// BfNodeSpaceSize Reached table size limit
					BfNodeSpaceSize *int32 `json:"bf_node_space_size,omitempty"`

					// EndJobQueue Reached end of queue
					EndJobQueue *int32 `json:"end_job_queue,omitempty"`

					// StateChanged System state changed
					StateChanged *int32 `json:"state_changed,omitempty"`
				} `json:"bf_exit,omitempty"`

				// BfLastBackfilledJobs Number of jobs started through backfilling since last reset
				BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`

				// BfLastDepth Number of processed jobs during last backfilling scheduling cycle
				BfLastDepth *int32 `json:"bf_last_depth,omitempty"`

				// BfLastDepthTry Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
				BfLastDepthTry *int32 `json:"bf_last_depth_try,omitempty"`

				// BfQueueLen Number of jobs pending to be processed by backfilling algorithm
				BfQueueLen *int32 `json:"bf_queue_len,omitempty"`

				// BfQueueLenMean Mean number of jobs pending to be processed by backfilling algorithm
				BfQueueLenMean *int64 `json:"bf_queue_len_mean,omitempty"`

				// BfQueueLenSum Total number of jobs pending to be processed by backfilling algorithm since last reset
				BfQueueLenSum *int32 `json:"bf_queue_len_sum,omitempty"`

				// BfTableSize Number of different time slots tested by the backfill scheduler in its last iteration
				BfTableSize *int32 `json:"bf_table_size,omitempty"`

				// BfTableSizeMean Mean number of different time slots tested by the backfill scheduler
				BfTableSizeMean *int64 `json:"bf_table_size_mean,omitempty"`

				// BfTableSizeSum Total number of different time slots tested by the backfill scheduler
				BfTableSizeSum *int32 `json:"bf_table_size_sum,omitempty"`

				// BfWhenLastCycle When the last backfill scheduling cycle happened (UNIX timestamp)
				BfWhenLastCycle *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"bf_when_last_cycle,omitempty"`

				// DbdAgentQueueSize Number of messages for SlurmDBD that are queued
				DbdAgentQueueSize *int32 `json:"dbd_agent_queue_size,omitempty"`

				// GettimeofdayLatency Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
				GettimeofdayLatency *int32 `json:"gettimeofday_latency,omitempty"`

				// JobStatesTs When the job state counts were gathered (UNIX timestamp)
				JobStatesTs *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"job_states_ts,omitempty"`

				// JobsCanceled Number of jobs canceled since the last reset
				JobsCanceled *int32 `json:"jobs_canceled,omitempty"`

				// JobsCompleted Number of jobs completed since last reset
				JobsCompleted *int32 `json:"jobs_completed,omitempty"`

				// JobsFailed Number of jobs failed due to slurmd or other internal issues since last reset
				JobsFailed *int32 `json:"jobs_failed,omitempty"`

				// JobsPending Number of jobs pending at the time of listed in job_state_ts
				JobsPending *int32 `json:"jobs_pending,omitempty"`

				// JobsRunning Number of jobs running at the time of listed in job_state_ts
				JobsRunning *int32 `json:"jobs_running,omitempty"`

				// JobsStarted Number of jobs started since last reset
				JobsStarted *int32 `json:"jobs_started,omitempty"`

				// JobsSubmitted Number of jobs submitted since last reset
				JobsSubmitted *int32 `json:"jobs_submitted,omitempty"`

				// PartsPacked Zero if only RPC statistic included
				PartsPacked *int32 `json:"parts_packed,omitempty"`

				// PendingRpcs Pending RPC statistics
				PendingRpcs *[]struct {
					// Count Number of pending RPCs queued
					Count int32 `json:"count"`

					// MessageType Message type as string
					MessageType string `json:"message_type"`

					// TypeId Message type as integer
					TypeId int32 `json:"type_id"`
				} `json:"pending_rpcs,omitempty"`

				// PendingRpcsByHostlist Pending RPCs hostlists
				PendingRpcsByHostlist *[]struct {
					// Count Number of RPCs received
					Count []string `json:"count"`

					// MessageType Message type as string
					MessageType string `json:"message_type"`

					// TypeId Message type as integer
					TypeId int32 `json:"type_id"`
				} `json:"pending_rpcs_by_hostlist,omitempty"`

				// ReqTime When the request was made (UNIX timestamp)
				ReqTime *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"req_time,omitempty"`

				// ReqTimeStart When the data in the report started (UNIX timestamp)
				ReqTimeStart *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"req_time_start,omitempty"`

				// RpcsByMessageType Most frequently issued remote procedure calls (RPCs)
				RpcsByMessageType *[]struct {
					// AverageTime Average time spent processing RPC in seconds
					AverageTime struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"average_time"`

					// Count Number of RPCs received
					Count int32 `json:"count"`

					// CycleLast Number of RPCs processed within the last RPC queue cycle
					CycleLast int32 `json:"cycle_last"`

					// CycleMax Maximum number of RPCs processed within a RPC queue cycle since start
					CycleMax int32 `json:"cycle_max"`

					// Dropped Number of RPCs dropped
					Dropped int64 `json:"dropped"`

					// MessageType Message type as string
					MessageType string `json:"message_type"`

					// Queued Number of RPCs queued
					Queued int32 `json:"queued"`

					// TotalTime Total time spent processing RPC in seconds
					TotalTime int64 `json:"total_time"`

					// TypeId Message type as integer
					TypeId int32 `json:"type_id"`
				} `json:"rpcs_by_message_type,omitempty"`

				// RpcsByUser RPCs issued by user ID
				RpcsByUser *[]struct {
					// AverageTime Average time spent processing RPC in seconds
					AverageTime struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"average_time"`

					// Count Number of RPCs received
					Count int32 `json:"count"`

					// TotalTime Total time spent processing RPC in seconds
					TotalTime int64 `json:"total_time"`

					// User User name
					User string `json:"user"`

					// UserId User ID (numeric)
					UserId int32 `json:"user_id"`
				} `json:"rpcs_by_user,omitempty"`

				// ScheduleCycleDepth Total number of jobs processed in scheduling cycles
				ScheduleCycleDepth *int32 `json:"schedule_cycle_depth,omitempty"`

				// ScheduleCycleLast Time in microseconds for last scheduling cycle
				ScheduleCycleLast *int32 `json:"schedule_cycle_last,omitempty"`

				// ScheduleCycleMax Max time of any scheduling cycle in microseconds since last reset
				ScheduleCycleMax *int32 `json:"schedule_cycle_max,omitempty"`

				// ScheduleCycleMean Mean time in microseconds for all scheduling cycles since last reset
				ScheduleCycleMean *int64 `json:"schedule_cycle_mean,omitempty"`

				// ScheduleCycleMeanDepth Mean of the number of jobs processed in a scheduling cycle
				ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`

				// ScheduleCyclePerMinute Number of scheduling executions per minute
				ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`

				// ScheduleCycleSum Total run time in microseconds for all scheduling cycles since last reset
				ScheduleCycleSum *int32 `json:"schedule_cycle_sum,omitempty"`

				// ScheduleCycleTotal Number of scheduling cycles since last reset
				ScheduleCycleTotal *int32 `json:"schedule_cycle_total,omitempty"`

				// ScheduleExit Reasons for which the scheduling cycle exited since last reset
				ScheduleExit *struct {
					// DefaultQueueDepth Reached number of jobs allowed to be tested
					DefaultQueueDepth *int32 `json:"default_queue_depth,omitempty"`

					// EndJobQueue Reached end of queue
					EndJobQueue *int32 `json:"end_job_queue,omitempty"`

					// Licenses Blocked on licenses
					Licenses *int32 `json:"licenses,omitempty"`

					// MaxJobStart Reached number of jobs allowed to start
					MaxJobStart *int32 `json:"max_job_start,omitempty"`

					// MaxRpcCnt Reached RPC limit
					MaxRpcCnt *int32 `json:"max_rpc_cnt,omitempty"`

					// MaxSchedTime Reached maximum allowed scheduler time
					MaxSchedTime *int32 `json:"max_sched_time,omitempty"`
				} `json:"schedule_exit,omitempty"`

				// ScheduleQueueLength Number of jobs pending in queue
				ScheduleQueueLength *int32 `json:"schedule_queue_length,omitempty"`

				// ServerThreadCount Number of current active slurmctld threads
				ServerThreadCount *int32 `json:"server_thread_count,omitempty"`
			} `json:"statistics"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Statistics statistics
			Statistics struct {
				// AgentCount Number of agent threads
				AgentCount *int32 `json:"agent_count,omitempty"`

				// AgentQueueSize Number of enqueued outgoing RPC requests in an internal retry list
				AgentQueueSize *int32 `json:"agent_queue_size,omitempty"`

				// AgentThreadCount Total number of active threads created by all agent threads
				AgentThreadCount *int32 `json:"agent_thread_count,omitempty"`

				// BfActive Backfill scheduler currently running
				BfActive *bool `json:"bf_active,omitempty"`

				// BfBackfilledHetJobs Number of heterogeneous job components started through backfilling since last Slurm start
				BfBackfilledHetJobs *int32 `json:"bf_backfilled_het_jobs,omitempty"`

				// BfBackfilledJobs Number of jobs started through backfilling since last slurm start
				BfBackfilledJobs *int32 `json:"bf_backfilled_jobs,omitempty"`

				// BfCycleCounter Number of backfill scheduling cycles since last reset
				BfCycleCounter *int32 `json:"bf_cycle_counter,omitempty"`

				// BfCycleLast Execution time in microseconds of last backfill scheduling cycle
				BfCycleLast *int32 `json:"bf_cycle_last,omitempty"`

				// BfCycleMax Execution time in microseconds of longest backfill scheduling cycle
				BfCycleMax *int32 `json:"bf_cycle_max,omitempty"`

				// BfCycleMean Mean time in microseconds of backfilling scheduling cycles since last reset
				BfCycleMean *int64 `json:"bf_cycle_mean,omitempty"`

				// BfCycleSum Total time in microseconds of backfilling scheduling cycles since last reset
				BfCycleSum *int64 `json:"bf_cycle_sum,omitempty"`

				// BfDepthMean Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
				BfDepthMean *int64 `json:"bf_depth_mean,omitempty"`

				// BfDepthMeanTry The subset of Depth Mean that the backfill scheduler attempted to schedule
				BfDepthMeanTry *int64 `json:"bf_depth_mean_try,omitempty"`

				// BfDepthSum Total number of jobs processed during all backfilling scheduling cycles since last reset
				BfDepthSum *int32 `json:"bf_depth_sum,omitempty"`

				// BfDepthTrySum Subset of bf_depth_sum that the backfill scheduler attempted to schedule
				BfDepthTrySum *int32 `json:"bf_depth_try_sum,omitempty"`

				// BfExit Reasons for which the backfill scheduling cycle exited since last reset
				BfExit *struct {
					// BfMaxJobStart Reached number of jobs allowed to start
					BfMaxJobStart *int32 `json:"bf_max_job_start,omitempty"`

					// BfMaxJobTest Reached number of jobs allowed to be tested
					BfMaxJobTest *int32 `json:"bf_max_job_test,omitempty"`

					// BfMaxTime Reached maximum allowed scheduler time
					BfMaxTime *int32 `json:"bf_max_time,omitempty"`

					// BfNodeSpaceSize Reached table size limit
					BfNodeSpaceSize *int32 `json:"bf_node_space_size,omitempty"`

					// EndJobQueue Reached end of queue
					EndJobQueue *int32 `json:"end_job_queue,omitempty"`

					// StateChanged System state changed
					StateChanged *int32 `json:"state_changed,omitempty"`
				} `json:"bf_exit,omitempty"`

				// BfLastBackfilledJobs Number of jobs started through backfilling since last reset
				BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`

				// BfLastDepth Number of processed jobs during last backfilling scheduling cycle
				BfLastDepth *int32 `json:"bf_last_depth,omitempty"`

				// BfLastDepthTry Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
				BfLastDepthTry *int32 `json:"bf_last_depth_try,omitempty"`

				// BfQueueLen Number of jobs pending to be processed by backfilling algorithm
				BfQueueLen *int32 `json:"bf_queue_len,omitempty"`

				// BfQueueLenMean Mean number of jobs pending to be processed by backfilling algorithm
				BfQueueLenMean *int64 `json:"bf_queue_len_mean,omitempty"`

				// BfQueueLenSum Total number of jobs pending to be processed by backfilling algorithm since last reset
				BfQueueLenSum *int32 `json:"bf_queue_len_sum,omitempty"`

				// BfTableSize Number of different time slots tested by the backfill scheduler in its last iteration
				BfTableSize *int32 `json:"bf_table_size,omitempty"`

				// BfTableSizeMean Mean number of different time slots tested by the backfill scheduler
				BfTableSizeMean *int64 `json:"bf_table_size_mean,omitempty"`

				// BfTableSizeSum Total number of different time slots tested by the backfill scheduler
				BfTableSizeSum *int32 `json:"bf_table_size_sum,omitempty"`

				// BfWhenLastCycle When the last backfill scheduling cycle happened (UNIX timestamp)
				BfWhenLastCycle *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"bf_when_last_cycle,omitempty"`

				// DbdAgentQueueSize Number of messages for SlurmDBD that are queued
				DbdAgentQueueSize *int32 `json:"dbd_agent_queue_size,omitempty"`

				// GettimeofdayLatency Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
				GettimeofdayLatency *int32 `json:"gettimeofday_latency,omitempty"`

				// JobStatesTs When the job state counts were gathered (UNIX timestamp)
				JobStatesTs *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"job_states_ts,omitempty"`

				// JobsCanceled Number of jobs canceled since the last reset
				JobsCanceled *int32 `json:"jobs_canceled,omitempty"`

				// JobsCompleted Number of jobs completed since last reset
				JobsCompleted *int32 `json:"jobs_completed,omitempty"`

				// JobsFailed Number of jobs failed due to slurmd or other internal issues since last reset
				JobsFailed *int32 `json:"jobs_failed,omitempty"`

				// JobsPending Number of jobs pending at the time of listed in job_state_ts
				JobsPending *int32 `json:"jobs_pending,omitempty"`

				// JobsRunning Number of jobs running at the time of listed in job_state_ts
				JobsRunning *int32 `json:"jobs_running,omitempty"`

				// JobsStarted Number of jobs started since last reset
				JobsStarted *int32 `json:"jobs_started,omitempty"`

				// JobsSubmitted Number of jobs submitted since last reset
				JobsSubmitted *int32 `json:"jobs_submitted,omitempty"`

				// PartsPacked Zero if only RPC statistic included
				PartsPacked *int32 `json:"parts_packed,omitempty"`

				// PendingRpcs Pending RPC statistics
				PendingRpcs *[]struct {
					// Count Number of pending RPCs queued
					Count int32 `json:"count"`

					// MessageType Message type as string
					MessageType string `json:"message_type"`

					// TypeId Message type as integer
					TypeId int32 `json:"type_id"`
				} `json:"pending_rpcs,omitempty"`

				// PendingRpcsByHostlist Pending RPCs hostlists
				PendingRpcsByHostlist *[]struct {
					// Count Number of RPCs received
					Count []string `json:"count"`

					// MessageType Message type as string
					MessageType string `json:"message_type"`

					// TypeId Message type as integer
					TypeId int32 `json:"type_id"`
				} `json:"pending_rpcs_by_hostlist,omitempty"`

				// ReqTime When the request was made (UNIX timestamp)
				ReqTime *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"req_time,omitempty"`

				// ReqTimeStart When the data in the report started (UNIX timestamp)
				ReqTimeStart *struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int64 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"req_time_start,omitempty"`

				// RpcsByMessageType Most frequently issued remote procedure calls (RPCs)
				RpcsByMessageType *[]struct {
					// AverageTime Average time spent processing RPC in seconds
					AverageTime struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"average_time"`

					// Count Number of RPCs received
					Count int32 `json:"count"`

					// CycleLast Number of RPCs processed within the last RPC queue cycle
					CycleLast int32 `json:"cycle_last"`

					// CycleMax Maximum number of RPCs processed within a RPC queue cycle since start
					CycleMax int32 `json:"cycle_max"`

					// Dropped Number of RPCs dropped
					Dropped int64 `json:"dropped"`

					// MessageType Message type as string
					MessageType string `json:"message_type"`

					// Queued Number of RPCs queued
					Queued int32 `json:"queued"`

					// TotalTime Total time spent processing RPC in seconds
					TotalTime int64 `json:"total_time"`

					// TypeId Message type as integer
					TypeId int32 `json:"type_id"`
				} `json:"rpcs_by_message_type,omitempty"`

				// RpcsByUser RPCs issued by user ID
				RpcsByUser *[]struct {
					// AverageTime Average time spent processing RPC in seconds
					AverageTime struct {
						// Infinite True if number has been set to infinite; "set" and "number" will be ignored
						Infinite *bool `json:"infinite,omitempty"`

						// Number If "set" is True the number will be set with value; otherwise ignore number contents
						Number *int64 `json:"number,omitempty"`

						// Set True if number has been set; False if number is unset
						Set *bool `json:"set,omitempty"`
					} `json:"average_time"`

					// Count Number of RPCs received
					Count int32 `json:"count"`

					// TotalTime Total time spent processing RPC in seconds
					TotalTime int64 `json:"total_time"`

					// User User name
					User string `json:"user"`

					// UserId User ID (numeric)
					UserId int32 `json:"user_id"`
				} `json:"rpcs_by_user,omitempty"`

				// ScheduleCycleDepth Total number of jobs processed in scheduling cycles
				ScheduleCycleDepth *int32 `json:"schedule_cycle_depth,omitempty"`

				// ScheduleCycleLast Time in microseconds for last scheduling cycle
				ScheduleCycleLast *int32 `json:"schedule_cycle_last,omitempty"`

				// ScheduleCycleMax Max time of any scheduling cycle in microseconds since last reset
				ScheduleCycleMax *int32 `json:"schedule_cycle_max,omitempty"`

				// ScheduleCycleMean Mean time in microseconds for all scheduling cycles since last reset
				ScheduleCycleMean *int64 `json:"schedule_cycle_mean,omitempty"`

				// ScheduleCycleMeanDepth Mean of the number of jobs processed in a scheduling cycle
				ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`

				// ScheduleCyclePerMinute Number of scheduling executions per minute
				ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`

				// ScheduleCycleSum Total run time in microseconds for all scheduling cycles since last reset
				ScheduleCycleSum *int32 `json:"schedule_cycle_sum,omitempty"`

				// ScheduleCycleTotal Number of scheduling cycles since last reset
				ScheduleCycleTotal *int32 `json:"schedule_cycle_total,omitempty"`

				// ScheduleExit Reasons for which the scheduling cycle exited since last reset
				ScheduleExit *struct {
					// DefaultQueueDepth Reached number of jobs allowed to be tested
					DefaultQueueDepth *int32 `json:"default_queue_depth,omitempty"`

					// EndJobQueue Reached end of queue
					EndJobQueue *int32 `json:"end_job_queue,omitempty"`

					// Licenses Blocked on licenses
					Licenses *int32 `json:"licenses,omitempty"`

					// MaxJobStart Reached number of jobs allowed to start
					MaxJobStart *int32 `json:"max_job_start,omitempty"`

					// MaxRpcCnt Reached RPC limit
					MaxRpcCnt *int32 `json:"max_rpc_cnt,omitempty"`

					// MaxSchedTime Reached maximum allowed scheduler time
					MaxSchedTime *int32 `json:"max_sched_time,omitempty"`
				} `json:"schedule_exit,omitempty"`

				// ScheduleQueueLength Number of jobs pending in queue
				ScheduleQueueLength *int32 `json:"schedule_queue_length,omitempty"`

				// ServerThreadCount Number of current active slurmctld threads
				ServerThreadCount *int32 `json:"server_thread_count,omitempty"`
			} `json:"statistics"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostJobAllocateResponse parses an HTTP response from a SlurmV0041PostJobAllocateWithResponse call
func ParseSlurmV0041PostJobAllocateResponse(rsp *http.Response) (*SlurmV0041PostJobAllocateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostJobAllocateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId Submitted Job ID
			JobId *int32 `json:"job_id,omitempty"`

			// JobSubmitUserMsg Job submission user message
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId Submitted Job ID
			JobId *int32 `json:"job_id,omitempty"`

			// JobSubmitUserMsg Job submission user message
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostJobSubmitResponse parses an HTTP response from a SlurmV0041PostJobSubmitWithResponse call
func ParseSlurmV0041PostJobSubmitResponse(rsp *http.Response) (*SlurmV0041PostJobSubmitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostJobSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId Submitted Job ID
			JobId *int32 `json:"job_id,omitempty"`

			// JobSubmitUserMsg Job submission user message
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Result Job submission
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			Result *struct {
				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorCode Error code
				ErrorCode *int32 `json:"error_code,omitempty"`

				// JobId New job ID
				JobId *int32 `json:"job_id,omitempty"`

				// JobSubmitUserMsg Message to user from job_submit plugin
				JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

				// StepId New job step ID
				StepId *string `json:"step_id,omitempty"`
			} `json:"result,omitempty"`

			// StepId Submitted Step ID
			StepId *string `json:"step_id,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId Submitted Job ID
			JobId *int32 `json:"job_id,omitempty"`

			// JobSubmitUserMsg Job submission user message
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Result Job submission
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			Result *struct {
				// Error Error message
				Error *string `json:"error,omitempty"`

				// ErrorCode Error code
				ErrorCode *int32 `json:"error_code,omitempty"`

				// JobId New job ID
				JobId *int32 `json:"job_id,omitempty"`

				// JobSubmitUserMsg Message to user from job_submit plugin
				JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

				// StepId New job step ID
				StepId *string `json:"step_id,omitempty"`
			} `json:"result,omitempty"`

			// StepId Submitted Step ID
			StepId *string `json:"step_id,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteJobResponse parses an HTTP response from a SlurmV0041DeleteJobWithResponse call
func ParseSlurmV0041DeleteJobResponse(rsp *http.Response) (*SlurmV0041DeleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetJobResponse parses an HTTP response from a SlurmV0041GetJobWithResponse call
func ParseSlurmV0041GetJobResponse(rsp *http.Response) (*SlurmV0041GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostJobResponse parses an HTTP response from a SlurmV0041PostJobWithResponse call
func ParseSlurmV0041PostJobResponse(rsp *http.Response) (*SlurmV0041PostJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId First updated Job ID - Use results instead
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			JobId *string `json:"job_id,omitempty"`

			// JobSubmitUserMsg First updated Job submission user message - Use results instead
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Results Job update results
			Results *[]struct {
				// Error Verbose update status or error
				Error *string `json:"error,omitempty"`

				// ErrorCode Verbose update status or error
				ErrorCode *int32 `json:"error_code,omitempty"`

				// JobId Job ID for updated job
				JobId *int32 `json:"job_id,omitempty"`

				// StepId Step ID for updated job
				StepId *string `json:"step_id,omitempty"`

				// Why Update response message
				Why *string `json:"why,omitempty"`
			} `json:"results,omitempty"`

			// StepId First updated Step ID - Use results instead
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			StepId *string `json:"step_id,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// JobId First updated Job ID - Use results instead
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			JobId *string `json:"job_id,omitempty"`

			// JobSubmitUserMsg First updated Job submission user message - Use results instead
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Results Job update results
			Results *[]struct {
				// Error Verbose update status or error
				Error *string `json:"error,omitempty"`

				// ErrorCode Verbose update status or error
				ErrorCode *int32 `json:"error_code,omitempty"`

				// JobId Job ID for updated job
				JobId *int32 `json:"job_id,omitempty"`

				// StepId Step ID for updated job
				StepId *string `json:"step_id,omitempty"`

				// Why Update response message
				Why *string `json:"why,omitempty"`
			} `json:"results,omitempty"`

			// StepId First updated Step ID - Use results instead
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			StepId *string `json:"step_id,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteJobsResponse parses an HTTP response from a SlurmV0041DeleteJobsWithResponse call
func ParseSlurmV0041DeleteJobsResponse(rsp *http.Response) (*SlurmV0041DeleteJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Status resultant status of signal request
			Status []struct {
				Error *struct {
					// Code Numeric error encountered signaling job
					Code *int32 `json:"code,omitempty"`

					// Message Error message why signaling job failed
					Message *string `json:"message,omitempty"`

					// String String error encountered signaling job
					String *string `json:"string,omitempty"`
				} `json:"error,omitempty"`
				Federation *struct {
					// Sibling Name of federation sibling (may be empty for non-federation)
					Sibling *string `json:"sibling,omitempty"`
				} `json:"federation,omitempty"`

				// JobId Job ID that signaling failed
				JobId struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"job_id"`

				// StepId Job or Step ID that signaling failed
				StepId string `json:"step_id"`
			} `json:"status"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Status resultant status of signal request
			Status []struct {
				Error *struct {
					// Code Numeric error encountered signaling job
					Code *int32 `json:"code,omitempty"`

					// Message Error message why signaling job failed
					Message *string `json:"message,omitempty"`

					// String String error encountered signaling job
					String *string `json:"string,omitempty"`
				} `json:"error,omitempty"`
				Federation *struct {
					// Sibling Name of federation sibling (may be empty for non-federation)
					Sibling *string `json:"sibling,omitempty"`
				} `json:"federation,omitempty"`

				// JobId Job ID that signaling failed
				JobId struct {
					// Infinite True if number has been set to infinite; "set" and "number" will be ignored
					Infinite *bool `json:"infinite,omitempty"`

					// Number If "set" is True the number will be set with value; otherwise ignore number contents
					Number *int32 `json:"number,omitempty"`

					// Set True if number has been set; False if number is unset
					Set *bool `json:"set,omitempty"`
				} `json:"job_id"`

				// StepId Job or Step ID that signaling failed
				StepId string `json:"step_id"`
			} `json:"status"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetJobsResponse parses an HTTP response from a SlurmV0041GetJobsWithResponse call
func ParseSlurmV0041GetJobsResponse(rsp *http.Response) (*SlurmV0041GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetJobsStateResponse parses an HTTP response from a SlurmV0041GetJobsStateWithResponse call
func ParseSlurmV0041GetJobsStateResponse(rsp *http.Response) (*SlurmV0041GetJobsStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetJobsStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetLicensesResponse parses an HTTP response from a SlurmV0041GetLicensesWithResponse call
func ParseSlurmV0041GetLicensesResponse(rsp *http.Response) (*SlurmV0041GetLicensesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetLicensesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// LastUpdate Time of last licenses change (UNIX timestamp)
			LastUpdate struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"last_update"`

			// Licenses List of licenses
			Licenses []struct {
				// Free Number of licenses currently available
				Free *int32 `json:"Free,omitempty"`

				// LastConsumed Last known number of licenses that were consumed in the license manager (Remote Only)
				LastConsumed *int32 `json:"LastConsumed,omitempty"`

				// LastDeficit Number of "missing licenses" from the cluster's perspective
				LastDeficit *int32 `json:"LastDeficit,omitempty"`

				// LastUpdate When the license information was last updated (UNIX Timestamp)
				LastUpdate *int64 `json:"LastUpdate,omitempty"`

				// LicenseName Name of the license
				LicenseName *string `json:"LicenseName,omitempty"`

				// Remote Indicates whether licenses are served by the database
				Remote *bool `json:"Remote,omitempty"`

				// Reserved Number of licenses reserved
				Reserved *int32 `json:"Reserved,omitempty"`

				// Total Total number of licenses present
				Total *int32 `json:"Total,omitempty"`

				// Used Number of licenses in use
				Used *int32 `json:"Used,omitempty"`
			} `json:"licenses"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// LastUpdate Time of last licenses change (UNIX timestamp)
			LastUpdate struct {
				// Infinite True if number has been set to infinite; "set" and "number" will be ignored
				Infinite *bool `json:"infinite,omitempty"`

				// Number If "set" is True the number will be set with value; otherwise ignore number contents
				Number *int64 `json:"number,omitempty"`

				// Set True if number has been set; False if number is unset
				Set *bool `json:"set,omitempty"`
			} `json:"last_update"`

			// Licenses List of licenses
			Licenses []struct {
				// Free Number of licenses currently available
				Free *int32 `json:"Free,omitempty"`

				// LastConsumed Last known number of licenses that were consumed in the license manager (Remote Only)
				LastConsumed *int32 `json:"LastConsumed,omitempty"`

				// LastDeficit Number of "missing licenses" from the cluster's perspective
				LastDeficit *int32 `json:"LastDeficit,omitempty"`

				// LastUpdate When the license information was last updated (UNIX Timestamp)
				LastUpdate *int64 `json:"LastUpdate,omitempty"`

				// LicenseName Name of the license
				LicenseName *string `json:"LicenseName,omitempty"`

				// Remote Indicates whether licenses are served by the database
				Remote *bool `json:"Remote,omitempty"`

				// Reserved Number of licenses reserved
				Reserved *int32 `json:"Reserved,omitempty"`

				// Total Total number of licenses present
				Total *int32 `json:"Total,omitempty"`

				// Used Number of licenses in use
				Used *int32 `json:"Used,omitempty"`
			} `json:"licenses"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteNodeResponse parses an HTTP response from a SlurmV0041DeleteNodeWithResponse call
func ParseSlurmV0041DeleteNodeResponse(rsp *http.Response) (*SlurmV0041DeleteNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetNodeResponse parses an HTTP response from a SlurmV0041GetNodeWithResponse call
func ParseSlurmV0041GetNodeResponse(rsp *http.Response) (*SlurmV0041GetNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostNodeResponse parses an HTTP response from a SlurmV0041PostNodeWithResponse call
func ParseSlurmV0041PostNodeResponse(rsp *http.Response) (*SlurmV0041PostNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetNodesResponse parses an HTTP response from a SlurmV0041GetNodesWithResponse call
func ParseSlurmV0041GetNodesResponse(rsp *http.Response) (*SlurmV0041GetNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostNodesResponse parses an HTTP response from a SlurmV0041PostNodesWithResponse call
func ParseSlurmV0041PostNodesResponse(rsp *http.Response) (*SlurmV0041PostNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetPartitionResponse parses an HTTP response from a SlurmV0041GetPartitionWithResponse call
func ParseSlurmV0041GetPartitionResponse(rsp *http.Response) (*SlurmV0041GetPartitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetPartitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetPartitionsResponse parses an HTTP response from a SlurmV0041GetPartitionsWithResponse call
func ParseSlurmV0041GetPartitionsResponse(rsp *http.Response) (*SlurmV0041GetPartitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetPingResponse parses an HTTP response from a SlurmV0041GetPingWithResponse call
func ParseSlurmV0041GetPingResponse(rsp *http.Response) (*SlurmV0041GetPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Pings pings
			Pings []struct {
				// Hostname Target for ping
				Hostname *string `json:"hostname,omitempty"`

				// Latency Number of microseconds it took to successfully ping or timeout
				Latency *int64 `json:"latency,omitempty"`

				// Mode The operating mode of the responding slurmctld
				Mode *string `json:"mode,omitempty"`

				// Pinged Ping result
				Pinged *string `json:"pinged,omitempty"`
			} `json:"pings"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Pings pings
			Pings []struct {
				// Hostname Target for ping
				Hostname *string `json:"hostname,omitempty"`

				// Latency Number of microseconds it took to successfully ping or timeout
				Latency *int64 `json:"latency,omitempty"`

				// Mode The operating mode of the responding slurmctld
				Mode *string `json:"mode,omitempty"`

				// Pinged Ping result
				Pinged *string `json:"pinged,omitempty"`
			} `json:"pings"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetReconfigureResponse parses an HTTP response from a SlurmV0041GetReconfigureWithResponse call
func ParseSlurmV0041GetReconfigureResponse(rsp *http.Response) (*SlurmV0041GetReconfigureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetReconfigureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetReservationResponse parses an HTTP response from a SlurmV0041GetReservationWithResponse call
func ParseSlurmV0041GetReservationResponse(rsp *http.Response) (*SlurmV0041GetReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetReservationsResponse parses an HTTP response from a SlurmV0041GetReservationsWithResponse call
func ParseSlurmV0041GetReservationsResponse(rsp *http.Response) (*SlurmV0041GetReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetSharesResponse parses an HTTP response from a SlurmV0041GetSharesWithResponse call
func ParseSlurmV0041GetSharesResponse(rsp *http.Response) (*SlurmV0041GetSharesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetSharesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSharesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSharesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteAccountResponse parses an HTTP response from a SlurmdbV0041DeleteAccountWithResponse call
func ParseSlurmdbV0041DeleteAccountResponse(rsp *http.Response) (*SlurmdbV0041DeleteAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// RemovedAccounts removed_accounts
			RemovedAccounts []string `json:"removed_accounts"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// RemovedAccounts removed_accounts
			RemovedAccounts []string `json:"removed_accounts"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAccountResponse parses an HTTP response from a SlurmdbV0041GetAccountWithResponse call
func ParseSlurmdbV0041GetAccountResponse(rsp *http.Response) (*SlurmdbV0041GetAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAccountsResponse parses an HTTP response from a SlurmdbV0041GetAccountsWithResponse call
func ParseSlurmdbV0041GetAccountsResponse(rsp *http.Response) (*SlurmdbV0041GetAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostAccountsResponse parses an HTTP response from a SlurmdbV0041PostAccountsWithResponse call
func ParseSlurmdbV0041PostAccountsResponse(rsp *http.Response) (*SlurmdbV0041PostAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostAccountsAssociationResponse parses an HTTP response from a SlurmdbV0041PostAccountsAssociationWithResponse call
func ParseSlurmdbV0041PostAccountsAssociationResponse(rsp *http.Response) (*SlurmdbV0041PostAccountsAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostAccountsAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AddedAccounts added_accounts
			AddedAccounts string `json:"added_accounts"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// AddedAccounts added_accounts
			AddedAccounts string `json:"added_accounts"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteAssociationResponse parses an HTTP response from a SlurmdbV0041DeleteAssociationWithResponse call
func ParseSlurmdbV0041DeleteAssociationResponse(rsp *http.Response) (*SlurmdbV0041DeleteAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAssociationResponse parses an HTTP response from a SlurmdbV0041GetAssociationWithResponse call
func ParseSlurmdbV0041GetAssociationResponse(rsp *http.Response) (*SlurmdbV0041GetAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteAssociationsResponse parses an HTTP response from a SlurmdbV0041DeleteAssociationsWithResponse call
func ParseSlurmdbV0041DeleteAssociationsResponse(rsp *http.Response) (*SlurmdbV0041DeleteAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAssociationsResponse parses an HTTP response from a SlurmdbV0041GetAssociationsWithResponse call
func ParseSlurmdbV0041GetAssociationsResponse(rsp *http.Response) (*SlurmdbV0041GetAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostAssociationsResponse parses an HTTP response from a SlurmdbV0041PostAssociationsWithResponse call
func ParseSlurmdbV0041PostAssociationsResponse(rsp *http.Response) (*SlurmdbV0041PostAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteClusterResponse parses an HTTP response from a SlurmdbV0041DeleteClusterWithResponse call
func ParseSlurmdbV0041DeleteClusterResponse(rsp *http.Response) (*SlurmdbV0041DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DeletedClusters deleted_clusters
			DeletedClusters []string `json:"deleted_clusters"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// DeletedClusters deleted_clusters
			DeletedClusters []string `json:"deleted_clusters"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetClusterResponse parses an HTTP response from a SlurmdbV0041GetClusterWithResponse call
func ParseSlurmdbV0041GetClusterResponse(rsp *http.Response) (*SlurmdbV0041GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetClustersResponse parses an HTTP response from a SlurmdbV0041GetClustersWithResponse call
func ParseSlurmdbV0041GetClustersResponse(rsp *http.Response) (*SlurmdbV0041GetClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostClustersResponse parses an HTTP response from a SlurmdbV0041PostClustersWithResponse call
func ParseSlurmdbV0041PostClustersResponse(rsp *http.Response) (*SlurmdbV0041PostClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetConfigResponse parses an HTTP response from a SlurmdbV0041GetConfigWithResponse call
func ParseSlurmdbV0041GetConfigResponse(rsp *http.Response) (*SlurmdbV0041GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdConfigResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdConfigResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostConfigResponse parses an HTTP response from a SlurmdbV0041PostConfigWithResponse call
func ParseSlurmdbV0041PostConfigResponse(rsp *http.Response) (*SlurmdbV0041PostConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetDiagResponse parses an HTTP response from a SlurmdbV0041GetDiagWithResponse call
func ParseSlurmdbV0041GetDiagResponse(rsp *http.Response) (*SlurmdbV0041GetDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Statistics statistics
			Statistics struct {
				// RPCs List of RPCs sent to the slurmdbd
				RPCs *[]struct {
					// Count Number of RPCs processed
					Count *int32 `json:"count,omitempty"`

					// Rpc RPC type
					Rpc  *string `json:"rpc,omitempty"`
					Time *struct {
						// Average Average RPC processing time in microseconds
						Average *int64 `json:"average,omitempty"`

						// Total Total RPC processing time in microseconds
						Total *int64 `json:"total,omitempty"`
					} `json:"time,omitempty"`
				} `json:"RPCs,omitempty"`

				// Rollups Rollup statistics
				Rollups *struct {
					Daily *struct {
						// Count Number of daily rollups since last_run
						Count    *int32 `json:"count,omitempty"`
						Duration *struct {
							// Last Total time spent doing daily daily rollup (seconds)
							Last *int64 `json:"last,omitempty"`

							// Max Longest daily rollup time (seconds)
							Max *int64 `json:"max,omitempty"`

							// Time Total time spent doing daily rollups (seconds)
							Time *int64 `json:"time,omitempty"`
						} `json:"duration,omitempty"`

						// LastRun Last time daily rollup ran (UNIX timestamp)
						LastRun *int64 `json:"last_run,omitempty"`
					} `json:"daily,omitempty"`
					Hourly *struct {
						// Count Number of hourly rollups since last_run
						Count    *int32 `json:"count,omitempty"`
						Duration *struct {
							// Last Total time spent doing last daily rollup (seconds)
							Last *int64 `json:"last,omitempty"`

							// Max Longest hourly rollup time (seconds)
							Max *int64 `json:"max,omitempty"`

							// Time Total time spent doing hourly rollups (seconds)
							Time *int64 `json:"time,omitempty"`
						} `json:"duration,omitempty"`

						// LastRun Last time hourly rollup ran (UNIX timestamp)
						LastRun *int64 `json:"last_run,omitempty"`
					} `json:"hourly,omitempty"`
					Monthly *struct {
						// Count Number of monthly rollups since last_run
						Count    *int32 `json:"count,omitempty"`
						Duration *struct {
							// Last Total time spent doing monthly daily rollup (seconds)
							Last *int64 `json:"last,omitempty"`

							// Max Longest monthly rollup time (seconds)
							Max *int64 `json:"max,omitempty"`

							// Time Total time spent doing monthly rollups (seconds)
							Time *int64 `json:"time,omitempty"`
						} `json:"duration,omitempty"`

						// LastRun Last time monthly rollup ran (UNIX timestamp)
						LastRun *int64 `json:"last_run,omitempty"`
					} `json:"monthly,omitempty"`
				} `json:"rollups,omitempty"`

				// TimeStart When data collection started (UNIX timestamp)
				TimeStart *int64 `json:"time_start,omitempty"`

				// Users List of users that issued RPCs
				Users *[]struct {
					// Count Number of RPCs processed
					Count *int32 `json:"count,omitempty"`
					Time  *struct {
						// Average Average RPC processing time in microseconds
						Average *int64 `json:"average,omitempty"`

						// Total Total RPC processing time in microseconds
						Total *int64 `json:"total,omitempty"`
					} `json:"time,omitempty"`

					// User User ID
					User *string `json:"user,omitempty"`
				} `json:"users,omitempty"`
			} `json:"statistics"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Statistics statistics
			Statistics struct {
				// RPCs List of RPCs sent to the slurmdbd
				RPCs *[]struct {
					// Count Number of RPCs processed
					Count *int32 `json:"count,omitempty"`

					// Rpc RPC type
					Rpc  *string `json:"rpc,omitempty"`
					Time *struct {
						// Average Average RPC processing time in microseconds
						Average *int64 `json:"average,omitempty"`

						// Total Total RPC processing time in microseconds
						Total *int64 `json:"total,omitempty"`
					} `json:"time,omitempty"`
				} `json:"RPCs,omitempty"`

				// Rollups Rollup statistics
				Rollups *struct {
					Daily *struct {
						// Count Number of daily rollups since last_run
						Count    *int32 `json:"count,omitempty"`
						Duration *struct {
							// Last Total time spent doing daily daily rollup (seconds)
							Last *int64 `json:"last,omitempty"`

							// Max Longest daily rollup time (seconds)
							Max *int64 `json:"max,omitempty"`

							// Time Total time spent doing daily rollups (seconds)
							Time *int64 `json:"time,omitempty"`
						} `json:"duration,omitempty"`

						// LastRun Last time daily rollup ran (UNIX timestamp)
						LastRun *int64 `json:"last_run,omitempty"`
					} `json:"daily,omitempty"`
					Hourly *struct {
						// Count Number of hourly rollups since last_run
						Count    *int32 `json:"count,omitempty"`
						Duration *struct {
							// Last Total time spent doing last daily rollup (seconds)
							Last *int64 `json:"last,omitempty"`

							// Max Longest hourly rollup time (seconds)
							Max *int64 `json:"max,omitempty"`

							// Time Total time spent doing hourly rollups (seconds)
							Time *int64 `json:"time,omitempty"`
						} `json:"duration,omitempty"`

						// LastRun Last time hourly rollup ran (UNIX timestamp)
						LastRun *int64 `json:"last_run,omitempty"`
					} `json:"hourly,omitempty"`
					Monthly *struct {
						// Count Number of monthly rollups since last_run
						Count    *int32 `json:"count,omitempty"`
						Duration *struct {
							// Last Total time spent doing monthly daily rollup (seconds)
							Last *int64 `json:"last,omitempty"`

							// Max Longest monthly rollup time (seconds)
							Max *int64 `json:"max,omitempty"`

							// Time Total time spent doing monthly rollups (seconds)
							Time *int64 `json:"time,omitempty"`
						} `json:"duration,omitempty"`

						// LastRun Last time monthly rollup ran (UNIX timestamp)
						LastRun *int64 `json:"last_run,omitempty"`
					} `json:"monthly,omitempty"`
				} `json:"rollups,omitempty"`

				// TimeStart When data collection started (UNIX timestamp)
				TimeStart *int64 `json:"time_start,omitempty"`

				// Users List of users that issued RPCs
				Users *[]struct {
					// Count Number of RPCs processed
					Count *int32 `json:"count,omitempty"`
					Time  *struct {
						// Average Average RPC processing time in microseconds
						Average *int64 `json:"average,omitempty"`

						// Total Total RPC processing time in microseconds
						Total *int64 `json:"total,omitempty"`
					} `json:"time,omitempty"`

					// User User ID
					User *string `json:"user,omitempty"`
				} `json:"users,omitempty"`
			} `json:"statistics"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetInstanceResponse parses an HTTP response from a SlurmdbV0041GetInstanceWithResponse call
func ParseSlurmdbV0041GetInstanceResponse(rsp *http.Response) (*SlurmdbV0041GetInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetInstancesResponse parses an HTTP response from a SlurmdbV0041GetInstancesWithResponse call
func ParseSlurmdbV0041GetInstancesResponse(rsp *http.Response) (*SlurmdbV0041GetInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetJobResponse parses an HTTP response from a SlurmdbV0041GetJobWithResponse call
func ParseSlurmdbV0041GetJobResponse(rsp *http.Response) (*SlurmdbV0041GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetJobsResponse parses an HTTP response from a SlurmdbV0041GetJobsWithResponse call
func ParseSlurmdbV0041GetJobsResponse(rsp *http.Response) (*SlurmdbV0041GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetQosResponse parses an HTTP response from a SlurmdbV0041GetQosWithResponse call
func ParseSlurmdbV0041GetQosResponse(rsp *http.Response) (*SlurmdbV0041GetQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostQosResponse parses an HTTP response from a SlurmdbV0041PostQosWithResponse call
func ParseSlurmdbV0041PostQosResponse(rsp *http.Response) (*SlurmdbV0041PostQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteSingleQosResponse parses an HTTP response from a SlurmdbV0041DeleteSingleQosWithResponse call
func ParseSlurmdbV0041DeleteSingleQosResponse(rsp *http.Response) (*SlurmdbV0041DeleteSingleQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteSingleQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// RemovedQos removed QOS
			RemovedQos []string `json:"removed_qos"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// RemovedQos removed QOS
			RemovedQos []string `json:"removed_qos"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetSingleQosResponse parses an HTTP response from a SlurmdbV0041GetSingleQosWithResponse call
func ParseSlurmdbV0041GetSingleQosResponse(rsp *http.Response) (*SlurmdbV0041GetSingleQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetSingleQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetTresResponse parses an HTTP response from a SlurmdbV0041GetTresWithResponse call
func ParseSlurmdbV0041GetTresResponse(rsp *http.Response) (*SlurmdbV0041GetTresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetTresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiTresResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiTresResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostTresResponse parses an HTTP response from a SlurmdbV0041PostTresWithResponse call
func ParseSlurmdbV0041PostTresResponse(rsp *http.Response) (*SlurmdbV0041PostTresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostTresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteUserResponse parses an HTTP response from a SlurmdbV0041DeleteUserWithResponse call
func ParseSlurmdbV0041DeleteUserResponse(rsp *http.Response) (*SlurmdbV0041DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetUserResponse parses an HTTP response from a SlurmdbV0041GetUserWithResponse call
func ParseSlurmdbV0041GetUserResponse(rsp *http.Response) (*SlurmdbV0041GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetUsersResponse parses an HTTP response from a SlurmdbV0041GetUsersWithResponse call
func ParseSlurmdbV0041GetUsersResponse(rsp *http.Response) (*SlurmdbV0041GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostUsersResponse parses an HTTP response from a SlurmdbV0041PostUsersWithResponse call
func ParseSlurmdbV0041PostUsersResponse(rsp *http.Response) (*SlurmdbV0041PostUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostUsersAssociationResponse parses an HTTP response from a SlurmdbV0041PostUsersAssociationWithResponse call
func ParseSlurmdbV0041PostUsersAssociationResponse(rsp *http.Response) (*SlurmdbV0041PostUsersAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostUsersAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AddedUsers added_users
			AddedUsers string `json:"added_users"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// AddedUsers added_users
			AddedUsers string `json:"added_users"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteWckeyResponse parses an HTTP response from a SlurmdbV0041DeleteWckeyWithResponse call
func ParseSlurmdbV0041DeleteWckeyResponse(rsp *http.Response) (*SlurmdbV0041DeleteWckeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteWckeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DeletedWckeys deleted wckeys
			DeletedWckeys []string `json:"deleted_wckeys"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// DeletedWckeys deleted wckeys
			DeletedWckeys []string `json:"deleted_wckeys"`

			// Errors Query errors
			Errors *[]struct {
				// Description Long form error description
				Description *string `json:"description,omitempty"`

				// Error Short form error description
				Error *string `json:"error,omitempty"`

				// ErrorNumber Slurm numeric error identifier
				ErrorNumber *int32 `json:"error_number,omitempty"`

				// Source Source of error or where error was first detected
				Source *string `json:"source,omitempty"`
			} `json:"errors,omitempty"`

			// Meta Slurm meta values
			Meta *struct {
				Client *struct {
					// Group Client group (if known)
					Group *string `json:"group,omitempty"`

					// Source Client source description
					Source *string `json:"source,omitempty"`

					// User Client user (if known)
					User *string `json:"user,omitempty"`
				} `json:"client,omitempty"`

				// Command CLI command (if applicable)
				Command *[]string `json:"command,omitempty"`
				Plugin  *struct {
					// AccountingStorage Slurm accounting plugin
					AccountingStorage *string `json:"accounting_storage,omitempty"`

					// DataParser Slurm data_parser plugin
					DataParser *string `json:"data_parser,omitempty"`

					// Name Slurm plugin name (if applicable)
					Name *string `json:"name,omitempty"`

					// Type Slurm plugin type (if applicable)
					Type *string `json:"type,omitempty"`
				} `json:"plugin,omitempty"`
				Slurm *struct {
					// Cluster Slurm cluster name
					Cluster *string `json:"cluster,omitempty"`

					// Release Slurm release string
					Release *string `json:"release,omitempty"`
					Version *struct {
						// Major Slurm release major version
						Major *string `json:"major,omitempty"`

						// Micro Slurm release micro version
						Micro *string `json:"micro,omitempty"`

						// Minor Slurm release minor version
						Minor *string `json:"minor,omitempty"`
					} `json:"version,omitempty"`
				} `json:"slurm,omitempty"`
			} `json:"meta,omitempty"`

			// Warnings Query warnings
			Warnings *[]struct {
				// Description Long form warning description
				Description *string `json:"description,omitempty"`

				// Source Source of warning or where warning was first detected
				Source *string `json:"source,omitempty"`
			} `json:"warnings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetWckeyResponse parses an HTTP response from a SlurmdbV0041GetWckeyWithResponse call
func ParseSlurmdbV0041GetWckeyResponse(rsp *http.Response) (*SlurmdbV0041GetWckeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetWckeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetWckeysResponse parses an HTTP response from a SlurmdbV0041GetWckeysWithResponse call
func ParseSlurmdbV0041GetWckeysResponse(rsp *http.Response) (*SlurmdbV0041GetWckeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetWckeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostWckeysResponse parses an HTTP response from a SlurmdbV0041PostWckeysWithResponse call
func ParseSlurmdbV0041PostWckeysResponse(rsp *http.Response) (*SlurmdbV0041PostWckeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostWckeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"ZeQBHbzwQOVGB7ZvIXasDku8JAZHzCAjSwY4AxDb/S+zzX5RHb2G36/v33zz5pu/vX39mS1f6x6BRMYM",
	"pQgFfQ7ickV9fPPmb28nTMjv2VJLyI4JPhXyHYu3X6A6+XRbPt2WT7fl021530qfbsun2/Lptny6LZ9u",
	"y6fb8um2fLotn27Lp9vy6bZ8ui2fbsun2/J+xj7dlk+35dNt+XRbPt2WT7fl0235dFs+3ZZPt+XTbfl0",
	"Wz7dlk+35dNt+XRb3kXAp9vy6bZ8ui2fbsun2/Lptny6LZ9uy6fb8um2fLotn27Lp9vy6bZ8ui2fbssf",
	"pn26LZ9uy6fb8um2PEV9ui1PVZ9uy5PSp9vy6bY8+Xy6LZ9uy6fb8um2fLotn27Lm5N9ui2fbsun2/Lp",
	"tny6LZ9uy6fb8gqDT7fl0235dFs+3ZZPt+XTbfl0W39Qui0IwrasZ2Oq2QdLdqBue9Rkj5rsUZM9arJH",
	"TfaoyR412aMme9Rkj5rsUZM9arJHTfaoyR412aMme9Rkj5rsUZP9dZFHTfaoyR412aMme9Rkj5rsUZM9",
	"arJHTfaoyR412aMme9Rkj5rsUZM9pq5HTfYU9qjJHjXZoyZ71GSPmuxRkz1qskdN9qjJHjXZoyZ71GSP",
	"muxRkz1qskdN9hCeHjXZk9KjJnuKetRkT1WPmuxRkz1qskdN9uTzqMkeNdmjJnuSetRkj5rsUZM9arJH",
	"TfaoyR412aMme9Rkj5rsUZM9arJHTfaoyR412aMme9Rkj5r8NVCTj45TNWPPoTfxoXdiWf4PNDEGHXOy",
	"QytKklitQnXS/tebX5A+BrbBU/rv/76y2JnqT7R7V87KaNBv37zR6G8g/MCBKs8To7y+/iy0BiuiDUmx",
	"BfdLHRut7qGKrZhSJ2T03jvHt5TZWi2gVDdzAEJ9RGvHAXa2YVye20zoUjhmScHB+ZJwGpkGwUhPV5S0",
	"NjcUPLIaGQDjma1Mu4yjhw3hxPz5gIUxDMZEAupNO3ytwyXqwg2YVYCw5yAIqNY0lCzEzIapWNtNnVBJ",
	"CMX9ADoiJULgNbGHc9r8S/TUqzIjzo4BDBNqVvD+cwfyRA+qIyhFL+gK3WXsIbPDqTlIZpow6NwnVpY9",
	"ptg0AXPSNAi7t5wLsXE4QKYQGjU7epmQl2dZh4ynuQvqHcLYJeOKjg561aDZK7d1C5CjxGGOuXBvuVqV",
	"hobs4Uu6Bf0WxDFZ5sQxFY1NqSqnm7IaclUzx9NqAJdd3ZbQzq5QLANb4nq9RDUxL1gauCf8/2fvapvb",
	"tpX1X8HonJmbzPjUPTNn7of2k2orOepxbNcvTe9tMxqIhCwkFKEQYBzdTP77HSwAipRICaBeTCf7pY1F",
	"AFwCi8WDxWIfaU1xVbAZfS+ybe1CIeLaqL1UGGViayu60OZWUg9ZdKHmVnxObhriufPEa3mvmrw1U9Ww",
	"WA3A0m8wjWZ1imp3PaZy5O2saloILtkjOJ33ugS8Md9kA9wzczC9rLlhTkvF5hvlhCjyujzZ9UeuDa0t",
	"l7/bpvb03gJydzTineL5rojHZbvZsqRshxKuoQJMuB/2Ayd8AOj76urvwKdJPjmhdkIh/kT8ifgT8Sfi",
	"T8SfiD8RfyL+RPx5YPypPyCfzWi20O80epCaQdWyQFqIP62tfKdLn8K/Tz/9+MOPP/zrn6fvxfj0i9Hi",
	"r6YPEmZOSHWPA34dxs40/P7jj//65zmU+NWQb9CMzpjhV/qzMYkn+zxPYLZBKtKTnl4Ne3Oqpj232rh5",
	"tLw+7izCEjPXKPUigV/4bJ5oKL4lC6ESxEhdK89HrXxLgYoUnR4CaG1rfD2QVbkczT5vdmWXL/42EklW",
	"e+vdjh78v2ds0vup97fTIsJUnpqn0un2SMxZSud8pF/UOKmMjthFqeV27kDCVOZ2RNOIJdoG2VL1M/yk",
	"92AOdZum72sIwe383H0F6dINb4PkacRIPo+pYsu0+J7TyVQzufd3mc1mcdrPRO5DfvDzwZ3JGvpm+Ack",
	"u3bJGO0MrMxdmNN39w1cV083t2Dw04nYpNcv5Euiy1hizmPMslZiVebbA1OAjHSJ2nk2t6e9TRPtWsgu",
	"zrR3NtuMVL+IeLGD1wqpcpEqF6lykSoXqXKRKhepcpEqF6lykSoXqXKRKhepcpEqF6lykSoXqXKRKhep",
	"cvGOIFLlIlUuUuUiVS5S5SJVLlLlIlUuUuUiVS5S5SJVLlLlIlUuUuUikSpS5eIII1UuUuUiVS5S5SJV",
	"LlLlIlUuUuUiVS5S5SJVLlLlIlUuUuUiVS5S5SJvI1Ll4lAiVS6OKFLl4qgiVS5S5SJVLlLl4vAhVS5S",
	"5SJVLg4pUuUiVS5S5SJVLlLlIlUuUuUiVS5S5SJVLlLlIlUuUuUiVS5S5SJVLlLlIlXu7lS59by0Ni85",
	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
