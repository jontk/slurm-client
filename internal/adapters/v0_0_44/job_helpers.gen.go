// Code generated by generate_adapters.go. DO NOT EDIT.
// SPDX-FileCopyrightText: 2025 Jon Thor Kristinsson
// SPDX-License-Identifier: Apache-2.0

package v0_0_44

import (
	"context"

	types "github.com/jontk/slurm-client/api"
	"github.com/jontk/slurm-client/internal/common"
	api "github.com/jontk/slurm-client/internal/openapi/v0_0_44"
	"github.com/jontk/slurm-client/pkg/errors"
	"strconv"
)

// holdJobImpl implements the Hold method
func (a *JobAdapter) holdJobImpl(ctx context.Context, req *types.JobHoldRequest) error {
	// Validate context
	if err := a.ValidateContext(ctx); err != nil {
		return err
	}

	// Validate job ID
	if err := a.ValidateResourceID(req.JobId, "jobID"); err != nil {
		return err
	}

	// Check client initialization
	if err := a.CheckClientInitialized(a.client); err != nil {
		return err
	}

	// Build job update request with hold flag
	updateReq := api.V0044JobDescMsg{
		Hold: &req.Hold,
	}

	// If priority is specified, include it
	if req.Priority != 0 {
		priority := api.V0044Uint32NoValStruct{
			Set:    ptrBool(true),
			Number: ptrInt32(req.Priority),
		}
		updateReq.Priority = &priority
	}

	// Call the API to update the job
	resp, err := a.client.SlurmV0044PostJobWithResponse(ctx, strconv.Itoa(int(req.JobId)), updateReq)
	if err != nil {
		return a.HandleAPIError(err)
	}

	// Handle response errors
	var apiErrors *api.V0044OpenapiErrors
	if resp.JSON200 != nil {
		apiErrors = resp.JSON200.Errors
	} else if resp.JSONDefault != nil {
		apiErrors = resp.JSONDefault.Errors
	}
	responseAdapter := api.NewResponseAdapter(resp.StatusCode(), apiErrors)
	if err := common.HandleAPIResponse(responseAdapter, "v0.0.44"); err != nil {
		return err
	}

	return nil
}

// signalJobImpl implements the Signal method
func (a *JobAdapter) signalJobImpl(ctx context.Context, req *types.JobSignalRequest) error {
	// Validate context
	if err := a.ValidateContext(ctx); err != nil {
		return err
	}

	// Validate job ID
	if err := a.ValidateResourceID(req.JobId, "jobID"); err != nil {
		return err
	}

	// Validate signal
	if req.Signal == "" {
		return errors.NewValidationError(errors.ErrorCodeValidationFailed, "signal is required", "signal", nil, nil)
	}

	// Check client initialization
	if err := a.CheckClientInitialized(a.client); err != nil {
		return err
	}

	// The SLURM REST API uses DELETE with a signal parameter to send signals to jobs
	params := &api.SlurmV0044DeleteJobParams{
		Signal: &req.Signal,
	}

	// Call the API to signal the job
	resp, err := a.client.SlurmV0044DeleteJobWithResponse(ctx, strconv.Itoa(int(req.JobId)), params)
	if err != nil {
		return a.HandleAPIError(err)
	}

	// Handle response errors
	var apiErrors *api.V0044OpenapiErrors
	if resp.JSON200 != nil {
		apiErrors = resp.JSON200.Errors
	} else if resp.JSONDefault != nil {
		apiErrors = resp.JSONDefault.Errors
	}
	responseAdapter := api.NewResponseAdapter(resp.StatusCode(), apiErrors)
	if err := common.HandleAPIResponse(responseAdapter, "v0.0.44"); err != nil {
		return err
	}

	return nil
}

// notifyJobImpl implements the Notify method
func (a *JobAdapter) notifyJobImpl(ctx context.Context, req *types.JobNotifyRequest) error {
	// Validate context
	if err := a.ValidateContext(ctx); err != nil {
		return err
	}

	// Validate job ID
	if err := a.ValidateResourceID(req.JobId, "jobID"); err != nil {
		return err
	}

	// Validate message
	if req.Message == "" {
		return errors.NewValidationError(errors.ErrorCodeValidationFailed, "message is required", "message", nil, nil)
	}

	// Job notification (scontrol notify) is not supported in SLURM REST API
	return errors.NewClientError(
		errors.ErrorCodeUnsupportedOperation,
		"Job notification is not supported via REST API v0.0.44. Use 'scontrol notify' command instead",
		"operation not supported in REST API",
	)
}

// requeueJobImpl implements the Requeue method
func (a *JobAdapter) requeueJobImpl(ctx context.Context, jobID int32) error {
	// Validate context
	if err := a.ValidateContext(ctx); err != nil {
		return err
	}

	// Validate job ID
	if err := a.ValidateResourceID(jobID, "jobID"); err != nil {
		return err
	}

	// Check client initialization
	if err := a.CheckClientInitialized(a.client); err != nil {
		return err
	}

	// Job requeue uses DELETE with FEDERATION_REQUEUE flag
	requeueFlag := api.SlurmV0044DeleteJobParamsFlagsFEDERATIONREQUEUE
	params := &api.SlurmV0044DeleteJobParams{
		Flags: &requeueFlag,
	}

	// Call the API to requeue the job
	resp, err := a.client.SlurmV0044DeleteJobWithResponse(ctx, strconv.Itoa(int(jobID)), params)
	if err != nil {
		return a.HandleAPIError(err)
	}

	// Handle response errors
	var apiErrors *api.V0044OpenapiErrors
	if resp.JSON200 != nil {
		apiErrors = resp.JSON200.Errors
	} else if resp.JSONDefault != nil {
		apiErrors = resp.JSONDefault.Errors
	}
	responseAdapter := api.NewResponseAdapter(resp.StatusCode(), apiErrors)
	if err := common.HandleAPIResponse(responseAdapter, "v0.0.44"); err != nil {
		return err
	}

	return nil
}

// NOTE: watchJobsImpl is intentionally NOT generated here.
// The real implementation is in job_watch_extra.go which uses polling.

// allocateJobImpl implements the Allocate method
func (a *JobAdapter) allocateJobImpl(ctx context.Context, req *types.JobAllocateRequest) (*types.JobAllocateResponse, error) {
	// Validate context
	if err := a.ValidateContext(ctx); err != nil {
		return nil, err
	}

	if req == nil {
		return nil, errors.NewValidationError(errors.ErrorCodeValidationFailed, "allocate request is required", "request", nil, nil)
	}

	// Check client initialization
	if err := a.CheckClientInitialized(a.client); err != nil {
		return nil, err
	}

	// Build job allocation request
	jobDesc := &api.V0044JobDescMsg{}

	// Basic metadata
	if req.Name != "" {
		jobDesc.Name = &req.Name
	}
	if req.Account != "" {
		jobDesc.Account = &req.Account
	}
	if req.Partition != "" {
		jobDesc.Partition = &req.Partition
	}
	if req.QoS != "" {
		jobDesc.Qos = &req.QoS
	}

	// Resource requirements
	if req.Nodes != "" {
		// Nodes can be a number (e.g., "2") or range (e.g., "1-4")
		jobDesc.Nodes = &req.Nodes
	}
	if req.Cpus > 0 {
		jobDesc.MinimumCpus = &req.Cpus
	}
	if req.Memory != "" {
		// Parse memory specification (e.g., "4096" for MB, "4G" for GB)
		memVal, err := common.ParseMemory(req.Memory)
		if err == nil && memVal > 0 {
			memPerNode := &api.V0044Uint64NoValStruct{}
			memPerNode.Number = &memVal
			memPerNode.Set = ptrBool(true)
			jobDesc.MemoryPerNode = memPerNode
		}
	}
	if req.TimeLimit > 0 {
		timeLimit := &api.V0044Uint32NoValStruct{}
		val := int32(req.TimeLimit)
		timeLimit.Number = &val
		timeLimit.Set = ptrBool(true)
		jobDesc.TimeLimit = timeLimit
	}

	// Environment and execution
	if req.WorkingDir != "" {
		jobDesc.CurrentWorkingDirectory = &req.WorkingDir
	}
	if len(req.Environment) > 0 {
		envArray := &api.V0044StringArray{}
		for key, value := range req.Environment {
			envStr := key + "=" + value
			*envArray = append(*envArray, envStr)
		}
		jobDesc.Environment = envArray
	}
	if len(req.Command) > 0 {
		cmdArray := &api.V0044StringArray{}
		*cmdArray = append(*cmdArray, req.Command...)
		jobDesc.Argv = cmdArray
	}

	allocReq := api.V0044JobAllocReq{
		Job: jobDesc,
	}

	// Call the API
	resp, err := a.client.SlurmV0044PostJobAllocateWithResponse(ctx, allocReq)
	if err != nil {
		return nil, a.HandleAPIError(err)
	}

	// Handle response errors
	var apiErrors *api.V0044OpenapiErrors
	if resp.JSON200 != nil {
		apiErrors = resp.JSON200.Errors
	} else if resp.JSONDefault != nil {
		apiErrors = resp.JSONDefault.Errors
	}
	responseAdapter := api.NewResponseAdapter(resp.StatusCode(), apiErrors)
	if err := common.HandleAPIResponse(responseAdapter, "V0044"); err != nil {
		return nil, err
	}

	// Convert response
	if resp.JSON200 == nil {
		return nil, errors.NewClientError(errors.ErrorCodeInvalidRequest, "empty response from server", "no response body")
	}

	return a.convertAPIJobAllocateResponseToCommon(resp.JSON200), nil
}

// convertCommonJobUpdateToAPIRequestBody converts JobUpdate to the API request body type
func (a *JobAdapter) convertCommonJobUpdateToAPIRequestBody(update *types.JobUpdate) api.SlurmV0044PostJobJSONRequestBody {
	if update == nil {
		return api.SlurmV0044PostJobJSONRequestBody{}
	}
	// JobUpdate is an alias for JobCreate, so we can use the same converter
	// This delegates to the goverter-generated ConvertCommonJobCreateToAPI
	result := jobWriteConverter.ConvertCommonJobCreateToAPI(update)
	if result == nil {
		return api.SlurmV0044PostJobJSONRequestBody{}
	}
	return *result
}

// convertAPIJobSubmitResponseToCommon converts API job submit response to common type
func (a *JobAdapter) convertAPIJobSubmitResponseToCommon(resp *api.V0044OpenapiJobSubmitResponse) *types.JobSubmitResponse {
	if resp == nil {
		return nil
	}

	result := &types.JobSubmitResponse{}

	// Extract job ID
	if resp.JobId != nil {
		result.JobId = *resp.JobId
	}

	// Extract step ID
	if resp.StepId != nil {
		result.StepId = *resp.StepId
	}

	// Extract user message
	if resp.JobSubmitUserMsg != nil {
		result.JobSubmitUserMsg = *resp.JobSubmitUserMsg
	}

	// Extract errors
	if resp.Errors != nil {
		for _, e := range *resp.Errors {
			if e.Error != nil {
				result.Error = append(result.Error, *e.Error)
			}
		}
	}

	// Extract warnings
	if resp.Warnings != nil {
		for _, w := range *resp.Warnings {
			if w.Description != nil {
				result.Warning = append(result.Warning, *w.Description)
			}
		}
	}

	return result
}

// convertAPIJobAllocateResponseToCommon converts API job allocate response to common type
func (a *JobAdapter) convertAPIJobAllocateResponseToCommon(resp *api.V0044OpenapiJobAllocResp) *types.JobAllocateResponse {
	if resp == nil {
		return nil
	}

	result := &types.JobAllocateResponse{
		Status: "allocated",
	}

	// Extract job ID
	if resp.JobId != nil {
		result.JobId = *resp.JobId
	}

	// Extract message
	if resp.JobSubmitUserMsg != nil {
		result.Message = *resp.JobSubmitUserMsg
	}

	return result
}

// Helper functions for pointer creation
func ptrBool(b bool) *bool {
	return &b
}

func ptrInt32(i int32) *int32 {
	return &i
}
