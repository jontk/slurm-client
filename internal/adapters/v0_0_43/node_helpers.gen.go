// Code generated by generate_adapters.go. DO NOT EDIT.
// SPDX-FileCopyrightText: 2025 Jon Thor Kristinsson
// SPDX-License-Identifier: Apache-2.0

package v0_0_43

import (
	"context"

	types "github.com/jontk/slurm-client/api"
	"github.com/jontk/slurm-client/internal/common"
	api "github.com/jontk/slurm-client/internal/openapi/v0_0_43"
)

// drainNodeImpl implements the Drain method
func (a *NodeAdapter) drainNodeImpl(ctx context.Context, nodeName string, reason string) error {
	// Validate context
	if err := a.ValidateContext(ctx); err != nil {
		return err
	}

	// Validate node name
	if err := a.ValidateResourceName(nodeName, "nodeName"); err != nil {
		return err
	}

	// Check client initialization
	if err := a.CheckClientInitialized(a.client); err != nil {
		return err
	}

	// Build node update request with DRAIN state
	drainState := api.V0043UpdateNodeMsgStateDRAIN
	updateReq := api.V0043UpdateNodeMsg{
		State: &[]api.V0043UpdateNodeMsgState{drainState},
	}

	if reason != "" {
		updateReq.Reason = &reason
	}

	// Call the API to update the node
	resp, err := a.client.SlurmV0043PostNodeWithResponse(ctx, nodeName, updateReq)
	if err != nil {
		return a.HandleAPIError(err)
	}

	// Handle response errors
	var apiErrors *api.V0043OpenapiErrors
	if resp.JSON200 != nil {
		apiErrors = resp.JSON200.Errors
	} else if resp.JSONDefault != nil {
		apiErrors = resp.JSONDefault.Errors
	}
	responseAdapter := api.NewResponseAdapter(resp.StatusCode(), apiErrors)
	if err := common.HandleAPIResponse(responseAdapter, "v0.0.43"); err != nil {
		return err
	}

	return nil
}

// resumeNodeImpl implements the Resume method
func (a *NodeAdapter) resumeNodeImpl(ctx context.Context, nodeName string) error {
	// Validate context
	if err := a.ValidateContext(ctx); err != nil {
		return err
	}

	// Validate node name
	if err := a.ValidateResourceName(nodeName, "nodeName"); err != nil {
		return err
	}

	// Check client initialization
	if err := a.CheckClientInitialized(a.client); err != nil {
		return err
	}

	// Build node update request with RESUME state
	resumeState := api.V0043UpdateNodeMsgStateRESUME
	updateReq := api.V0043UpdateNodeMsg{
		State: &[]api.V0043UpdateNodeMsgState{resumeState},
	}

	// Call the API to update the node
	resp, err := a.client.SlurmV0043PostNodeWithResponse(ctx, nodeName, updateReq)
	if err != nil {
		return a.HandleAPIError(err)
	}

	// Handle response errors
	var apiErrors *api.V0043OpenapiErrors
	if resp.JSON200 != nil {
		apiErrors = resp.JSON200.Errors
	} else if resp.JSONDefault != nil {
		apiErrors = resp.JSONDefault.Errors
	}
	responseAdapter := api.NewResponseAdapter(resp.StatusCode(), apiErrors)
	if err := common.HandleAPIResponse(responseAdapter, "v0.0.43"); err != nil {
		return err
	}

	return nil
}

// NOTE: watchNodesImpl is intentionally NOT generated here.
// The real implementation is in node_watch_extra.go which uses polling.

// convertCommonNodeUpdateToAPIRequestBody converts NodeUpdate to the API request body type
func (a *NodeAdapter) convertCommonNodeUpdateToAPIRequestBody(update *types.NodeUpdate) api.SlurmV0043PostNodeJSONRequestBody {
	if update == nil {
		return api.SlurmV0043PostNodeJSONRequestBody{}
	}
	// Delegate to the goverter-generated ConvertCommonNodeUpdateToAPI
	result := nodeWriteConverter.ConvertCommonNodeUpdateToAPI(update)
	if result == nil {
		return api.SlurmV0043PostNodeJSONRequestBody{}
	}
	return *result
}
